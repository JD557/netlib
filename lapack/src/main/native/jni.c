/*
 * Copyright 2020, 2021, Ludovic Henry
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Please contact git@ludovic.dev or visit ludovic.dev if you need additional
 * information or have any questions.
 */

#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

#include "dev_ludovic_netlib_lapack_JNILAPACK.h"

#define UNUSED __attribute__((unused))

#define TRUE 1
#define FALSE 0

static jfieldID booleanW_val_fieldID;
static jfieldID intW_val_fieldID;
static jfieldID floatW_val_fieldID;
static jfieldID doubleW_val_fieldID;
static jfieldID StringW_val_fieldID;

static void *lapack;

static void throwOOM(JNIEnv *env) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/OutOfMemoryError"), "Failed to copy from heap to native memory");
}

static void (*dbdsdc_)(const char *uplo, const char *compq, int *n, double *d, double *e, double *u, int *ldu, double *vt, int *ldvt, double *q, int *iq, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dbdsdcK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring compq, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray q, jint offsetq, jintArray iq, jint offsetiq, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ncompq = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nu = NULL; double *__nvt = NULL; double *__nq = NULL; int *__niq = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__niq = (*env)->GetPrimitiveArrayCritical(env, iq, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dbdsdc_(__nuplo, __ncompq, &n, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nq + offsetq, __niq + offsetiq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niq) (*env)->ReleasePrimitiveArrayCritical(env, iq, __niq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dbdsqr_)(const char *uplo, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, double *vt, int *ldvt, double *u, int *ldu, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dbdsqrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint ncvt, jint nru, jint ncc, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nvt = NULL; double *__nu = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dbdsqr_(__nuplo, &n, &ncvt, &nru, &ncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &ldvt, __nu + offsetu, &ldu, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ddisna_)(const char *job, int *m, int *n, double *d, double *sep, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ddisnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jint m, jint n, jdoubleArray d, jint offsetd, jdoubleArray sep, jint offsetsep, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __ninfo = 0; double *__nd = NULL; double *__nsep = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) goto fail;
  ddisna_(__njob, &m, &n, __nd + offsetd, __nsep + offsetsep, &__ninfo);
done:
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbbrd_)(const char *vect, int *m, int *n, int *ncc, int *kl, int *ku, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *pt, int *ldpt, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbbrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint ncc, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray pt, jint offsetpt, jint ldpt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; int __ninfo = 0; double *__nab = NULL; double *__nd = NULL; double *__ne = NULL; double *__nq = NULL; double *__npt = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__npt = (*env)->GetPrimitiveArrayCritical(env, pt, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgbbrd_(__nvect, &m, &n, &ncc, &kl, &ku, __nab + offsetab, &ldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __npt + offsetpt, &ldpt, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__npt) (*env)->ReleasePrimitiveArrayCritical(env, pt, __npt, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbcon_)(const char *norm, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double __nrcond = 0; int __ninfo = 0; double *__nab = NULL; int *__nipiv = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgbcon_(__nnorm, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbequ_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  jboolean failed = FALSE;
  double __nrowcnd = 0; double __ncolcnd = 0; double __namax = 0; int __ninfo = 0; double *__nab = NULL; double *__nr = NULL; double *__nc = NULL;
  __nrowcnd = (*env)->GetDoubleField(env, rowcnd, doubleW_val_fieldID);
  __ncolcnd = (*env)->GetDoubleField(env, colcnd, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dgbequ_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!failed) (*env)->SetDoubleField(env, colcnd, doubleW_val_fieldID, __ncolcnd);
  if (!failed) (*env)->SetDoubleField(env, rowcnd, doubleW_val_fieldID, __nrowcnd);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbrfs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__nab = NULL; double *__nafb = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgbrfs_(__ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbsv_)(int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nab = NULL; int *__nipiv = NULL; double *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgbsv_(&n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbsvx_)(const char *fact, const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jobject equed, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double __nrcond = 0; int __ninfo = 0; double *__nab = NULL; double *__nafb = NULL; int *__nipiv = NULL; double *__nr = NULL; double *__nc = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgbsvx_(__nfact, __ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbtf2_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nab = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dgbtf2_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbtrf_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nab = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dgbtrf_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgbtrs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgbtrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__nab = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgbtrs_(__ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgebak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, double *scale, int *m, double *v, int *ldv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jdoubleArray scale, jint offsetscale, jint m, jdoubleArray v, jint offsetv, jint ldv, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nside = NULL; int __ninfo = 0; double *__nscale = NULL; double *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  dgebak_(__njob, __nside, &n, &ilo, &ihi, __nscale + offsetscale, &m, __nv + offsetv, &ldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgebal_)(const char *job, int *n, double *a, int *lda, int *ilo, int *ihi, double *scale, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jdoubleArray a, jint offseta, jint lda, jobject ilo, jobject ihi, jdoubleArray scale, jint offsetscale, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __nilo = 0; int __nihi = 0; int __ninfo = 0; double *__na = NULL; double *__nscale = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  dgebal_(__njob, &n, __na + offseta, &lda, &__nilo, &__nihi, __nscale + offsetscale, &__ninfo);
done:
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgebd2_)(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebd2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntauq = NULL; double *__ntaup = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgebd2_(&m, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgebrd_)(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgebrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntauq = NULL; double *__ntaup = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgebrd_(&m, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgecon_)(const char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray a, jint offseta, jint lda, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgecon_(__nnorm, &n, __na + offseta, &lda, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeequ_)(int *m, int *n, double *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  jboolean failed = FALSE;
  double __nrowcnd = 0; double __ncolcnd = 0; double __namax = 0; int __ninfo = 0; double *__na = NULL; double *__nr = NULL; double *__nc = NULL;
  __nrowcnd = (*env)->GetDoubleField(env, rowcnd, doubleW_val_fieldID);
  __ncolcnd = (*env)->GetDoubleField(env, colcnd, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dgeequ_(&m, &n, __na + offseta, &lda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!failed) (*env)->SetDoubleField(env, colcnd, doubleW_val_fieldID, __ncolcnd);
  if (!failed) (*env)->SetDoubleField(env, rowcnd, doubleW_val_fieldID, __nrowcnd);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeev_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; double *__na = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeev_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jdoubleArray scale, jint offsetscale, jobject abnrm, jdoubleArray rconde, jint offsetrconde, jdoubleArray rcondv, jint offsetrcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nbalanc = NULL; const char *__njobvl = NULL; const char *__njobvr = NULL; const char *__nsense = NULL; int __nilo = 0; int __nihi = 0; double __nabnrm = 0; int __ninfo = 0; double *__na = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nscale = NULL; double *__nrconde = NULL; double *__nrcondv = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) goto fail;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetDoubleField(env, abnrm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) goto fail;
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgeevx_(__nbalanc, __njobvl, __njobvr, __nsense, &n, __na + offseta, &lda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &__nilo, &__nihi, __nscale + offsetscale, &__nabnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, abnrm, doubleW_val_fieldID, __nabnrm);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgegs_)(const char *jobvsl, const char *jobvsr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgegsK(JNIEnv *env, UNUSED jobject obj, jstring jobvsl, jstring jobvsr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vsl, jint offsetvsl, jint ldvsl, jdoubleArray vsr, jint offsetvsr, jint ldvsr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvsl = NULL; const char *__njobvsr = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nvsl = NULL; double *__nvsr = NULL; double *__nwork = NULL;
  if (!(__njobvsl = (*env)->GetStringUTFChars(env, jobvsl, NULL))) goto fail;
  if (!(__njobvsr = (*env)->GetStringUTFChars(env, jobvsr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvsl = (*env)->GetPrimitiveArrayCritical(env, vsl, NULL))) goto fail;
  if (!(__nvsr = (*env)->GetPrimitiveArrayCritical(env, vsr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgegs_(__njobvsl, __njobvsr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvsl + offsetvsl, &ldvsl, __nvsr + offsetvsr, &ldvsr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvsr) (*env)->ReleasePrimitiveArrayCritical(env, vsr, __nvsr, failed ? JNI_ABORT : 0);
  if (__nvsl) (*env)->ReleasePrimitiveArrayCritical(env, vsl, __nvsl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvsr) (*env)->ReleaseStringUTFChars(env, jobvsr, __njobvsr);
  if (__njobvsl) (*env)->ReleaseStringUTFChars(env, jobvsl, __njobvsl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgegv_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgegvK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgegv_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgehd2_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgehd2K(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgehd2_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgehrd_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgehrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgehrd_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelq2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgelq2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelqf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgelqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgels_)(const char *trans, int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgels_(__ntrans, &m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelsd_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray s, jint offsets, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__ns = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgelsd_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __ns + offsets, &rcond, &__nrank, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelss_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelssK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray s, jint offsets, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__ns = NULL; double *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgelss_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __ns + offsets, &rcond, &__nrank, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelsx_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *jpvt, double *rcond, int *rank, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsxK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; int *__njpvt = NULL; double *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgelsx_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __njpvt + offsetjpvt, &rcond, &__nrank, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgelsy_)(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *jpvt, double *rcond, int *rank, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgelsyK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; int *__njpvt = NULL; double *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgelsy_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __njpvt + offsetjpvt, &rcond, &__nrank, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeql2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeql2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeql2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeqlf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqlfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeqlf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeqp3_)(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqp3K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__njpvt = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeqp3_(&m, &n, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeqpf_)(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqpfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__njpvt = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeqpf_(&m, &n, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeqr2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeqr2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgeqrf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeqrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgeqrf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgerfs_)(const char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgerfs_(__ntrans, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgerq2_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgerq2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgerqf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgerqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgerqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgesc2_)(int *n, double *a, int *lda, double *rhs, int *ipiv, int *jpiv, double *scale);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesc2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray rhs, jint offsetrhs, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject scale) {
  jboolean failed = FALSE;
  double __nscale = 0; double *__na = NULL; double *__nrhs = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  dgesc2_(&n, __na + offseta, &lda, __nrhs + offsetrhs, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__nscale);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgesdd_)(const char *jobz, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesddK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; double *__na = NULL; double *__ns = NULL; double *__nu = NULL; double *__nvt = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgesdd_(__njobz, &m, &n, __na + offseta, &lda, __ns + offsets, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgesv_)(int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgesv_(&n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgesvd_)(const char *jobu, const char *jobvt, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobvt, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobvt = NULL; int __ninfo = 0; double *__na = NULL; double *__ns = NULL; double *__nu = NULL; double *__nvt = NULL; double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobvt = (*env)->GetStringUTFChars(env, jobvt, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgesvd_(__njobu, __njobvt, &m, &n, __na + offseta, &lda, __ns + offsets, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvt) (*env)->ReleaseStringUTFChars(env, jobvt, __njobvt);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgesvx_)(const char *fact, const char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgesvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jobject equed, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; int *__nipiv = NULL; double *__nr = NULL; double *__nc = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgesvx_(__nfact, __ntrans, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgetc2_)(int *n, double *a, int *lda, int *ipiv, int *jpiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetc2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  dgetc2_(&n, __na + offseta, &lda, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__ninfo);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgetf2_)(int *m, int *n, double *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dgetf2_(&m, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgetrf_)(int *m, int *n, double *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dgetrf_(&m, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgetri_)(int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetriK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgetri_(&n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgetrs_)(const char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgetrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgetrs_(__ntrans, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggbak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, double *lscale, double *rscale, int *m, double *v, int *ldv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggbakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jint m, jdoubleArray v, jint offsetv, jint ldv, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nside = NULL; int __ninfo = 0; double *__nlscale = NULL; double *__nrscale = NULL; double *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  dggbak_(__njob, __nside, &n, &ilo, &ihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &m, __nv + offsetv, &ldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggbal_)(const char *job, int *n, double *a, int *lda, double *b, int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggbalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject ilo, jobject ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __nilo = 0; int __nihi = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nlscale = NULL; double *__nrscale = NULL; double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggbal_(__njob, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggev_)(const char *jobvl, const char *jobvr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggev_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *bwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jdoubleArray lscale, jint offsetlscale, jdoubleArray rscale, jint offsetrscale, jobject abnrm, jobject bbnrm, jdoubleArray rconde, jint offsetrconde, jdoubleArray rcondv, jint offsetrcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nbalanc = NULL; const char *__njobvl = NULL; const char *__njobvr = NULL; const char *__nsense = NULL; int __nilo = 0; int __nihi = 0; double __nabnrm = 0; double __nbbnrm = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nlscale = NULL; double *__nrscale = NULL; double *__nrconde = NULL; double *__nrcondv = NULL; double *__nwork = NULL; int *__niwork = NULL; jboolean *__jbwork = NULL; int *__nbwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) goto fail;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetDoubleField(env, abnrm, doubleW_val_fieldID);
  __nbbnrm = (*env)->GetDoubleField(env, bbnrm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) goto fail;
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__jbwork = (*env)->GetPrimitiveArrayCritical(env, bwork, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, bwork); if (length <= 0) goto fail; if (!(__nbwork = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nbwork[i] = __jbwork[i]; } } while(0);
  dggevx_(__nbalanc, __njobvl, __njobvr, __nsense, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nabnrm, &__nbbnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nbwork + offsetbwork, &__ninfo);
done:
  if (__nbwork) { free(__nbwork); } if (__jbwork) (*env)->ReleasePrimitiveArrayCritical(env, bwork, __nbwork, JNI_ABORT);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, bbnrm, doubleW_val_fieldID, __nbbnrm);
  if (!failed) (*env)->SetDoubleField(env, abnrm, doubleW_val_fieldID, __nabnrm);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggglm_)(int *n, int *m, int *p, double *a, int *lda, double *b, int *ldb, double *d, double *x, double *y, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggglmK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray d, jint offsetd, jdoubleArray x, jint offsetx, jdoubleArray y, jint offsety, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nd = NULL; double *__nx = NULL; double *__ny = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggglm_(&n, &m, &p, __na + offseta, &lda, __nb + offsetb, &ldb, __nd + offsetd, __nx + offsetx, __ny + offsety, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgghrd_)(const char *compq, const char *compz, int *n, int *ilo, int *ihi, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgghrdK(JNIEnv *env, UNUSED jobject obj, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompq = NULL; const char *__ncompz = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nq = NULL; double *__nz = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dgghrd_(__ncompq, __ncompz, &n, &ilo, &ihi, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgglse_)(int *m, int *n, int *p, double *a, int *lda, double *b, int *ldb, double *c, double *d, double *x, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgglseK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jdoubleArray d, jint offsetd, jdoubleArray x, jint offsetx, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL; double *__nd = NULL; double *__nx = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dgglse_(&m, &n, &p, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, __nd + offsetd, __nx + offsetx, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggqrf_)(int *n, int *m, int *p, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggqrfK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jdoubleArray a, jint offseta, jint lda, jdoubleArray taua, jint offsettaua, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray taub, jint offsettaub, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntaua = NULL; double *__nb = NULL; double *__ntaub = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggqrf_(&n, &m, &p, __na + offseta, &lda, __ntaua + offsettaua, __nb + offsetb, &ldb, __ntaub + offsettaub, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggrqf_)(int *m, int *p, int *n, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint p, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray taua, jint offsettaua, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray taub, jint offsettaub, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntaua = NULL; double *__nb = NULL; double *__ntaub = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggrqf_(&m, &p, &n, __na + offseta, &lda, __ntaua + offsettaua, __nb + offsetb, &ldb, __ntaub + offsettaub, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggsvd_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *n, int *p, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggsvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint n, jint p, jobject k, jobject l, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alpha, jint offsetalpha, jdoubleArray beta, jint offsetbeta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nk = 0; int __nl = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalpha = NULL; double *__nbeta = NULL; double *__nu = NULL; double *__nv = NULL; double *__nq = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dggsvd_(__njobu, __njobv, __njobq, &m, &n, &p, &__nk, &__nl, __na + offseta, &lda, __nb + offsetb, &ldb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dggsvp_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, int *k, int *l, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, int *iwork, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggsvpK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble tola, jdouble tolb, jobject k, jobject l, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jintArray iwork, jint offsetiwork, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nk = 0; int __nl = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nu = NULL; double *__nv = NULL; double *__nq = NULL; int *__niwork = NULL; double *__ntau = NULL; double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dggsvp_(__njobu, __njobv, __njobq, &m, &p, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &tola, &tolb, &__nk, &__nl, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __niwork + offsetiwork, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgtcon_)(const char *norm, int *n, double *dl, double *d, double *du, double *du2, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double __nrcond = 0; int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndu2 = NULL; int *__nipiv = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgtcon_(__nnorm, &n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgtrfs_)(const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray dlf, jint offsetdlf, jdoubleArray df, jint offsetdf, jdoubleArray duf, jint offsetduf, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndlf = NULL; double *__ndf = NULL; double *__nduf = NULL; double *__ndu2 = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgtrfs_(__ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgtsv_)(int *n, int *nrhs, double *dl, double *d, double *du, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgtsv_(&n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgtsvx_)(const char *fact, const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray dlf, jint offsetdlf, jdoubleArray df, jint offsetdf, jdoubleArray duf, jint offsetduf, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; double __nrcond = 0; int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndlf = NULL; double *__ndf = NULL; double *__nduf = NULL; double *__ndu2 = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dgtsvx_(__nfact, __ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgttrf_)(int *n, double *dl, double *d, double *du, double *du2, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndu2 = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dgttrf_(&n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgttrs_)(const char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgttrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndu2 = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgttrs_(__ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dgtts2_)(int *itrans, int *n, int *nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgtts2K(JNIEnv *env, UNUSED jobject obj, jint itrans, jint n, jint nrhs, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__ndu2 = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dgtts2_(&itrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dhgeqz_)(const char *job, const char *compq, const char *compz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *t, int *ldt, double *alphar, double *alphai, double *beta, double *q, int *ldq, double *z, int *ldz, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhgeqzK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray t, jint offsett, jint ldt, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompq = NULL; const char *__ncompz = NULL; int __ninfo = 0; double *__nh = NULL; double *__nt = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nq = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dhgeqz_(__njob, __ncompq, __ncompz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nt + offsett, &ldt, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &ldq, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dhsein_)(const char *side, const char *eigsrc, const char *initv, int *select, int *n, double *h, int *ldh, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *ifaill, int *ifailr, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhseinK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring eigsrc, jstring initv, jbooleanArray select, jint offsetselect, jint n, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jintArray ifaill, jint offsetifaill, jintArray ifailr, jint offsetifailr, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__neigsrc = NULL; const char *__ninitv = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__nh = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL; int *__nifaill = NULL; int *__nifailr = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__neigsrc = (*env)->GetStringUTFChars(env, eigsrc, NULL))) goto fail;
  if (!(__ninitv = (*env)->GetStringUTFChars(env, initv, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__nifaill = (*env)->GetPrimitiveArrayCritical(env, ifaill, NULL))) goto fail;
  if (!(__nifailr = (*env)->GetPrimitiveArrayCritical(env, ifailr, NULL))) goto fail;
  dhsein_(__nside, __neigsrc, __ninitv, __nselect + offsetselect, &n, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, __nifaill + offsetifaill, __nifailr + offsetifailr, &__ninfo);
done:
  if (__nifailr) (*env)->ReleasePrimitiveArrayCritical(env, ifailr, __nifailr, failed ? JNI_ABORT : 0);
  if (__nifaill) (*env)->ReleasePrimitiveArrayCritical(env, ifaill, __nifaill, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ninitv) (*env)->ReleaseStringUTFChars(env, initv, __ninitv);
  if (__neigsrc) (*env)->ReleaseStringUTFChars(env, eigsrc, __neigsrc);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dhseqr_)(const char *job, const char *compz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, double *z, int *ldz, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dhseqrK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompz = NULL; int __ninfo = 0; double *__nh = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dhseqr_(__njob, __ncompz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*disnan_)(double *din);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_disnanK(JNIEnv *env, UNUSED jobject obj, jdouble din) {
  jboolean __ret;
  jboolean failed = FALSE;
  

  __ret = disnan_(&din);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlabad_)(double *small, double *large);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlabadK(JNIEnv *env, UNUSED jobject obj, jobject small, jobject large) {
  jboolean failed = FALSE;
  double __nsmall = 0; double __nlarge = 0;
  __nsmall = (*env)->GetDoubleField(env, small, doubleW_val_fieldID);
  __nlarge = (*env)->GetDoubleField(env, large, doubleW_val_fieldID);
  dlabad_(&__nsmall, &__nlarge);
done:
  if (!failed) (*env)->SetDoubleField(env, large, doubleW_val_fieldID, __nlarge);
  if (!failed) (*env)->SetDoubleField(env, small, doubleW_val_fieldID, __nsmall);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlabrd_)(int *m, int *n, int *nb, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *x, int *ldx, double *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlabrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tauq, jint offsettauq, jdoubleArray taup, jint offsettaup, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  double *__na = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntauq = NULL; double *__ntaup = NULL; double *__nx = NULL; double *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  dlabrd_(&m, &n, &nb, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nx + offsetx, &ldx, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlacn2_)(int *n, double *v, double *x, int *isgn, double *est, int *kase, int *isave);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlacn2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray v, jint offsetv, jdoubleArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase, jintArray isave, jint offsetisave) {
  jboolean failed = FALSE;
  double __nest = 0; int __nkase = 0; double *__nv = NULL; double *__nx = NULL; int *__nisgn = NULL; int *__nisave = NULL;
  __nest = (*env)->GetDoubleField(env, est, doubleW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) goto fail;
  if (!(__nisave = (*env)->GetPrimitiveArrayCritical(env, isave, NULL))) goto fail;
  dlacn2_(&n, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase, __nisave + offsetisave);
done:
  if (__nisave) (*env)->ReleasePrimitiveArrayCritical(env, isave, __nisave, failed ? JNI_ABORT : 0);
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!failed) (*env)->SetDoubleField(env, est, doubleW_val_fieldID, __nest);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlacon_)(int *n, double *v, double *x, int *isgn, double *est, int *kase);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaconK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray v, jint offsetv, jdoubleArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase) {
  jboolean failed = FALSE;
  double __nest = 0; int __nkase = 0; double *__nv = NULL; double *__nx = NULL; int *__nisgn = NULL;
  __nest = (*env)->GetDoubleField(env, est, doubleW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) goto fail;
  dlacon_(&n, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase);
done:
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!failed) (*env)->SetDoubleField(env, est, doubleW_val_fieldID, __nest);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlacpy_)(const char *uplo, int *m, int *n, double *a, int *lda, double *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlacpyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dlacpy_(__nuplo, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dladiv_)(double *a, double *b, double *c, double *d, double *p, double *q);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dladivK(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jdouble d, jobject p, jobject q) {
  jboolean failed = FALSE;
  double __np = 0; double __nq = 0;
  __np = (*env)->GetDoubleField(env, p, doubleW_val_fieldID);
  __nq = (*env)->GetDoubleField(env, q, doubleW_val_fieldID);
  dladiv_(&a, &b, &c, &d, &__np, &__nq);
done:
  if (!failed) (*env)->SetDoubleField(env, q, doubleW_val_fieldID, __nq);
  if (!failed) (*env)->SetDoubleField(env, p, doubleW_val_fieldID, __np);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlae2_)(double *a, double *b, double *c, double *rt1, double *rt2);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlae2K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jobject rt1, jobject rt2) {
  jboolean failed = FALSE;
  double __nrt1 = 0; double __nrt2 = 0;
  __nrt1 = (*env)->GetDoubleField(env, rt1, doubleW_val_fieldID);
  __nrt2 = (*env)->GetDoubleField(env, rt2, doubleW_val_fieldID);
  dlae2_(&a, &b, &c, &__nrt1, &__nrt2);
done:
  if (!failed) (*env)->SetDoubleField(env, rt2, doubleW_val_fieldID, __nrt2);
  if (!failed) (*env)->SetDoubleField(env, rt1, doubleW_val_fieldID, __nrt1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaebz_)(int *ijob, int *nitmax, int *n, int *mmax, int *minp, int *nbmin, double *abstol, double *reltol, double *pivmin, double *d, double *e, double *e2, int *nval, double *ab, double *c, int *mout, int *nab, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaebzK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint nitmax, jint n, jint mmax, jint minp, jint nbmin, jdouble abstol, jdouble reltol, jdouble pivmin, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jintArray nval, jint offsetnval, jdoubleArray ab, jint offsetab, jdoubleArray c, jint offsetc, jobject mout, jintArray nab, jint offsetnab, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __nmout = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__ne2 = NULL; int *__nnval = NULL; double *__nab = NULL; double *__nc = NULL; int *__nnab = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nmout = (*env)->GetIntField(env, mout, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nnval = (*env)->GetPrimitiveArrayCritical(env, nval, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nnab = (*env)->GetPrimitiveArrayCritical(env, nab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlaebz_(&ijob, &nitmax, &n, &mmax, &minp, &nbmin, &abstol, &reltol, &pivmin, __nd + offsetd, __ne + offsete, __ne2 + offsete2, __nnval + offsetnval, __nab + offsetab, __nc + offsetc, &__nmout, __nnab + offsetnab, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nnab) (*env)->ReleasePrimitiveArrayCritical(env, nab, __nnab, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nnval) (*env)->ReleasePrimitiveArrayCritical(env, nval, __nnval, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, mout, intW_val_fieldID, __nmout);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed0_)(int *icompq, int *qsiz, int *n, double *d, double *e, double *q, int *ldq, double *qstore, int *ldqs, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint qsiz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray qstore, jint offsetqstore, jint ldqs, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nq = NULL; double *__nqstore = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlaed0_(&icompq, &qsiz, &n, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __nqstore + offsetqstore, &ldqs, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed1_)(int *n, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  double __nrho = 0; int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; int *__nindxq = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlaed1_(&n, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed2_)(int *k, int *n, int *n1, double *d, double *q, int *ldq, int *indxq, double *rho, double *z, double *dlamda, double *w, double *q2, int *indx, int *indxc, int *indxp, int *coltyp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed2K(JNIEnv *env, UNUSED jobject obj, jobject k, jint n, jint n1, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jdoubleArray z, jint offsetz, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray w, jint offsetw, jdoubleArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray indxc, jint offsetindxc, jintArray indxp, jint offsetindxp, jintArray coltyp, jint offsetcoltyp, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; double __nrho = 0; int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; int *__nindxq = NULL; double *__nz = NULL; double *__ndlamda = NULL; double *__nw = NULL; double *__nq2 = NULL; int *__nindx = NULL; int *__nindxc = NULL; int *__nindxp = NULL; int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  if (!(__nindxc = (*env)->GetPrimitiveArrayCritical(env, indxc, NULL))) goto fail;
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) goto fail;
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) goto fail;
  dlaed2_(&__nk, &n, &n1, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, __nz + offsetz, __ndlamda + offsetdlamda, __nw + offsetw, __nq2 + offsetq2, __nindx + offsetindx, __nindxc + offsetindxc, __nindxp + offsetindxp, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, failed ? JNI_ABORT : 0);
  if (__nindxc) (*env)->ReleasePrimitiveArrayCritical(env, indxc, __nindxc, failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed3_)(int *k, int *n, int *n1, double *d, double *q, int *ldq, double *rho, double *dlamda, double *q2, int *indx, int *ctot, double *w, double *s, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed3K(JNIEnv *env, UNUSED jobject obj, jint k, jint n, jint n1, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdouble rho, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray ctot, jint offsetctot, jdoubleArray w, jint offsetw, jdoubleArray s, jint offsets, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; double *__ndlamda = NULL; double *__nq2 = NULL; int *__nindx = NULL; int *__nctot = NULL; double *__nw = NULL; double *__ns = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlaed3_(&k, &n, &n1, __nd + offsetd, __nq + offsetq, &ldq, &rho, __ndlamda + offsetdlamda, __nq2 + offsetq2, __nindx + offsetindx, __nctot + offsetctot, __nw + offsetw, __ns + offsets, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed4_)(int *n, int *i, double *d, double *z, double *delta, double *rho, double *dlam, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dlam, jobject info) {
  jboolean failed = FALSE;
  double __ndlam = 0; int __ninfo = 0; double *__nd = NULL; double *__nz = NULL; double *__ndelta = NULL;
  __ndlam = (*env)->GetDoubleField(env, dlam, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  dlaed4_(&n, &i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndlam, &__ninfo);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, dlam, doubleW_val_fieldID, __ndlam);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed5_)(int *i, double *d, double *z, double *delta, double *rho, double *dlam);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed5K(JNIEnv *env, UNUSED jobject obj, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dlam) {
  jboolean failed = FALSE;
  double __ndlam = 0; double *__nd = NULL; double *__nz = NULL; double *__ndelta = NULL;
  __ndlam = (*env)->GetDoubleField(env, dlam, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  dlaed5_(&i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndlam);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, dlam, doubleW_val_fieldID, __ndlam);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed6_)(int *kniter, int *orgati, double *rho, double *d, double *z, double *finit, double *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed6K(JNIEnv *env, UNUSED jobject obj, jint kniter, jboolean orgati, jdouble rho, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdouble finit, jobject tau, jobject info) {
  jboolean failed = FALSE;
  int __norgati; double __ntau = 0; int __ninfo = 0; double *__nd = NULL; double *__nz = NULL;
  __norgati = orgati;
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlaed6_(&kniter, &__norgati, &rho, __nd + offsetd, __nz + offsetz, &finit, &__ntau, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (!failed) orgati = __norgati;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed7_)(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint n, jint qsiz, jint tlvls, jint curlvl, jint curpbm, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray qstore, jint offsetqstore, jintArray qptr, jint offsetqptr, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  double __nrho = 0; int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; int *__nindxq = NULL; double *__nqstore = NULL; int *__nqptr = NULL; int *__nprmptr = NULL; int *__nperm = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) goto fail;
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) goto fail;
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlaed7_(&icompq, &n, &qsiz, &tlvls, &curlvl, &curpbm, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nqstore + offsetqstore, __nqptr + offsetqptr, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed8_)(int *icompq, int *k, int *n, int *qsiz, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *z, double *dlamda, double *q2, int *ldq2, double *w, int *perm, int *givptr, int *givcol, double *givnum, int *indxp, int *indx, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jobject k, jint n, jint qsiz, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jdoubleArray z, jint offsetz, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray q2, jint offsetq2, jint ldq2, jdoubleArray w, jint offsetw, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jintArray indxp, jint offsetindxp, jintArray indx, jint offsetindx, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; double __nrho = 0; int __ngivptr = 0; int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; int *__nindxq = NULL; double *__nz = NULL; double *__ndlamda = NULL; double *__nq2 = NULL; double *__nw = NULL; int *__nperm = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL; int *__nindxp = NULL; int *__nindx = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nrho = (*env)->GetDoubleField(env, rho, doubleW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  dlaed8_(&icompq, &__nk, &n, &qsiz, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nz + offsetz, __ndlamda + offsetdlamda, __nq2 + offsetq2, &ldq2, __nw + offsetw, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nindxp + offsetindxp, __nindx + offsetindx, &__ninfo);
done:
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetDoubleField(env, rho, doubleW_val_fieldID, __nrho);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaed9_)(int *k, int *kstart, int *kstop, int *n, double *d, double *q, int *ldq, double *rho, double *dlamda, double *w, double *s, int *lds, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaed9K(JNIEnv *env, UNUSED jobject obj, jint k, jint kstart, jint kstop, jint n, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdouble rho, jdoubleArray dlamda, jint offsetdlamda, jdoubleArray w, jint offsetw, jdoubleArray s, jint offsets, jint lds, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; double *__ndlamda = NULL; double *__nw = NULL; double *__ns = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlaed9_(&k, &kstart, &kstop, &n, __nd + offsetd, __nq + offsetq, &ldq, &rho, __ndlamda + offsetdlamda, __nw + offsetw, __ns + offsets, &lds, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaeda_)(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *q, int *qptr, double *z, double *ztemp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaedaK(JNIEnv *env, UNUSED jobject obj, jint n, jint tlvls, jint curlvl, jint curpbm, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jdoubleArray givnum, jint offsetgivnum, jdoubleArray q, jint offsetq, jintArray qptr, jint offsetqptr, jdoubleArray z, jint offsetz, jdoubleArray ztemp, jint offsetztemp, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; int *__nprmptr = NULL; int *__nperm = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL; double *__nq = NULL; int *__nqptr = NULL; double *__nz = NULL; double *__nztemp = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nztemp = (*env)->GetPrimitiveArrayCritical(env, ztemp, NULL))) goto fail;
  dlaeda_(&n, &tlvls, &curlvl, &curpbm, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nq + offsetq, __nqptr + offsetqptr, __nz + offsetz, __nztemp + offsetztemp, &__ninfo);
done:
  if (__nztemp) (*env)->ReleasePrimitiveArrayCritical(env, ztemp, __nztemp, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaein_)(int *rightv, int *noinit, int *n, double *h, int *ldh, double *wr, double *wi, double *vr, double *vi, double *b, int *ldb, double *work, double *eps3, double *smlnum, double *bignum, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaeinK(JNIEnv *env, UNUSED jobject obj, jboolean rightv, jboolean noinit, jint n, jdoubleArray h, jint offseth, jint ldh, jdouble wr, jdouble wi, jdoubleArray vr, jint offsetvr, jdoubleArray vi, jint offsetvi, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jdouble eps3, jdouble smlnum, jdouble bignum, jobject info) {
  jboolean failed = FALSE;
  int __nrightv; int __nnoinit; int __ninfo = 0; double *__nh = NULL; double *__nvr = NULL; double *__nvi = NULL; double *__nb = NULL; double *__nwork = NULL;
  __nrightv = rightv;
  __nnoinit = noinit;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nvi = (*env)->GetPrimitiveArrayCritical(env, vi, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaein_(&__nrightv, &__nnoinit, &n, __nh + offseth, &ldh, &wr, &wi, __nvr + offsetvr, __nvi + offsetvi, __nb + offsetb, &ldb, __nwork + offsetwork, &eps3, &smlnum, &bignum, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nvi) (*env)->ReleasePrimitiveArrayCritical(env, vi, __nvi, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) noinit = __nnoinit;
  if (!failed) rightv = __nrightv;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaev2_)(double *a, double *b, double *c, double *rt1, double *rt2, double *cs1, double *sn1);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaev2K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b, jdouble c, jobject rt1, jobject rt2, jobject cs1, jobject sn1) {
  jboolean failed = FALSE;
  double __nrt1 = 0; double __nrt2 = 0; double __ncs1 = 0; double __nsn1 = 0;
  __nrt1 = (*env)->GetDoubleField(env, rt1, doubleW_val_fieldID);
  __nrt2 = (*env)->GetDoubleField(env, rt2, doubleW_val_fieldID);
  __ncs1 = (*env)->GetDoubleField(env, cs1, doubleW_val_fieldID);
  __nsn1 = (*env)->GetDoubleField(env, sn1, doubleW_val_fieldID);
  dlaev2_(&a, &b, &c, &__nrt1, &__nrt2, &__ncs1, &__nsn1);
done:
  if (!failed) (*env)->SetDoubleField(env, sn1, doubleW_val_fieldID, __nsn1);
  if (!failed) (*env)->SetDoubleField(env, cs1, doubleW_val_fieldID, __ncs1);
  if (!failed) (*env)->SetDoubleField(env, rt2, doubleW_val_fieldID, __nrt2);
  if (!failed) (*env)->SetDoubleField(env, rt1, doubleW_val_fieldID, __nrt1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaexc_)(int *wantq, int *n, double *t, int *ldt, double *q, int *ldq, int *j1, int *n1, int *n2, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jint j1, jint n1, jint n2, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __ninfo = 0; double *__nt = NULL; double *__nq = NULL; double *__nwork = NULL;
  __nwantq = wantq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaexc_(&__nwantq, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, &j1, &n1, &n2, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlag2_)(double *a, int *lda, double *b, int *ldb, double *safmin, double *scale1, double *scale2, double *wr1, double *wr2, double *wi);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlag2K(JNIEnv *env, UNUSED jobject obj, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble safmin, jobject scale1, jobject scale2, jobject wr1, jobject wr2, jobject wi) {
  jboolean failed = FALSE;
  double __nscale1 = 0; double __nscale2 = 0; double __nwr1 = 0; double __nwr2 = 0; double __nwi = 0; double *__na = NULL; double *__nb = NULL;
  __nscale1 = (*env)->GetDoubleField(env, scale1, doubleW_val_fieldID);
  __nscale2 = (*env)->GetDoubleField(env, scale2, doubleW_val_fieldID);
  __nwr1 = (*env)->GetDoubleField(env, wr1, doubleW_val_fieldID);
  __nwr2 = (*env)->GetDoubleField(env, wr2, doubleW_val_fieldID);
  __nwi = (*env)->GetDoubleField(env, wi, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dlag2_(__na + offseta, &lda, __nb + offsetb, &ldb, &safmin, &__nscale1, &__nscale2, &__nwr1, &__nwr2, &__nwi);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, wi, doubleW_val_fieldID, __nwi);
  if (!failed) (*env)->SetDoubleField(env, wr2, doubleW_val_fieldID, __nwr2);
  if (!failed) (*env)->SetDoubleField(env, wr1, doubleW_val_fieldID, __nwr1);
  if (!failed) (*env)->SetDoubleField(env, scale2, doubleW_val_fieldID, __nscale2);
  if (!failed) (*env)->SetDoubleField(env, scale1, doubleW_val_fieldID, __nscale1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlag2s_)(int *m, int *n, double *a, int *lda, float *sa, int *ldsa, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlag2sK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jfloatArray sa, jint offsetsa, jint ldsa, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; float *__nsa = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nsa = (*env)->GetPrimitiveArrayCritical(env, sa, NULL))) goto fail;
  dlag2s_(&m, &n, __na + offseta, &lda, __nsa + offsetsa, &ldsa, &__ninfo);
done:
  if (__nsa) (*env)->ReleasePrimitiveArrayCritical(env, sa, __nsa, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlags2_)(int *upper, double *a1, double *a2, double *a3, double *b1, double *b2, double *b3, double *csu, double *snu, double *csv, double *snv, double *csq, double *snq);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlags2K(JNIEnv *env, UNUSED jobject obj, jboolean upper, jdouble a1, jdouble a2, jdouble a3, jdouble b1, jdouble b2, jdouble b3, jobject csu, jobject snu, jobject csv, jobject snv, jobject csq, jobject snq) {
  jboolean failed = FALSE;
  int __nupper; double __ncsu = 0; double __nsnu = 0; double __ncsv = 0; double __nsnv = 0; double __ncsq = 0; double __nsnq = 0;
  __nupper = upper;
  __ncsu = (*env)->GetDoubleField(env, csu, doubleW_val_fieldID);
  __nsnu = (*env)->GetDoubleField(env, snu, doubleW_val_fieldID);
  __ncsv = (*env)->GetDoubleField(env, csv, doubleW_val_fieldID);
  __nsnv = (*env)->GetDoubleField(env, snv, doubleW_val_fieldID);
  __ncsq = (*env)->GetDoubleField(env, csq, doubleW_val_fieldID);
  __nsnq = (*env)->GetDoubleField(env, snq, doubleW_val_fieldID);
  dlags2_(&__nupper, &a1, &a2, &a3, &b1, &b2, &b3, &__ncsu, &__nsnu, &__ncsv, &__nsnv, &__ncsq, &__nsnq);
done:
  if (!failed) (*env)->SetDoubleField(env, snq, doubleW_val_fieldID, __nsnq);
  if (!failed) (*env)->SetDoubleField(env, csq, doubleW_val_fieldID, __ncsq);
  if (!failed) (*env)->SetDoubleField(env, snv, doubleW_val_fieldID, __nsnv);
  if (!failed) (*env)->SetDoubleField(env, csv, doubleW_val_fieldID, __ncsv);
  if (!failed) (*env)->SetDoubleField(env, snu, doubleW_val_fieldID, __nsnu);
  if (!failed) (*env)->SetDoubleField(env, csu, doubleW_val_fieldID, __ncsu);
  if (!failed) upper = __nupper;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlagtf_)(int *n, double *a, double *lambda, double *b, double *c, double *tol, double *d, int *in, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jdouble lambda, jdoubleArray b, jint offsetb, jdoubleArray c, jint offsetc, jdouble tol, jdoubleArray d, jint offsetd, jintArray in, jint offsetin, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL; double *__nd = NULL; int *__nin = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) goto fail;
  dlagtf_(&n, __na + offseta, &lambda, __nb + offsetb, __nc + offsetc, &tol, __nd + offsetd, __nin + offsetin, &__ninfo);
done:
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlagtm_)(const char *trans, int *n, int *nrhs, double *alpha, double *dl, double *d, double *du, double *x, int *ldx, double *beta, double *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtmK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jdouble alpha, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu, jdoubleArray x, jint offsetx, jint ldx, jdouble beta, jdoubleArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL; double *__nx = NULL; double *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dlagtm_(__ntrans, &n, &nrhs, &alpha, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nx + offsetx, &ldx, &beta, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlagts_)(int *job, int *n, double *a, double *b, double *c, double *d, int *in, double *y, double *tol, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagtsK(JNIEnv *env, UNUSED jobject obj, jint job, jint n, jdoubleArray a, jint offseta, jdoubleArray b, jint offsetb, jdoubleArray c, jint offsetc, jdoubleArray d, jint offsetd, jintArray in, jint offsetin, jdoubleArray y, jint offsety, jobject tol, jobject info) {
  jboolean failed = FALSE;
  double __ntol = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL; double *__nd = NULL; int *__nin = NULL; double *__ny = NULL;
  __ntol = (*env)->GetDoubleField(env, tol, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  dlagts_(&job, &n, __na + offseta, __nb + offsetb, __nc + offsetc, __nd + offsetd, __nin + offsetin, __ny + offsety, &__ntol, &__ninfo);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, tol, doubleW_val_fieldID, __ntol);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlagv2_)(double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *csl, double *snl, double *csr, double *snr);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlagv2K(JNIEnv *env, UNUSED jobject obj, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jobject csl, jobject snl, jobject csr, jobject snr) {
  jboolean failed = FALSE;
  double __ncsl = 0; double __nsnl = 0; double __ncsr = 0; double __nsnr = 0; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL;
  __ncsl = (*env)->GetDoubleField(env, csl, doubleW_val_fieldID);
  __nsnl = (*env)->GetDoubleField(env, snl, doubleW_val_fieldID);
  __ncsr = (*env)->GetDoubleField(env, csr, doubleW_val_fieldID);
  __nsnr = (*env)->GetDoubleField(env, snr, doubleW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  dlagv2_(__na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, &__ncsl, &__nsnl, &__ncsr, &__nsnr);
done:
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, snr, doubleW_val_fieldID, __nsnr);
  if (!failed) (*env)->SetDoubleField(env, csr, doubleW_val_fieldID, __ncsr);
  if (!failed) (*env)->SetDoubleField(env, snl, doubleW_val_fieldID, __nsnl);
  if (!failed) (*env)->SetDoubleField(env, csl, doubleW_val_fieldID, __ncsl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlahqr_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahqrK(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; double *__nh = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nz = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlahqr_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlahr2_)(int *n, int *k, int *nb, double *a, int *lda, double *tau, double *t, int *ldt, double *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahr2K(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt, jdoubleArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  double *__na = NULL; double *__ntau = NULL; double *__nt = NULL; double *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  dlahr2_(&n, &k, &nb, __na + offseta, &lda, __ntau + offsettau, __nt + offsett, &ldt, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlahrd_)(int *n, int *k, int *nb, double *a, int *lda, double *tau, double *t, int *ldt, double *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlahrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt, jdoubleArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  double *__na = NULL; double *__ntau = NULL; double *__nt = NULL; double *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  dlahrd_(&n, &k, &nb, __na + offseta, &lda, __ntau + offsettau, __nt + offsett, &ldt, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaic1_)(int *job, int *j, double *x, double *sest, double *w, double *gamma, double *sestpr, double *s, double *c);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaic1K(JNIEnv *env, UNUSED jobject obj, jint job, jint j, jdoubleArray x, jint offsetx, jdouble sest, jdoubleArray w, jint offsetw, jdouble gamma, jobject sestpr, jobject s, jobject c) {
  jboolean failed = FALSE;
  double __nsestpr = 0; double __ns = 0; double __nc = 0; double *__nx = NULL; double *__nw = NULL;
  __nsestpr = (*env)->GetDoubleField(env, sestpr, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  dlaic1_(&job, &j, __nx + offsetx, &sest, __nw + offsetw, &gamma, &__nsestpr, &__ns, &__nc);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!failed) (*env)->SetDoubleField(env, sestpr, doubleW_val_fieldID, __nsestpr);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*dlaisnan_)(double *din1, double *din2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaisnanK(JNIEnv *env, UNUSED jobject obj, jdouble din1, jdouble din2) {
  jboolean __ret;
  jboolean failed = FALSE;
  

  __ret = dlaisnan_(&din1, &din2);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaln2_)(int *ltrans, int *na, int *nw, double *smin, double *ca, double *a, int *lda, double *d1, double *d2, double *b, int *ldb, double *wr, double *wi, double *x, int *ldx, double *scale, double *xnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaln2K(JNIEnv *env, UNUSED jobject obj, jboolean ltrans, jint na, jint nw, jdouble smin, jdouble ca, jdoubleArray a, jint offseta, jint lda, jdouble d1, jdouble d2, jdoubleArray b, jint offsetb, jint ldb, jdouble wr, jdouble wi, jdoubleArray x, jint offsetx, jint ldx, jobject scale, jobject xnorm, jobject info) {
  jboolean failed = FALSE;
  int __nltrans; double __nscale = 0; double __nxnorm = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nx = NULL;
  __nltrans = ltrans;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nxnorm = (*env)->GetDoubleField(env, xnorm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlaln2_(&__nltrans, &na, &nw, &smin, &ca, __na + offseta, &lda, &d1, &d2, __nb + offsetb, &ldb, &wr, &wi, __nx + offsetx, &ldx, &__nscale, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, xnorm, doubleW_val_fieldID, __nxnorm);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (!failed) ltrans = __nltrans;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlals0_)(int *icompq, int *nl, int *nr, int *sqre, int *nrhs, double *b, int *ldb, double *bx, int *ldbx, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *poles, double *difl, double *difr, double *z, int *k, double *c, double *s, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlals0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jint nrhs, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray bx, jint offsetbx, jint ldbx, jintArray perm, jint offsetperm, jint givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jdoubleArray poles, jint offsetpoles, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jint k, jdouble c, jdouble s, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nb = NULL; double *__nbx = NULL; int *__nperm = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL; double *__npoles = NULL; double *__ndifl = NULL; double *__ndifr = NULL; double *__nz = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlals0_(&icompq, &nl, &nr, &sqre, &nrhs, __nb + offsetb, &ldb, __nbx + offsetbx, &ldbx, __nperm + offsetperm, &givptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &k, &c, &s, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlalsa_)(int *icompq, int *smlsiz, int *n, int *nrhs, double *b, int *ldb, double *bx, int *ldbx, double *u, int *ldu, double *vt, int *k, double *difl, double *difr, double *z, double *poles, int *givptr, int *givcol, int *ldgcol, int *perm, double *givnum, double *c, double *s, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlalsaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint nrhs, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray bx, jint offsetbx, jint ldbx, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jintArray k, jint offsetk, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jdoubleArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jdoubleArray givnum, jint offsetgivnum, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nb = NULL; double *__nbx = NULL; double *__nu = NULL; double *__nvt = NULL; int *__nk = NULL; double *__ndifl = NULL; double *__ndifr = NULL; double *__nz = NULL; double *__npoles = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; int *__nperm = NULL; double *__ngivnum = NULL; double *__nc = NULL; double *__ns = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlalsa_(&icompq, &smlsiz, &n, &nrhs, __nb + offsetb, &ldb, __nbx + offsetbx, &ldbx, __nu + offsetu, &ldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &ldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlalsd_)(const char *uplo, int *smlsiz, int *n, int *nrhs, double *d, double *e, double *b, int *ldb, double *rcond, int *rank, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlalsdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint smlsiz, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jdouble rcond, jobject rank, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __nrank = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nb = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlalsd_(__nuplo, &smlsiz, &n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &rcond, &__nrank, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlamrg_)(int *n1, int *n2, double *a, int *dtrd1, int *dtrd2, int *index);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamrgK(JNIEnv *env, UNUSED jobject obj, jint n1, jint n2, jdoubleArray a, jint offseta, jint dtrd1, jint dtrd2, jintArray index, jint offsetindex) {
  jboolean failed = FALSE;
  double *__na = NULL; int *__nindex = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nindex = (*env)->GetPrimitiveArrayCritical(env, index, NULL))) goto fail;
  dlamrg_(&n1, &n2, __na + offseta, &dtrd1, &dtrd2, __nindex + offsetindex);
done:
  if (__nindex) (*env)->ReleasePrimitiveArrayCritical(env, index, __nindex, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*dlaneg_)(int *n, double *d, double *lld, double *sigma, double *pivmin, int *r);

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanegK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray lld, jint offsetlld, jdouble sigma, jdouble pivmin, jint r) {
  jint __ret;
  jboolean failed = FALSE;
  double *__nd = NULL; double *__nlld = NULL;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  __ret = dlaneg_(&n, __nd + offsetd, __nlld + offsetlld, &sigma, &pivmin, &r);
done:
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlangb_)(const char *norm, int *n, int *kl, int *ku, double *ab, int *ldab, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double *__nab = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlangb_(__nnorm, &n, &kl, &ku, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlange_)(const char *norm, int *m, int *n, double *a, int *lda, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangeK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double *__na = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlange_(__nnorm, &m, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlangt_)(const char *norm, int *n, double *dl, double *d, double *du);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlangtK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray dl, jint offsetdl, jdoubleArray d, jint offsetd, jdoubleArray du, jint offsetdu) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double *__ndl = NULL; double *__nd = NULL; double *__ndu = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  __ret = dlangt_(__nnorm, &n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu);
done:
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlanhs_)(const char *norm, int *n, double *a, int *lda, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanhsK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double *__na = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlanhs_(__nnorm, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlansb_)(const char *norm, const char *uplo, int *n, int *k, double *ab, int *ldab, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlansbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jint k, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; double *__nab = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlansb_(__nnorm, __nuplo, &n, &k, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlansp_)(const char *norm, const char *uplo, int *n, double *ap, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanspK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; double *__nap = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlansp_(__nnorm, __nuplo, &n, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlanst_)(const char *norm, int *n, double *d, double *e);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanstK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; double *__nd = NULL; double *__ne = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  __ret = dlanst_(__nnorm, &n, __nd + offsetd, __ne + offsete);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlansy_)(const char *norm, const char *uplo, int *n, double *a, int *lda, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlansyK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; double *__na = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlansy_(__nnorm, __nuplo, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlantb_)(const char *norm, const char *uplo, const char *diag, int *n, int *k, double *ab, int *ldab, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint k, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double *__nab = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlantb_(__nnorm, __nuplo, __ndiag, &n, &k, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlantp_)(const char *norm, const char *uplo, const char *diag, int *n, double *ap, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantpK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double *__nap = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlantp_(__nnorm, __nuplo, __ndiag, &n, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlantr_)(const char *norm, const char *uplo, const char *diag, int *m, int *n, double *a, int *lda, double *work);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlantrK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray work, jint offsetwork) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double *__na = NULL; double *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = dlantr_(__nnorm, __nuplo, __ndiag, &m, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlanv2_)(double *a, double *b, double *c, double *d, double *rt1r, double *rt1i, double *rt2r, double *rt2i, double *cs, double *sn);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlanv2K(JNIEnv *env, UNUSED jobject obj, jobject a, jobject b, jobject c, jobject d, jobject rt1r, jobject rt1i, jobject rt2r, jobject rt2i, jobject cs, jobject sn) {
  jboolean failed = FALSE;
  double __na = 0; double __nb = 0; double __nc = 0; double __nd = 0; double __nrt1r = 0; double __nrt1i = 0; double __nrt2r = 0; double __nrt2i = 0; double __ncs = 0; double __nsn = 0;
  __na = (*env)->GetDoubleField(env, a, doubleW_val_fieldID);
  __nb = (*env)->GetDoubleField(env, b, doubleW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __nd = (*env)->GetDoubleField(env, d, doubleW_val_fieldID);
  __nrt1r = (*env)->GetDoubleField(env, rt1r, doubleW_val_fieldID);
  __nrt1i = (*env)->GetDoubleField(env, rt1i, doubleW_val_fieldID);
  __nrt2r = (*env)->GetDoubleField(env, rt2r, doubleW_val_fieldID);
  __nrt2i = (*env)->GetDoubleField(env, rt2i, doubleW_val_fieldID);
  __ncs = (*env)->GetDoubleField(env, cs, doubleW_val_fieldID);
  __nsn = (*env)->GetDoubleField(env, sn, doubleW_val_fieldID);
  dlanv2_(&__na, &__nb, &__nc, &__nd, &__nrt1r, &__nrt1i, &__nrt2r, &__nrt2i, &__ncs, &__nsn);
done:
  if (!failed) (*env)->SetDoubleField(env, sn, doubleW_val_fieldID, __nsn);
  if (!failed) (*env)->SetDoubleField(env, cs, doubleW_val_fieldID, __ncs);
  if (!failed) (*env)->SetDoubleField(env, rt2i, doubleW_val_fieldID, __nrt2i);
  if (!failed) (*env)->SetDoubleField(env, rt2r, doubleW_val_fieldID, __nrt2r);
  if (!failed) (*env)->SetDoubleField(env, rt1i, doubleW_val_fieldID, __nrt1i);
  if (!failed) (*env)->SetDoubleField(env, rt1r, doubleW_val_fieldID, __nrt1r);
  if (!failed) (*env)->SetDoubleField(env, d, doubleW_val_fieldID, __nd);
  if (!failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!failed) (*env)->SetDoubleField(env, b, doubleW_val_fieldID, __nb);
  if (!failed) (*env)->SetDoubleField(env, a, doubleW_val_fieldID, __na);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlapll_)(int *n, double *x, int *incx, double *y, int *incy, double *ssmin);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapllK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jobject ssmin) {
  jboolean failed = FALSE;
  double __nssmin = 0; double *__nx = NULL; double *__ny = NULL;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  dlapll_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, &__nssmin);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlapmt_)(int *forwrd, int *m, int *n, double *x, int *ldx, int *k);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapmtK(JNIEnv *env, UNUSED jobject obj, jboolean forwrd, jint m, jint n, jdoubleArray x, jint offsetx, jint ldx, jintArray k, jint offsetk) {
  jboolean failed = FALSE;
  int __nforwrd; double *__nx = NULL; int *__nk = NULL;
  __nforwrd = forwrd;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  dlapmt_(&__nforwrd, &m, &n, __nx + offsetx, &ldx, __nk + offsetk);
done:
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) forwrd = __nforwrd;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlapy2_)(double *x, double *y);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapy2K(JNIEnv *env, UNUSED jobject obj, jdouble x, jdouble y) {
  jdouble __ret;
  jboolean failed = FALSE;
  

  __ret = dlapy2_(&x, &y);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlapy3_)(double *x, double *y, double *z);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlapy3K(JNIEnv *env, UNUSED jobject obj, jdouble x, jdouble y, jdouble z) {
  jdouble __ret;
  jboolean failed = FALSE;
  

  __ret = dlapy3_(&x, &y, &z);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqgb_)(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqgbK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdouble rowcnd, jdouble colcnd, jdouble amax, jobject equed) {
  jboolean failed = FALSE;
  char *__nequed = NULL; jstring __jequed = NULL;; double *__nab = NULL; double *__nr = NULL; double *__nc = NULL;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dlaqgb_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nr + offsetr, __nc + offsetc, &rowcnd, &colcnd, &amax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqge_)(int *m, int *n, double *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqgeK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray r, jint offsetr, jdoubleArray c, jint offsetc, jdouble rowcnd, jdouble colcnd, jdouble amax, jobject equed) {
  jboolean failed = FALSE;
  char *__nequed = NULL; jstring __jequed = NULL;; double *__na = NULL; double *__nr = NULL; double *__nc = NULL;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dlaqge_(&m, &n, __na + offseta, &lda, __nr + offsetr, __nc + offsetc, &rowcnd, &colcnd, &amax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqp2_)(int *m, int *n, int *offset, double *a, int *lda, int *jpvt, double *tau, double *vn1, double *vn2, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqp2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray vn1, jint offsetvn1, jdoubleArray vn2, jint offsetvn2, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  double *__na = NULL; int *__njpvt = NULL; double *__ntau = NULL; double *__nvn1 = NULL; double *__nvn2 = NULL; double *__nwork = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) goto fail;
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqp2_(&m, &n, &offset, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqps_)(int *m, int *n, int *offset, int *nb, int *kb, double *a, int *lda, int *jpvt, double *tau, double *vn1, double *vn2, double *auxv, double *f, int *ldf);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqpsK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jint nb, jobject kb, jdoubleArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jdoubleArray tau, jint offsettau, jdoubleArray vn1, jint offsetvn1, jdoubleArray vn2, jint offsetvn2, jdoubleArray auxv, jint offsetauxv, jdoubleArray f, jint offsetf, jint ldf) {
  jboolean failed = FALSE;
  int __nkb = 0; double *__na = NULL; int *__njpvt = NULL; double *__ntau = NULL; double *__nvn1 = NULL; double *__nvn2 = NULL; double *__nauxv = NULL; double *__nf = NULL;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) goto fail;
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) goto fail;
  if (!(__nauxv = (*env)->GetPrimitiveArrayCritical(env, auxv, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  dlaqps_(&m, &n, &offset, &nb, &__nkb, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nauxv + offsetauxv, __nf + offsetf, &ldf);
done:
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__nauxv) (*env)->ReleasePrimitiveArrayCritical(env, auxv, __nauxv, failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr0_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr0K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; double *__nh = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nz = NULL; double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqr0_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr1_)(int *n, double *h, int *ldh, double *sr1, double *si1, double *sr2, double *si2, double *v);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray h, jint offseth, jint ldh, jdouble sr1, jdouble si1, jdouble sr2, jdouble si2, jdoubleArray v, jint offsetv) {
  jboolean failed = FALSE;
  double *__nh = NULL; double *__nv = NULL;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  dlaqr1_(&n, __nh + offseth, &ldh, &sr1, &si1, &sr2, &si2, __nv + offsetv);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr2_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, int *ns, int *nd, double *sr, double *si, double *v, int *ldv, int *nh, double *t, int *ldt, int *nv, double *wv, int *ldwv, double *work, int *lwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr2K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray v, jint offsetv, jint ldv, jint nh, jdoubleArray t, jint offsett, jint ldt, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jdoubleArray work, jint offsetwork, jint lwork) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __nns = 0; int __nnd = 0; double *__nh = NULL; double *__nz = NULL; double *__nsr = NULL; double *__nsi = NULL; double *__nv = NULL; double *__nt = NULL; double *__nwv = NULL; double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqr2_(&__nwantt, &__nwantz, &n, &ktop, &kbot, &nw, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &ldv, &nh, __nt + offsett, &ldt, &nv, __nwv + offsetwv, &ldwv, __nwork + offsetwork, &lwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr3_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, int *ns, int *nd, double *sr, double *si, double *v, int *ldv, int *nh, double *t, int *ldt, int *nv, double *wv, int *ldwv, double *work, int *lwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr3K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray v, jint offsetv, jint ldv, jint nh, jdoubleArray t, jint offsett, jint ldt, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jdoubleArray work, jint offsetwork, jint lwork) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __nns = 0; int __nnd = 0; double *__nh = NULL; double *__nz = NULL; double *__nsr = NULL; double *__nsi = NULL; double *__nv = NULL; double *__nt = NULL; double *__nwv = NULL; double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqr3_(&__nwantt, &__nwantz, &n, &ktop, &kbot, &nw, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &ldv, &nh, __nt + offsett, &ldt, &nv, __nwv + offsetwv, &ldwv, __nwork + offsetwork, &lwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr4_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, int *iloz, int *ihiz, double *z, int *ldz, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr4K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jdoubleArray h, jint offseth, jint ldh, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; double *__nh = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nz = NULL; double *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqr4_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqr5_)(int *wantt, int *wantz, int *kacc22, int *n, int *ktop, int *kbot, int *nshfts, double *sr, double *si, double *h, int *ldh, int *iloz, int *ihiz, double *z, int *ldz, double *v, int *ldv, double *u, int *ldu, int *nv, double *wv, int *ldwv, int *nh, double *wh, int *ldwh);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqr5K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint kacc22, jint n, jint ktop, jint kbot, jint nshfts, jdoubleArray sr, jint offsetsr, jdoubleArray si, jint offsetsi, jdoubleArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray u, jint offsetu, jint ldu, jint nv, jdoubleArray wv, jint offsetwv, jint ldwv, jint nh, jdoubleArray wh, jint offsetwh, jint ldwh) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; double *__nsr = NULL; double *__nsi = NULL; double *__nh = NULL; double *__nz = NULL; double *__nv = NULL; double *__nu = NULL; double *__nwv = NULL; double *__nwh = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwh = (*env)->GetPrimitiveArrayCritical(env, wh, NULL))) goto fail;
  dlaqr5_(&__nwantt, &__nwantz, &kacc22, &n, &ktop, &kbot, &nshfts, __nsr + offsetsr, __nsi + offsetsi, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, __nv + offsetv, &ldv, __nu + offsetu, &ldu, &nv, __nwv + offsetwv, &ldwv, &nh, __nwh + offsetwh, &ldwh);
done:
  if (__nwh) (*env)->ReleasePrimitiveArrayCritical(env, wh, __nwh, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqsb_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *s, double *scond, double *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqsbK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double *__nab = NULL; double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlaqsb_(__nuplo, &n, &kd, __nab + offsetab, &ldab, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqsp_)(const char *uplo, int *n, double *ap, double *s, double *scond, double *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqspK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double *__nap = NULL; double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlaqsp_(__nuplo, &n, __nap + offsetap, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqsy_)(const char *uplo, int *n, double *a, int *lda, double *s, double *scond, double *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqsyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jdouble scond, jdouble amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double *__na = NULL; double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlaqsy_(__nuplo, &n, __na + offseta, &lda, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaqtr_)(int *ltran, int *lreal, int *n, double *t, int *ldt, double *b, double *w, double *scale, double *x, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaqtrK(JNIEnv *env, UNUSED jobject obj, jboolean ltran, jboolean lreal, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray b, jint offsetb, jdouble w, jobject scale, jdoubleArray x, jint offsetx, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nltran; int __nlreal; double __nscale = 0; int __ninfo = 0; double *__nt = NULL; double *__nb = NULL; double *__nx = NULL; double *__nwork = NULL;
  __nltran = ltran;
  __nlreal = lreal;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlaqtr_(&__nltran, &__nlreal, &n, __nt + offsett, &ldt, __nb + offsetb, &w, &__nscale, __nx + offsetx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (!failed) lreal = __nlreal;
  if (!failed) ltran = __nltran;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlar1v_)(int *n, int *b1, int *bn, double *lambda, double *d, double *l, double *ld, double *lld, double *pivmin, double *gaptol, double *z, int *wantnc, int *negcnt, double *ztz, double *mingma, int *r, int *isuppz, double *nrminv, double *resid, double *rqcorr, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlar1vK(JNIEnv *env, UNUSED jobject obj, jint n, jint b1, jint bn, jdouble lambda, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdoubleArray ld, jint offsetld, jdoubleArray lld, jint offsetlld, jdouble pivmin, jdouble gaptol, jdoubleArray z, jint offsetz, jboolean wantnc, jobject negcnt, jobject ztz, jobject mingma, jobject r, jintArray isuppz, jint offsetisuppz, jobject nrminv, jobject resid, jobject rqcorr, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  int __nwantnc; int __nnegcnt = 0; double __nztz = 0; double __nmingma = 0; int __nr = 0; double __nnrminv = 0; double __nresid = 0; double __nrqcorr = 0; double *__nd = NULL; double *__nl = NULL; double *__nld = NULL; double *__nlld = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL;
  __nwantnc = wantnc;
  __nnegcnt = (*env)->GetIntField(env, negcnt, intW_val_fieldID);
  __nztz = (*env)->GetDoubleField(env, ztz, doubleW_val_fieldID);
  __nmingma = (*env)->GetDoubleField(env, mingma, doubleW_val_fieldID);
  __nr = (*env)->GetIntField(env, r, intW_val_fieldID);
  __nnrminv = (*env)->GetDoubleField(env, nrminv, doubleW_val_fieldID);
  __nresid = (*env)->GetDoubleField(env, resid, doubleW_val_fieldID);
  __nrqcorr = (*env)->GetDoubleField(env, rqcorr, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlar1v_(&n, &b1, &bn, &lambda, __nd + offsetd, __nl + offsetl, __nld + offsetld, __nlld + offsetlld, &pivmin, &gaptol, __nz + offsetz, &__nwantnc, &__nnegcnt, &__nztz, &__nmingma, &__nr, __nisuppz + offsetisuppz, &__nnrminv, &__nresid, &__nrqcorr, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, rqcorr, doubleW_val_fieldID, __nrqcorr);
  if (!failed) (*env)->SetDoubleField(env, resid, doubleW_val_fieldID, __nresid);
  if (!failed) (*env)->SetDoubleField(env, nrminv, doubleW_val_fieldID, __nnrminv);
  if (!failed) (*env)->SetIntField(env, r, intW_val_fieldID, __nr);
  if (!failed) (*env)->SetDoubleField(env, mingma, doubleW_val_fieldID, __nmingma);
  if (!failed) (*env)->SetDoubleField(env, ztz, doubleW_val_fieldID, __nztz);
  if (!failed) (*env)->SetIntField(env, negcnt, intW_val_fieldID, __nnegcnt);
  if (!failed) wantnc = __nwantnc;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlar2v_)(int *n, double *x, double *y, double *z, int *incx, double *c, double *s, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlar2vK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jdoubleArray y, jint offsety, jdoubleArray z, jint offsetz, jint incx, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jint incc) {
  jboolean failed = FALSE;
  double *__nx = NULL; double *__ny = NULL; double *__nz = NULL; double *__nc = NULL; double *__ns = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlar2v_(&n, __nx + offsetx, __ny + offsety, __nz + offsetz, &incx, __nc + offsetc, __ns + offsets, &incc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarf_)(const char *side, int *m, int *n, double *v, int *incv, double *tau, double *c, int *Ldc, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; double *__nv = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarf_(__nside, &m, &n, __nv + offsetv, &incv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarfb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, double *v, int *ldv, double *t, int *ldt, double *c, int *Ldc, double *work, int *ldwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray t, jint offsett, jint ldt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint ldwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; const char *__ndirect = NULL; const char *__nstorev = NULL; double *__nv = NULL; double *__nt = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarfb_(__nside, __ntrans, __ndirect, __nstorev, &m, &n, &k, __nv + offsetv, &ldv, __nt + offsett, &ldt, __nc + offsetc, &Ldc, __nwork + offsetwork, &ldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarfg_)(int *n, double *alpha, double *x, int *incx, double *tau);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfgK(JNIEnv *env, UNUSED jobject obj, jint n, jobject alpha, jdoubleArray x, jint offsetx, jint incx, jobject tau) {
  jboolean failed = FALSE;
  double __nalpha = 0; double __ntau = 0; double *__nx = NULL;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlarfg_(&n, &__nalpha, __nx + offsetx, &incx, &__ntau);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (!failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarft_)(const char *direct, const char *storev, int *n, int *k, double *v, int *ldv, double *tau, double *t, int *ldt);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarftK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt) {
  jboolean failed = FALSE;
  const char *__ndirect = NULL; const char *__nstorev = NULL; double *__nv = NULL; double *__ntau = NULL; double *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  dlarft_(__ndirect, __nstorev, &n, &k, __nv + offsetv, &ldv, __ntau + offsettau, __nt + offsett, &ldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarfx_)(const char *side, int *m, int *n, double *v, double *tau, double *c, int *Ldc, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarfxK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; double *__nv = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarfx_(__nside, &m, &n, __nv + offsetv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlargv_)(int *n, double *x, int *incx, double *y, int *incy, double *c, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlargvK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jdoubleArray c, jint offsetc, jint incc) {
  jboolean failed = FALSE;
  double *__nx = NULL; double *__ny = NULL; double *__nc = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dlargv_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, __nc + offsetc, &incc);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarnv_)(int *idist, int *iseed, int *n, double *x);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarnvK(JNIEnv *env, UNUSED jobject obj, jint idist, jintArray iseed, jint offsetiseed, jint n, jdoubleArray x, jint offsetx) {
  jboolean failed = FALSE;
  int *__niseed = NULL; double *__nx = NULL;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlarnv_(&idist, __niseed + offsetiseed, &n, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarra_)(int *n, double *d, double *e, double *e2, double *spltol, double *tnrm, int *nsplit, int *isplit, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarraK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble spltol, jdouble tnrm, jobject nsplit, jintArray isplit, jint offsetisplit, jobject info) {
  jboolean failed = FALSE;
  int __nnsplit = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__ne2 = NULL; int *__nisplit = NULL;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  dlarra_(&n, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &spltol, &tnrm, &__nnsplit, __nisplit + offsetisplit, &__ninfo);
done:
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrb_)(int *n, double *d, double *lld, int *ifirst, int *ilast, double *rtol1, double *rtol2, int *offset, double *w, double *wgap, double *werr, double *work, int *iwork, double *pivmin, double *spdiam, int *twist, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrbK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray lld, jint offsetlld, jint ifirst, jint ilast, jdouble rtol1, jdouble rtol2, jint offset, jdoubleArray w, jint offsetw, jdoubleArray wgap, jint offsetwgap, jdoubleArray werr, jint offsetwerr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jdouble pivmin, jdouble spdiam, jint twist, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__nlld = NULL; double *__nw = NULL; double *__nwgap = NULL; double *__nwerr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlarrb_(&n, __nd + offsetd, __nlld + offsetlld, &ifirst, &ilast, &rtol1, &rtol2, &offset, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &pivmin, &spdiam, &twist, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrc_)(const char *jobt, int *n, double *vl, double *vu, double *d, double *e, double *pivmin, int *eigcnt, int *lcnt, int *rcnt, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrcK(JNIEnv *env, UNUSED jobject obj, jstring jobt, jint n, jdouble vl, jdouble vu, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble pivmin, jobject eigcnt, jobject lcnt, jobject rcnt, jobject info) {
  jboolean failed = FALSE;
  const char *__njobt = NULL; int __neigcnt = 0; int __nlcnt = 0; int __nrcnt = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL;
  if (!(__njobt = (*env)->GetStringUTFChars(env, jobt, NULL))) goto fail;
  __neigcnt = (*env)->GetIntField(env, eigcnt, intW_val_fieldID);
  __nlcnt = (*env)->GetIntField(env, lcnt, intW_val_fieldID);
  __nrcnt = (*env)->GetIntField(env, rcnt, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  dlarrc_(__njobt, &n, &vl, &vu, __nd + offsetd, __ne + offsete, &pivmin, &__neigcnt, &__nlcnt, &__nrcnt, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rcnt, intW_val_fieldID, __nrcnt);
  if (!failed) (*env)->SetIntField(env, lcnt, intW_val_fieldID, __nlcnt);
  if (!failed) (*env)->SetIntField(env, eigcnt, intW_val_fieldID, __neigcnt);
  if (__njobt) (*env)->ReleaseStringUTFChars(env, jobt, __njobt);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrd_)(const char *range, const char *order, int *n, double *vl, double *vu, int *il, int *iu, double *gers, double *reltol, double *d, double *e, double *e2, double *pivmin, int *nsplit, int *isplit, int *m, double *w, double *werr, double *wl, double *wu, int *iblock, int *indexw, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrdK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jdouble vl, jdouble vu, jint il, jint iu, jdoubleArray gers, jint offsetgers, jdouble reltol, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble pivmin, jint nsplit, jintArray isplit, jint offsetisplit, jobject m, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jobject wl, jobject wu, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; const char *__norder = NULL; int __nm = 0; double __nwl = 0; double __nwu = 0; int __ninfo = 0; double *__ngers = NULL; double *__nd = NULL; double *__ne = NULL; double *__ne2 = NULL; int *__nisplit = NULL; double *__nw = NULL; double *__nwerr = NULL; int *__niblock = NULL; int *__nindexw = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nwl = (*env)->GetDoubleField(env, wl, doubleW_val_fieldID);
  __nwu = (*env)->GetDoubleField(env, wu, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlarrd_(__nrange, __norder, &n, &vl, &vu, &il, &iu, __ngers + offsetgers, &reltol, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &pivmin, &nsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, &__nwl, &__nwu, __niblock + offsetiblock, __nindexw + offsetindexw, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, wu, doubleW_val_fieldID, __nwu);
  if (!failed) (*env)->SetDoubleField(env, wl, doubleW_val_fieldID, __nwl);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarre_)(const char *range, int *n, double *vl, double *vu, int *il, int *iu, double *d, double *e, double *e2, double *rtol1, double *rtol2, double *spltol, int *nsplit, int *isplit, int *m, double *w, double *werr, double *wgap, int *iblock, int *indexw, double *gers, double *pivmin, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarreK(JNIEnv *env, UNUSED jobject obj, jstring range, jint n, jobject vl, jobject vu, jint il, jint iu, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray e2, jint offsete2, jdouble rtol1, jdouble rtol2, jdouble spltol, jobject nsplit, jintArray isplit, jint offsetisplit, jobject m, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray gers, jint offsetgers, jobject pivmin, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; double __nvl = 0; double __nvu = 0; int __nnsplit = 0; int __nm = 0; double __npivmin = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__ne2 = NULL; int *__nisplit = NULL; double *__nw = NULL; double *__nwerr = NULL; double *__nwgap = NULL; int *__niblock = NULL; int *__nindexw = NULL; double *__ngers = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nvl = (*env)->GetDoubleField(env, vl, doubleW_val_fieldID);
  __nvu = (*env)->GetDoubleField(env, vu, doubleW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npivmin = (*env)->GetDoubleField(env, pivmin, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlarre_(__nrange, &n, &__nvl, &__nvu, &il, &iu, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &rtol1, &rtol2, &spltol, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, &__npivmin, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, pivmin, doubleW_val_fieldID, __npivmin);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!failed) (*env)->SetDoubleField(env, vu, doubleW_val_fieldID, __nvu);
  if (!failed) (*env)->SetDoubleField(env, vl, doubleW_val_fieldID, __nvl);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrf_)(int *n, double *d, double *l, double *ld, int *clstrt, int *clend, double *w, double *wgap, double *werr, double *spdiam, double *clgapl, double *clgapr, double *pivmin, double *sigma, double *dplus, double *lplus, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdoubleArray ld, jint offsetld, jint clstrt, jint clend, jdoubleArray w, jint offsetw, jdoubleArray wgap, jint offsetwgap, jdoubleArray werr, jint offsetwerr, jdouble spdiam, jdouble clgapl, jdouble clgapr, jdouble pivmin, jobject sigma, jdoubleArray dplus, jint offsetdplus, jdoubleArray lplus, jint offsetlplus, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  double __nsigma = 0; int __ninfo = 0; double *__nd = NULL; double *__nl = NULL; double *__nld = NULL; double *__nw = NULL; double *__nwgap = NULL; double *__nwerr = NULL; double *__ndplus = NULL; double *__nlplus = NULL; double *__nwork = NULL;
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__ndplus = (*env)->GetPrimitiveArrayCritical(env, dplus, NULL))) goto fail;
  if (!(__nlplus = (*env)->GetPrimitiveArrayCritical(env, lplus, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarrf_(&n, __nd + offsetd, __nl + offsetl, __nld + offsetld, &clstrt, &clend, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, &spdiam, &clgapl, &clgapr, &pivmin, &__nsigma, __ndplus + offsetdplus, __nlplus + offsetlplus, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nlplus) (*env)->ReleasePrimitiveArrayCritical(env, lplus, __nlplus, failed ? JNI_ABORT : 0);
  if (__ndplus) (*env)->ReleasePrimitiveArrayCritical(env, dplus, __ndplus, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrj_)(int *n, double *d, double *e2, int *ifirst, int *ilast, double *rtol, int *offset, double *w, double *werr, double *work, int *iwork, double *pivmin, double *spdiam, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrjK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e2, jint offsete2, jint ifirst, jint ilast, jdouble rtol, jint offset, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jdouble pivmin, jdouble spdiam, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne2 = NULL; double *__nw = NULL; double *__nwerr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlarrj_(&n, __nd + offsetd, __ne2 + offsete2, &ifirst, &ilast, &rtol, &offset, __nw + offsetw, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &pivmin, &spdiam, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrk_)(int *n, int *iw, double *gl, double *gu, double *d, double *e2, double *pivmin, double *reltol, double *w, double *werr, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrkK(JNIEnv *env, UNUSED jobject obj, jint n, jint iw, jdouble gl, jdouble gu, jdoubleArray d, jint offsetd, jdoubleArray e2, jint offsete2, jdouble pivmin, jdouble reltol, jobject w, jobject werr, jobject info) {
  jboolean failed = FALSE;
  double __nw = 0; double __nwerr = 0; int __ninfo = 0; double *__nd = NULL; double *__ne2 = NULL;
  __nw = (*env)->GetDoubleField(env, w, doubleW_val_fieldID);
  __nwerr = (*env)->GetDoubleField(env, werr, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  dlarrk_(&n, &iw, &gl, &gu, __nd + offsetd, __ne2 + offsete2, &pivmin, &reltol, &__nw, &__nwerr, &__ninfo);
done:
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, werr, doubleW_val_fieldID, __nwerr);
  if (!failed) (*env)->SetDoubleField(env, w, doubleW_val_fieldID, __nw);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrr_)(int *n, double *d, double *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrrK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  dlarrr_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarrv_)(int *n, double *vl, double *vu, double *d, double *l, double *pivmin, int *isplit, int *m, int *dol, int *dou, double *minrgp, double *rtol1, double *rtol2, double *w, double *werr, double *wgap, int *iblock, int *indexw, double *gers, double *z, int *ldz, int *isuppz, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarrvK(JNIEnv *env, UNUSED jobject obj, jint n, jdouble vl, jdouble vu, jdoubleArray d, jint offsetd, jdoubleArray l, jint offsetl, jdouble pivmin, jintArray isplit, jint offsetisplit, jint m, jint dol, jint dou, jdouble minrgp, jobject rtol1, jobject rtol2, jdoubleArray w, jint offsetw, jdoubleArray werr, jint offsetwerr, jdoubleArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jdoubleArray gers, jint offsetgers, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  double __nrtol1 = 0; double __nrtol2 = 0; int __ninfo = 0; double *__nd = NULL; double *__nl = NULL; int *__nisplit = NULL; double *__nw = NULL; double *__nwerr = NULL; double *__nwgap = NULL; int *__niblock = NULL; int *__nindexw = NULL; double *__ngers = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nrtol1 = (*env)->GetDoubleField(env, rtol1, doubleW_val_fieldID);
  __nrtol2 = (*env)->GetDoubleField(env, rtol2, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlarrv_(&n, &vl, &vu, __nd + offsetd, __nl + offsetl, &pivmin, __nisplit + offsetisplit, &m, &dol, &dou, &minrgp, &__nrtol1, &__nrtol2, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rtol2, doubleW_val_fieldID, __nrtol2);
  if (!failed) (*env)->SetDoubleField(env, rtol1, doubleW_val_fieldID, __nrtol1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlartg_)(double *f, double *g, double *cs, double *sn, double *r);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlartgK(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jobject cs, jobject sn, jobject r) {
  jboolean failed = FALSE;
  double __ncs = 0; double __nsn = 0; double __nr = 0;
  __ncs = (*env)->GetDoubleField(env, cs, doubleW_val_fieldID);
  __nsn = (*env)->GetDoubleField(env, sn, doubleW_val_fieldID);
  __nr = (*env)->GetDoubleField(env, r, doubleW_val_fieldID);
  dlartg_(&f, &g, &__ncs, &__nsn, &__nr);
done:
  if (!failed) (*env)->SetDoubleField(env, r, doubleW_val_fieldID, __nr);
  if (!failed) (*env)->SetDoubleField(env, sn, doubleW_val_fieldID, __nsn);
  if (!failed) (*env)->SetDoubleField(env, cs, doubleW_val_fieldID, __ncs);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlartv_)(int *n, double *x, int *incx, double *y, int *incy, double *c, double *s, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlartvK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jdoubleArray y, jint offsety, jint incy, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jint incc) {
  jboolean failed = FALSE;
  double *__nx = NULL; double *__ny = NULL; double *__nc = NULL; double *__ns = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dlartv_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, __nc + offsetc, __ns + offsets, &incc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaruv_)(int *iseed, int *n, double *x);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaruvK(JNIEnv *env, UNUSED jobject obj, jintArray iseed, jint offsetiseed, jint n, jdoubleArray x, jint offsetx) {
  jboolean failed = FALSE;
  int *__niseed = NULL; double *__nx = NULL;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlaruv_(__niseed + offsetiseed, &n, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarz_)(const char *side, int *m, int *n, int *l, double *v, int *incv, double *tau, double *c, int *Ldc, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarzK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jint l, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; double *__nv = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarz_(__nside, &m, &n, &l, __nv + offsetv, &incv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarzb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, int *l, double *v, int *ldv, double *t, int *ldt, double *c, int *Ldc, double *work, int *ldwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarzbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jint l, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray t, jint offsett, jint ldt, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint ldwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; const char *__ndirect = NULL; const char *__nstorev = NULL; double *__nv = NULL; double *__nt = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlarzb_(__nside, __ntrans, __ndirect, __nstorev, &m, &n, &k, &l, __nv + offsetv, &ldv, __nt + offsett, &ldt, __nc + offsetc, &Ldc, __nwork + offsetwork, &ldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlarzt_)(const char *direct, const char *storev, int *n, int *k, double *v, int *ldv, double *tau, double *t, int *ldt);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlarztK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray tau, jint offsettau, jdoubleArray t, jint offsett, jint ldt) {
  jboolean failed = FALSE;
  const char *__ndirect = NULL; const char *__nstorev = NULL; double *__nv = NULL; double *__ntau = NULL; double *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  dlarzt_(__ndirect, __nstorev, &n, &k, __nv + offsetv, &ldv, __ntau + offsettau, __nt + offsett, &ldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlas2_)(double *f, double *g, double *h, double *ssmin, double *ssmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlas2K(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jdouble h, jobject ssmin, jobject ssmax) {
  jboolean failed = FALSE;
  double __nssmin = 0; double __nssmax = 0;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  __nssmax = (*env)->GetDoubleField(env, ssmax, doubleW_val_fieldID);
  dlas2_(&f, &g, &h, &__nssmin, &__nssmax);
done:
  if (!failed) (*env)->SetDoubleField(env, ssmax, doubleW_val_fieldID, __nssmax);
  if (!failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlascl_)(const char *type, int *kl, int *ku, double *cfrom, double *cto, int *m, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasclK(JNIEnv *env, UNUSED jobject obj, jstring type, jint kl, jint ku, jdouble cfrom, jdouble cto, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__ntype = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__ntype = (*env)->GetStringUTFChars(env, type, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dlascl_(__ntype, &kl, &ku, &cfrom, &cto, &m, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntype) (*env)->ReleaseStringUTFChars(env, type, __ntype);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd0_)(int *n, int *sqre, double *d, double *e, double *u, int *ldu, double *vt, int *ldvt, int *smlsiz, int *iwork, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd0K(JNIEnv *env, UNUSED jobject obj, jint n, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jint smlsiz, jintArray iwork, jint offsetiwork, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nu = NULL; double *__nvt = NULL; int *__niwork = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasd0_(&n, &sqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, &smlsiz, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd1_)(int *nl, int *nr, int *sqre, double *d, double *alpha, double *beta, double *u, int *ldu, double *vt, int *ldvt, int *idxq, int *iwork, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd1K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jdoubleArray d, jint offsetd, jobject alpha, jobject beta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jintArray idxq, jint offsetidxq, jintArray iwork, jint offsetiwork, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  double __nalpha = 0; double __nbeta = 0; int __ninfo = 0; double *__nd = NULL; double *__nu = NULL; double *__nvt = NULL; int *__nidxq = NULL; int *__niwork = NULL; double *__nwork = NULL;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __nbeta = (*env)->GetDoubleField(env, beta, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasd1_(&nl, &nr, &sqre, __nd + offsetd, &__nalpha, &__nbeta, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nidxq + offsetidxq, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, beta, doubleW_val_fieldID, __nbeta);
  if (!failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd2_)(int *nl, int *nr, int *sqre, int *k, double *d, double *z, double *alpha, double *beta, double *u, int *ldu, double *vt, int *ldvt, double *dsigma, double *u2, int *ldu2, double *vt2, int *ldvt2, int *idxp, int *idx, int *idxc, int *idxq, int *coltyp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd2K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jobject k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdouble alpha, jdouble beta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray u2, jint offsetu2, jint ldu2, jdoubleArray vt2, jint offsetvt2, jint ldvt2, jintArray idxp, jint offsetidxp, jintArray idx, jint offsetidx, jintArray idxc, jint offsetidxc, jintArray idxq, jint offsetidxq, jintArray coltyp, jint offsetcoltyp, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; int __ninfo = 0; double *__nd = NULL; double *__nz = NULL; double *__nu = NULL; double *__nvt = NULL; double *__ndsigma = NULL; double *__nu2 = NULL; double *__nvt2 = NULL; int *__nidxp = NULL; int *__nidx = NULL; int *__nidxc = NULL; int *__nidxq = NULL; int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) goto fail;
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) goto fail;
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) goto fail;
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) goto fail;
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) goto fail;
  dlasd2_(&nl, &nr, &sqre, &__nk, __nd + offsetd, __nz + offsetz, &alpha, &beta, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __ndsigma + offsetdsigma, __nu2 + offsetu2, &ldu2, __nvt2 + offsetvt2, &ldvt2, __nidxp + offsetidxp, __nidx + offsetidx, __nidxc + offsetidxc, __nidxq + offsetidxq, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd3_)(int *nl, int *nr, int *sqre, int *k, double *d, double *q, int *ldq, double *dsigma, double *u, int *ldu, double *u2, int *ldu2, double *vt, int *ldvt, double *vt2, int *ldvt2, int *idxc, int *ctot, double *z, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd3K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jint k, jdoubleArray d, jint offsetd, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray u2, jint offsetu2, jint ldu2, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray vt2, jint offsetvt2, jint ldvt2, jintArray idxc, jint offsetidxc, jintArray ctot, jint offsetctot, jdoubleArray z, jint offsetz, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__nq = NULL; double *__ndsigma = NULL; double *__nu = NULL; double *__nu2 = NULL; double *__nvt = NULL; double *__nvt2 = NULL; int *__nidxc = NULL; int *__nctot = NULL; double *__nz = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) goto fail;
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) goto fail;
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasd3_(&nl, &nr, &sqre, &k, __nd + offsetd, __nq + offsetq, &ldq, __ndsigma + offsetdsigma, __nu + offsetu, &ldu, __nu2 + offsetu2, &ldu2, __nvt + offsetvt, &ldvt, __nvt2 + offsetvt2, &ldvt2, __nidxc + offsetidxc, __nctot + offsetctot, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd4_)(int *n, int *i, double *d, double *z, double *delta, double *rho, double *sigma, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject sigma, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  double __nsigma = 0; int __ninfo = 0; double *__nd = NULL; double *__nz = NULL; double *__ndelta = NULL; double *__nwork = NULL;
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasd4_(&n, &i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__nsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd5_)(int *i, double *d, double *z, double *delta, double *rho, double *dsigma, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd5K(JNIEnv *env, UNUSED jobject obj, jint i, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray delta, jint offsetdelta, jdouble rho, jobject dsigma, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  double __ndsigma = 0; double *__nd = NULL; double *__nz = NULL; double *__ndelta = NULL; double *__nwork = NULL;
  __ndsigma = (*env)->GetDoubleField(env, dsigma, doubleW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasd5_(&i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndsigma, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, dsigma, doubleW_val_fieldID, __ndsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd6_)(int *icompq, int *nl, int *nr, int *sqre, double *d, double *vf, double *vl, double *alpha, double *beta, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *poles, double *difl, double *difr, double *z, int *k, double *c, double *s, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd6K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray vf, jint offsetvf, jdoubleArray vl, jint offsetvl, jobject alpha, jobject beta, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jdoubleArray poles, jint offsetpoles, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jobject k, jobject c, jobject s, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  double __nalpha = 0; double __nbeta = 0; int __ngivptr = 0; int __nk = 0; double __nc = 0; double __ns = 0; int __ninfo = 0; double *__nd = NULL; double *__nvf = NULL; double *__nvl = NULL; int *__nidxq = NULL; int *__nperm = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL; double *__npoles = NULL; double *__ndifl = NULL; double *__ndifr = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nalpha = (*env)->GetDoubleField(env, alpha, doubleW_val_fieldID);
  __nbeta = (*env)->GetDoubleField(env, beta, doubleW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlasd6_(&icompq, &nl, &nr, &sqre, __nd + offsetd, __nvf + offsetvf, __nvl + offsetvl, &__nalpha, &__nbeta, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetDoubleField(env, beta, doubleW_val_fieldID, __nbeta);
  if (!failed) (*env)->SetDoubleField(env, alpha, doubleW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd7_)(int *icompq, int *nl, int *nr, int *sqre, int *k, double *d, double *z, double *zw, double *vf, double *vfw, double *vl, double *vlw, double *alpha, double *beta, double *dsigma, int *idx, int *idxp, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, double *givnum, int *ldgnum, double *c, double *s, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jobject k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray zw, jint offsetzw, jdoubleArray vf, jint offsetvf, jdoubleArray vfw, jint offsetvfw, jdoubleArray vl, jint offsetvl, jdoubleArray vlw, jint offsetvlw, jdouble alpha, jdouble beta, jdoubleArray dsigma, jint offsetdsigma, jintArray idx, jint offsetidx, jintArray idxp, jint offsetidxp, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jdoubleArray givnum, jint offsetgivnum, jint ldgnum, jobject c, jobject s, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; int __ngivptr = 0; double __nc = 0; double __ns = 0; int __ninfo = 0; double *__nd = NULL; double *__nz = NULL; double *__nzw = NULL; double *__nvf = NULL; double *__nvfw = NULL; double *__nvl = NULL; double *__nvlw = NULL; double *__ndsigma = NULL; int *__nidx = NULL; int *__nidxp = NULL; int *__nidxq = NULL; int *__nperm = NULL; int *__ngivcol = NULL; double *__ngivnum = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nc = (*env)->GetDoubleField(env, c, doubleW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nzw = (*env)->GetPrimitiveArrayCritical(env, zw, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvfw = (*env)->GetPrimitiveArrayCritical(env, vfw, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvlw = (*env)->GetPrimitiveArrayCritical(env, vlw, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) goto fail;
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  dlasd7_(&icompq, &nl, &nr, &sqre, &__nk, __nd + offsetd, __nz + offsetz, __nzw + offsetzw, __nvf + offsetvf, __nvfw + offsetvfw, __nvl + offsetvl, __nvlw + offsetvlw, &alpha, &beta, __ndsigma + offsetdsigma, __nidx + offsetidx, __nidxp + offsetidxp, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, &__nc, &__ns, &__ninfo);
done:
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nvlw) (*env)->ReleasePrimitiveArrayCritical(env, vlw, __nvlw, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvfw) (*env)->ReleasePrimitiveArrayCritical(env, vfw, __nvfw, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nzw) (*env)->ReleasePrimitiveArrayCritical(env, zw, __nzw, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!failed) (*env)->SetDoubleField(env, c, doubleW_val_fieldID, __nc);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasd8_)(int *icompq, int *k, double *d, double *z, double *vf, double *vl, double *difl, double *difr, int *lddifr, double *dsigma, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasd8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint k, jdoubleArray d, jint offsetd, jdoubleArray z, jint offsetz, jdoubleArray vf, jint offsetvf, jdoubleArray vl, jint offsetvl, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jint lddifr, jdoubleArray dsigma, jint offsetdsigma, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__nz = NULL; double *__nvf = NULL; double *__nvl = NULL; double *__ndifl = NULL; double *__ndifr = NULL; double *__ndsigma = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasd8_(&icompq, &k, __nd + offsetd, __nz + offsetz, __nvf + offsetvf, __nvl + offsetvl, __ndifl + offsetdifl, __ndifr + offsetdifr, &lddifr, __ndsigma + offsetdsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasda_)(int *icompq, int *smlsiz, int *n, int *sqre, double *d, double *e, double *u, int *ldu, double *vt, int *k, double *difl, double *difr, double *z, double *poles, int *givptr, int *givcol, int *ldgcol, int *perm, double *givnum, double *c, double *s, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint sqre, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray vt, jint offsetvt, jintArray k, jint offsetk, jdoubleArray difl, jint offsetdifl, jdoubleArray difr, jint offsetdifr, jdoubleArray z, jint offsetz, jdoubleArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jdoubleArray givnum, jint offsetgivnum, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nu = NULL; double *__nvt = NULL; int *__nk = NULL; double *__ndifl = NULL; double *__ndifr = NULL; double *__nz = NULL; double *__npoles = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; int *__nperm = NULL; double *__ngivnum = NULL; double *__nc = NULL; double *__ns = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dlasda_(&icompq, &smlsiz, &n, &sqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &ldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasdq_)(const char *uplo, int *sqre, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, double *vt, int *ldvt, double *u, int *ldu, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdqK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint sqre, jint n, jint ncvt, jint nru, jint ncc, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray vt, jint offsetvt, jint ldvt, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nvt = NULL; double *__nu = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasdq_(__nuplo, &sqre, &n, &ncvt, &nru, &ncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &ldvt, __nu + offsetu, &ldu, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasdt_)(int *n, int *lvl, int *nd, int *inode, int *ndiml, int *ndimr, int *msub);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasdtK(JNIEnv *env, UNUSED jobject obj, jint n, jobject lvl, jobject nd, jintArray inode, jint offsetinode, jintArray ndiml, jint offsetndiml, jintArray ndimr, jint offsetndimr, jint msub) {
  jboolean failed = FALSE;
  int __nlvl = 0; int __nnd = 0; int *__ninode = NULL; int *__nndiml = NULL; int *__nndimr = NULL;
  __nlvl = (*env)->GetIntField(env, lvl, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__ninode = (*env)->GetPrimitiveArrayCritical(env, inode, NULL))) goto fail;
  if (!(__nndiml = (*env)->GetPrimitiveArrayCritical(env, ndiml, NULL))) goto fail;
  if (!(__nndimr = (*env)->GetPrimitiveArrayCritical(env, ndimr, NULL))) goto fail;
  dlasdt_(&n, &__nlvl, &__nnd, __ninode + offsetinode, __nndiml + offsetndiml, __nndimr + offsetndimr, &msub);
done:
  if (__nndimr) (*env)->ReleasePrimitiveArrayCritical(env, ndimr, __nndimr, failed ? JNI_ABORT : 0);
  if (__nndiml) (*env)->ReleasePrimitiveArrayCritical(env, ndiml, __nndiml, failed ? JNI_ABORT : 0);
  if (__ninode) (*env)->ReleasePrimitiveArrayCritical(env, inode, __ninode, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, lvl, intW_val_fieldID, __nlvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaset_)(const char *uplo, int *m, int *n, double *alpha, double *beta, double *a, int *lda);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasetK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jdouble alpha, jdouble beta, jdoubleArray a, jint offseta, jint lda) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dlaset_(__nuplo, &m, &n, &alpha, &beta, __na + offseta, &lda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq1_)(int *n, double *d, double *e, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq1K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlasq1_(&n, __nd + offsetd, __ne + offsete, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq2_)(int *n, double *z, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq2K(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray z, jint offsetz, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nz = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasq2_(&n, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq3_)(int *i0, int *n0, double *z, int *pp, double *dmin, double *sigma, double *desig, double *qmax, int *nfail, int *iter, int *ndiv, int *ieee);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq3K(JNIEnv *env, UNUSED jobject obj, jint i0, jobject n0, jdoubleArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee) {
  jboolean failed = FALSE;
  int __nn0 = 0; double __ndmin = 0; double __nsigma = 0; double __ndesig = 0; double __nqmax = 0; int __nnfail = 0; int __niter = 0; int __nndiv = 0; int __nieee; double *__nz = NULL;
  __nn0 = (*env)->GetIntField(env, n0, intW_val_fieldID);
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __nsigma = (*env)->GetDoubleField(env, sigma, doubleW_val_fieldID);
  __ndesig = (*env)->GetDoubleField(env, desig, doubleW_val_fieldID);
  __nqmax = (*env)->GetDoubleField(env, qmax, doubleW_val_fieldID);
  __nnfail = (*env)->GetIntField(env, nfail, intW_val_fieldID);
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __nndiv = (*env)->GetIntField(env, ndiv, intW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasq3_(&i0, &__nn0, __nz + offsetz, &pp, &__ndmin, &__nsigma, &__ndesig, &__nqmax, &__nnfail, &__niter, &__nndiv, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) ieee = __nieee;
  if (!failed) (*env)->SetIntField(env, ndiv, intW_val_fieldID, __nndiv);
  if (!failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (!failed) (*env)->SetIntField(env, nfail, intW_val_fieldID, __nnfail);
  if (!failed) (*env)->SetDoubleField(env, qmax, doubleW_val_fieldID, __nqmax);
  if (!failed) (*env)->SetDoubleField(env, desig, doubleW_val_fieldID, __ndesig);
  if (!failed) (*env)->SetDoubleField(env, sigma, doubleW_val_fieldID, __nsigma);
  if (!failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (!failed) (*env)->SetIntField(env, n0, intW_val_fieldID, __nn0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq4_)(int *i0, int *n0, double *z, int *pp, int *n0in, double *dmin, double *dmin1, double *dmin2, double *dn, double *dn1, double *dn2, double *tau, int *ttype);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq4K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jint n0in, jdouble dmin, jdouble dmin1, jdouble dmin2, jdouble dn, jdouble dn1, jdouble dn2, jobject tau, jobject ttype) {
  jboolean failed = FALSE;
  double __ntau = 0; int __nttype = 0; double *__nz = NULL;
  __ntau = (*env)->GetDoubleField(env, tau, doubleW_val_fieldID);
  __nttype = (*env)->GetIntField(env, ttype, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasq4_(&i0, &n0, __nz + offsetz, &pp, &n0in, &dmin, &dmin1, &dmin2, &dn, &dn1, &dn2, &__ntau, &__nttype);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, ttype, intW_val_fieldID, __nttype);
  if (!failed) (*env)->SetDoubleField(env, tau, doubleW_val_fieldID, __ntau);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq5_)(int *i0, int *n0, double *z, int *pp, double *tau, double *dmin, double *dmin1, double *dmin2, double *dn, double *dnm1, double *dnm2, int *ieee);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq5K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jdouble tau, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2, jboolean ieee) {
  jboolean failed = FALSE;
  double __ndmin = 0; double __ndmin1 = 0; double __ndmin2 = 0; double __ndn = 0; double __ndnm1 = 0; double __ndnm2 = 0; int __nieee; double *__nz = NULL;
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __ndmin1 = (*env)->GetDoubleField(env, dmin1, doubleW_val_fieldID);
  __ndmin2 = (*env)->GetDoubleField(env, dmin2, doubleW_val_fieldID);
  __ndn = (*env)->GetDoubleField(env, dn, doubleW_val_fieldID);
  __ndnm1 = (*env)->GetDoubleField(env, dnm1, doubleW_val_fieldID);
  __ndnm2 = (*env)->GetDoubleField(env, dnm2, doubleW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasq5_(&i0, &n0, __nz + offsetz, &pp, &tau, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) ieee = __nieee;
  if (!failed) (*env)->SetDoubleField(env, dnm2, doubleW_val_fieldID, __ndnm2);
  if (!failed) (*env)->SetDoubleField(env, dnm1, doubleW_val_fieldID, __ndnm1);
  if (!failed) (*env)->SetDoubleField(env, dn, doubleW_val_fieldID, __ndn);
  if (!failed) (*env)->SetDoubleField(env, dmin2, doubleW_val_fieldID, __ndmin2);
  if (!failed) (*env)->SetDoubleField(env, dmin1, doubleW_val_fieldID, __ndmin1);
  if (!failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasq6_)(int *i0, int *n0, double *z, int *pp, double *dmin, double *dmin1, double *dmin2, double *dn, double *dnm1, double *dnm2);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasq6K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2) {
  jboolean failed = FALSE;
  double __ndmin = 0; double __ndmin1 = 0; double __ndmin2 = 0; double __ndn = 0; double __ndnm1 = 0; double __ndnm2 = 0; double *__nz = NULL;
  __ndmin = (*env)->GetDoubleField(env, dmin, doubleW_val_fieldID);
  __ndmin1 = (*env)->GetDoubleField(env, dmin1, doubleW_val_fieldID);
  __ndmin2 = (*env)->GetDoubleField(env, dmin2, doubleW_val_fieldID);
  __ndn = (*env)->GetDoubleField(env, dn, doubleW_val_fieldID);
  __ndnm1 = (*env)->GetDoubleField(env, dnm1, doubleW_val_fieldID);
  __ndnm2 = (*env)->GetDoubleField(env, dnm2, doubleW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  dlasq6_(&i0, &n0, __nz + offsetz, &pp, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, dnm2, doubleW_val_fieldID, __ndnm2);
  if (!failed) (*env)->SetDoubleField(env, dnm1, doubleW_val_fieldID, __ndnm1);
  if (!failed) (*env)->SetDoubleField(env, dn, doubleW_val_fieldID, __ndn);
  if (!failed) (*env)->SetDoubleField(env, dmin2, doubleW_val_fieldID, __ndmin2);
  if (!failed) (*env)->SetDoubleField(env, dmin1, doubleW_val_fieldID, __ndmin1);
  if (!failed) (*env)->SetDoubleField(env, dmin, doubleW_val_fieldID, __ndmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasr_)(const char *side, const char *pivot, const char *direct, int *m, int *n, double *c, double *s, double *a, int *lda);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring pivot, jstring direct, jint m, jint n, jdoubleArray c, jint offsetc, jdoubleArray s, jint offsets, jdoubleArray a, jint offseta, jint lda) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__npivot = NULL; const char *__ndirect = NULL; double *__nc = NULL; double *__ns = NULL; double *__na = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__npivot = (*env)->GetStringUTFChars(env, pivot, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dlasr_(__nside, __npivot, __ndirect, &m, &n, __nc + offsetc, __ns + offsets, __na + offseta, &lda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__npivot) (*env)->ReleaseStringUTFChars(env, pivot, __npivot);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasrt_)(const char *id, int *n, double *d, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasrtK(JNIEnv *env, UNUSED jobject obj, jstring id, jint n, jdoubleArray d, jint offsetd, jobject info) {
  jboolean failed = FALSE;
  const char *__nid = NULL; int __ninfo = 0; double *__nd = NULL;
  if (!(__nid = (*env)->GetStringUTFChars(env, id, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  dlasrt_(__nid, &n, __nd + offsetd, &__ninfo);
done:
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nid) (*env)->ReleaseStringUTFChars(env, id, __nid);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlassq_)(int *n, double *x, int *incx, double *scale, double *sumsq);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlassqK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray x, jint offsetx, jint incx, jobject scale, jobject sumsq) {
  jboolean failed = FALSE;
  double __nscale = 0; double __nsumsq = 0; double *__nx = NULL;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nsumsq = (*env)->GetDoubleField(env, sumsq, doubleW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlassq_(&n, __nx + offsetx, &incx, &__nscale, &__nsumsq);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, sumsq, doubleW_val_fieldID, __nsumsq);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasv2_)(double *f, double *g, double *h, double *ssmin, double *ssmax, double *snr, double *csr, double *snl, double *csl);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasv2K(JNIEnv *env, UNUSED jobject obj, jdouble f, jdouble g, jdouble h, jobject ssmin, jobject ssmax, jobject snr, jobject csr, jobject snl, jobject csl) {
  jboolean failed = FALSE;
  double __nssmin = 0; double __nssmax = 0; double __nsnr = 0; double __ncsr = 0; double __nsnl = 0; double __ncsl = 0;
  __nssmin = (*env)->GetDoubleField(env, ssmin, doubleW_val_fieldID);
  __nssmax = (*env)->GetDoubleField(env, ssmax, doubleW_val_fieldID);
  __nsnr = (*env)->GetDoubleField(env, snr, doubleW_val_fieldID);
  __ncsr = (*env)->GetDoubleField(env, csr, doubleW_val_fieldID);
  __nsnl = (*env)->GetDoubleField(env, snl, doubleW_val_fieldID);
  __ncsl = (*env)->GetDoubleField(env, csl, doubleW_val_fieldID);
  dlasv2_(&f, &g, &h, &__nssmin, &__nssmax, &__nsnr, &__ncsr, &__nsnl, &__ncsl);
done:
  if (!failed) (*env)->SetDoubleField(env, csl, doubleW_val_fieldID, __ncsl);
  if (!failed) (*env)->SetDoubleField(env, snl, doubleW_val_fieldID, __nsnl);
  if (!failed) (*env)->SetDoubleField(env, csr, doubleW_val_fieldID, __ncsr);
  if (!failed) (*env)->SetDoubleField(env, snr, doubleW_val_fieldID, __nsnr);
  if (!failed) (*env)->SetDoubleField(env, ssmax, doubleW_val_fieldID, __nssmax);
  if (!failed) (*env)->SetDoubleField(env, ssmin, doubleW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlaswp_)(int *n, double *a, int *lda, int *k1, int *k2, int *ipiv, int *incx);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlaswpK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jint k1, jint k2, jintArray ipiv, jint offsetipiv, jint incx) {
  jboolean failed = FALSE;
  double *__na = NULL; int *__nipiv = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dlaswp_(&n, __na + offseta, &lda, &k1, &k2, __nipiv + offsetipiv, &incx);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasy2_)(int *ltranl, int *ltranr, int *isgn, int *n1, int *n2, double *tl, int *ldtl, double *tr, int *ldtr, double *b, int *ldb, double *scale, double *x, int *ldx, double *xnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasy2K(JNIEnv *env, UNUSED jobject obj, jboolean ltranl, jboolean ltranr, jint isgn, jint n1, jint n2, jdoubleArray tl, jint offsettl, jint ldtl, jdoubleArray tr, jint offsettr, jint ldtr, jdoubleArray b, jint offsetb, jint ldb, jobject scale, jdoubleArray x, jint offsetx, jint ldx, jobject xnorm, jobject info) {
  jboolean failed = FALSE;
  int __nltranl; int __nltranr; double __nscale = 0; double __nxnorm = 0; int __ninfo = 0; double *__ntl = NULL; double *__ntr = NULL; double *__nb = NULL; double *__nx = NULL;
  __nltranl = ltranl;
  __nltranr = ltranr;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nxnorm = (*env)->GetDoubleField(env, xnorm, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ntl = (*env)->GetPrimitiveArrayCritical(env, tl, NULL))) goto fail;
  if (!(__ntr = (*env)->GetPrimitiveArrayCritical(env, tr, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  dlasy2_(&__nltranl, &__nltranr, &isgn, &n1, &n2, __ntl + offsettl, &ldtl, __ntr + offsettr, &ldtr, __nb + offsetb, &ldb, &__nscale, __nx + offsetx, &ldx, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntr) (*env)->ReleasePrimitiveArrayCritical(env, tr, __ntr, failed ? JNI_ABORT : 0);
  if (__ntl) (*env)->ReleasePrimitiveArrayCritical(env, tl, __ntl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, xnorm, doubleW_val_fieldID, __nxnorm);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (!failed) ltranr = __nltranr;
  if (!failed) ltranl = __nltranl;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlasyf_)(const char *uplo, int *n, int *nb, int *kb, double *a, int *lda, int *ipiv, double *w, int *ldw, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlasyfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jobject kb, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray w, jint offsetw, jint ldw, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __nkb = 0; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  dlasyf_(__nuplo, &n, &nb, &__nkb, __na + offseta, &lda, __nipiv + offsetipiv, __nw + offsetw, &ldw, &__ninfo);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatbs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, int *kd, double *ab, int *ldab, double *x, double *scale, double *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatbsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; double __nscale = 0; int __ninfo = 0; double *__nab = NULL; double *__nx = NULL; double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  dlatbs_(__nuplo, __ntrans, __ndiag, __nnormin, &n, &kd, __nab + offsetab, &ldab, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatdf_)(int *ijob, int *n, double *z, int *ldz, double *rhs, double *rdsum, double *rdscal, int *ipiv, int *jpiv);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatdfK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint n, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray rhs, jint offsetrhs, jobject rdsum, jobject rdscal, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv) {
  jboolean failed = FALSE;
  double __nrdsum = 0; double __nrdscal = 0; double *__nz = NULL; double *__nrhs = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __nrdsum = (*env)->GetDoubleField(env, rdsum, doubleW_val_fieldID);
  __nrdscal = (*env)->GetDoubleField(env, rdscal, doubleW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  dlatdf_(&ijob, &n, __nz + offsetz, &ldz, __nrhs + offsetrhs, &__nrdsum, &__nrdscal, __nipiv + offsetipiv, __njpiv + offsetjpiv);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetDoubleField(env, rdscal, doubleW_val_fieldID, __nrdscal);
  if (!failed) (*env)->SetDoubleField(env, rdsum, doubleW_val_fieldID, __nrdsum);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatps_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, double *ap, double *x, double *scale, double *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatpsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jdoubleArray ap, jint offsetap, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; double __nscale = 0; int __ninfo = 0; double *__nap = NULL; double *__nx = NULL; double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  dlatps_(__nuplo, __ntrans, __ndiag, __nnormin, &n, __nap + offsetap, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatrd_)(const char *uplo, int *n, int *nb, double *a, int *lda, double *e, double *tau, double *w, int *ldw);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jdoubleArray a, jint offseta, jint lda, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jdoubleArray w, jint offsetw, jint ldw) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double *__na = NULL; double *__ne = NULL; double *__ntau = NULL; double *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  dlatrd_(__nuplo, &n, &nb, __na + offseta, &lda, __ne + offsete, __ntau + offsettau, __nw + offsetw, &ldw);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatrs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, double *a, int *lda, double *x, double *scale, double *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray x, jint offsetx, jobject scale, jdoubleArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; double __nscale = 0; int __ninfo = 0; double *__na = NULL; double *__nx = NULL; double *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  dlatrs_(__nuplo, __ntrans, __ndiag, __nnormin, &n, __na + offseta, &lda, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatrz_)(int *m, int *n, int *l, double *a, int *lda, double *tau, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatrzK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlatrz_(&m, &n, &l, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlatzm_)(const char *side, int *m, int *n, double *v, int *incv, double *tau, double *c1, double *c2, int *Ldc, double *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlatzmK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jdoubleArray v, jint offsetv, jint incv, jdouble tau, jdoubleArray c1, jint offsetc1, jdoubleArray c2, jint offsetc2, jint Ldc, jdoubleArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; double *__nv = NULL; double *__nc1 = NULL; double *__nc2 = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc1 = (*env)->GetPrimitiveArrayCritical(env, c1, NULL))) goto fail;
  if (!(__nc2 = (*env)->GetPrimitiveArrayCritical(env, c2, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dlatzm_(__nside, &m, &n, __nv + offsetv, &incv, &tau, __nc1 + offsetc1, __nc2 + offsetc2, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc2) (*env)->ReleasePrimitiveArrayCritical(env, c2, __nc2, failed ? JNI_ABORT : 0);
  if (__nc1) (*env)->ReleasePrimitiveArrayCritical(env, c1, __nc1, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlauu2_)(const char *uplo, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlauu2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dlauu2_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dlauum_)(const char *uplo, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlauumK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dlauum_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dopgtr_)(const char *uplo, int *n, double *ap, double *tau, double *q, int *ldq, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dopgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray tau, jint offsettau, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__ntau = NULL; double *__nq = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dopgtr_(__nuplo, &n, __nap + offsetap, __ntau + offsettau, __nq + offsetq, &ldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dopmtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, double *ap, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dopmtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jdoubleArray ap, jint offsetap, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nuplo = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__nap = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dopmtr_(__nside, __nuplo, __ntrans, &m, &n, __nap + offsetap, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorg2l_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorg2lK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorg2l_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorg2r_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorg2rK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorg2r_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgbr_)(const char *vect, int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgbr_(__nvect, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorghr_)(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorghrK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorghr_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgl2_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgl2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgl2_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorglq_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorglqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorglq_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgql_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgqlK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgql_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgqr_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgqrK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgqr_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgr2_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgr2_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgrq_)(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgrqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgrq_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorgtr_)(const char *uplo, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorgtr_(__nuplo, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorm2l_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorm2lK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorm2l_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorm2r_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorm2rK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorm2r_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormbr_)(const char *vect, const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormbr_(__nvect, __nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormhr_)(const char *side, const char *trans, int *m, int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormhrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint ilo, jint ihi, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormhr_(__nside, __ntrans, &m, &n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dorml2_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dorml2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dorml2_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormlq_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormlqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormlq_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormql_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormqlK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormql_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormqr_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormqrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormqr_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormr2_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormr2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormr2_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormr3_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormr3K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormr3_(__nside, __ntrans, &m, &n, &k, &l, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormrq_)(const char *side, const char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormrqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormrq_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormrz_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormrzK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormrz_(__nside, __ntrans, &m, &n, &k, &l, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dormtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, double *a, int *lda, double *tau, double *c, int *Ldc, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dormtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nuplo = NULL; const char *__ntrans = NULL; int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nc = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dormtr_(__nside, __nuplo, __ntrans, &m, &n, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbcon_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__nab = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dpbcon_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbequ_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, double *s, double *scond, double *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nscond = 0; double __namax = 0; int __ninfo = 0; double *__nab = NULL; double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dpbequ_(__nuplo, &n, &kd, __nab + offsetab, &ldab, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbrfs_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nafb = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dpbrfs_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbstf_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbstfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  dpbstf_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbsv_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dpbsv_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbsvx_)(const char *fact, const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray afb, jint offsetafb, jint ldafb, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double __nrcond = 0; int __ninfo = 0; double *__nab = NULL; double *__nafb = NULL; double *__ns = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dpbsvx_(__nfact, __nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbtf2_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  dpbtf2_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbtrf_)(const char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  dpbtrf_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpbtrs_)(const char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dpbtrs_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpocon_)(const char *uplo, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpoconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dpocon_(__nuplo, &n, __na + offseta, &lda, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpoequ_)(int *n, double *a, int *lda, double *s, double *scond, double *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpoequK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  double __nscond = 0; double __namax = 0; int __ninfo = 0; double *__na = NULL; double *__ns = NULL;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dpoequ_(&n, __na + offseta, &lda, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dporfs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dporfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dporfs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dposv_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dposvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dposv_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dposvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dposvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; double *__ns = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dposvx_(__nfact, __nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpotf2_)(const char *uplo, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dpotf2_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpotrf_)(const char *uplo, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dpotrf_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpotri_)(const char *uplo, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dpotri_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpotrs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpotrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dpotrs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dppcon_)(const char *uplo, int *n, double *ap, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__nap = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dppcon_(__nuplo, &n, __nap + offsetap, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dppequ_)(const char *uplo, int *n, double *ap, double *s, double *scond, double *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nscond = 0; double __namax = 0; int __ninfo = 0; double *__nap = NULL; double *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nscond = (*env)->GetDoubleField(env, scond, doubleW_val_fieldID);
  __namax = (*env)->GetDoubleField(env, amax, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  dppequ_(__nuplo, &n, __nap + offsetap, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, amax, doubleW_val_fieldID, __namax);
  if (!failed) (*env)->SetDoubleField(env, scond, doubleW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpprfs_)(const char *uplo, int *n, int *nrhs, double *ap, double *afp, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nafp = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dpprfs_(__nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dppsv_)(const char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dppsv_(__nuplo, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dppsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *ap, double *afp, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dppsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jobject equed, jdoubleArray s, jint offsets, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; double __nrcond = 0; int __ninfo = 0; double *__nap = NULL; double *__nafp = NULL; double *__ns = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dppsvx_(__nfact, __nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpptrf_)(const char *uplo, int *n, double *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  dpptrf_(__nuplo, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpptri_)(const char *uplo, int *n, double *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  dpptri_(__nuplo, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpptrs_)(const char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dpptrs_(__nuplo, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dptcon_)(int *n, double *d, double *e, double *anorm, double *rcond, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptconK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  double __nrcond = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nwork = NULL;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dptcon_(&n, __nd + offsetd, __ne + offsete, &anorm, &__nrcond, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpteqr_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dpteqr_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dptrfs_)(int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptrfsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray df, jint offsetdf, jdoubleArray ef, jint offsetef, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__ndf = NULL; double *__nef = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dptrfs_(&n, &nrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dptsv_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dptsv_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dptsvx_)(const char *fact, int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray df, jint offsetdf, jdoubleArray ef, jint offsetef, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; double __nrcond = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__ndf = NULL; double *__nef = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dptsvx_(__nfact, &n, &nrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpttrf_)(int *n, double *d, double *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  dpttrf_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dpttrs_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dpttrsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dpttrs_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dptts2_)(int *n, int *nrhs, double *d, double *e, double *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dptts2K(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  double *__nd = NULL; double *__ne = NULL; double *__nb = NULL;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dptts2_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*drscl_)(int *n, double *sa, double *sx, int *incx);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_drsclK(JNIEnv *env, UNUSED jobject obj, jint n, jdouble sa, jdoubleArray sx, jint offsetsx, jint incx) {
  jboolean failed = FALSE;
  double *__nsx = NULL;
  if (!(__nsx = (*env)->GetPrimitiveArrayCritical(env, sx, NULL))) goto fail;
  drscl_(&n, &sa, __nsx + offsetsx, &incx);
done:
  if (__nsx) (*env)->ReleasePrimitiveArrayCritical(env, sx, __nsx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbev_)(const char *jobz, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsbev_(__njobz, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbevd_)(const char *jobz, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsbevd_(__njobz, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbevx_)(const char *jobz, const char *range, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray q, jint offsetq, jint ldq, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__nab = NULL; double *__nq = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dsbevx_(__njobz, __nrange, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nq + offsetq, &ldq, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbgst_)(const char *vect, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *x, int *ldx, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgstK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nbb = NULL; double *__nx = NULL; double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsbgst_(__nvect, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nx + offsetx, &ldx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbgv_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *w, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nbb = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsbgv_(__njobz, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbgvd_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nbb = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsbgvd_(__njobz, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbgvx_)(const char *jobz, const char *range, const char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbgvxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint ka, jint kb, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray bb, jint offsetbb, jint ldbb, jdoubleArray q, jint offsetq, jint ldq, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__nab = NULL; double *__nbb = NULL; double *__nq = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dsbgvx_(__njobz, __nrange, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nq + offsetq, &ldq, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsbtrd_)(const char *vect, const char *uplo, int *n, int *kd, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsbtrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nab = NULL; double *__nd = NULL; double *__ne = NULL; double *__nq = NULL; double *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsbtrd_(__nvect, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsgesv_)(int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *work, float *swork, int *iter, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray work, jint offsetwork, jfloatArray swork, jint offsetswork, jobject iter, jobject info) {
  jboolean failed = FALSE;
  int __niter = 0; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nwork = NULL; float *__nswork = NULL;
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__nswork = (*env)->GetPrimitiveArrayCritical(env, swork, NULL))) goto fail;
  dsgesv_(&n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nwork + offsetwork, __nswork + offsetswork, &__niter, &__ninfo);
done:
  if (__nswork) (*env)->ReleasePrimitiveArrayCritical(env, swork, __nswork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspcon_)(const char *uplo, int *n, double *ap, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__nap = NULL; int *__nipiv = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dspcon_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspev_)(const char *jobz, const char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dspev_(__njobz, __nuplo, &n, __nap + offsetap, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspevd_)(const char *jobz, const char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dspevd_(__njobz, __nuplo, &n, __nap + offsetap, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspevx_)(const char *jobz, const char *range, const char *uplo, int *n, double *ap, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__nap = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dspevx_(__njobz, __nrange, __nuplo, &n, __nap + offsetap, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspgst_)(int *itype, const char *uplo, int *n, double *ap, double *bp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nbp = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  dspgst_(&itype, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, &__ninfo);
done:
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspgv_)(int *itype, const char *jobz, const char *uplo, int *n, double *ap, double *bp, double *w, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nbp = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dspgv_(&itype, __njobz, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspgvd_)(int *itype, const char *jobz, const char *uplo, int *n, double *ap, double *bp, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nbp = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dspgvd_(&itype, __njobz, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspgvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, double *ap, double *bp, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspgvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray bp, jint offsetbp, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__nap = NULL; double *__nbp = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dspgvx_(&itype, __njobz, __nrange, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsprfs_)(const char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nafp = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsprfs_(__nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspsv_)(const char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dspsv_(__nuplo, &n, &nrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dspsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dspsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__nap = NULL; double *__nafp = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dspsvx_(__nfact, __nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsptrd_)(const char *uplo, int *n, double *ap, double *d, double *e, double *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  dsptrd_(__nuplo, &n, __nap + offsetap, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsptrf_)(const char *uplo, int *n, double *ap, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dsptrf_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsptri_)(const char *uplo, int *n, double *ap, int *ipiv, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; int *__nipiv = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsptri_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsptrs_)(const char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__nap = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dsptrs_(__nuplo, &n, &nrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstebz_)(const char *range, const char *order, int *n, double *vl, double *vu, int *il, int *iu, double *abstol, double *d, double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstebzK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject m, jobject nsplit, jdoubleArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; const char *__norder = NULL; int __nm = 0; int __nnsplit = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; int *__niblock = NULL; int *__nisplit = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstebz_(__nrange, __norder, &n, &vl, &vu, &il, &iu, &abstol, __nd + offsetd, __ne + offsete, &__nm, &__nnsplit, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstedc_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstedcK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstedc_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstegr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstegrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstegr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstein_)(int *n, double *d, double *e, int *m, double *w, int *iblock, int *isplit, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsteinK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jint m, jdoubleArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; int *__niblock = NULL; int *__nisplit = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dstein_(&n, __nd + offsetd, __ne + offsete, &m, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstemr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, int *m, double *w, double *z, int *ldz, int *nzc, int *isuppz, int *tryrac, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstemrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jint nzc, jintArray isuppz, jint offsetisuppz, jobject tryrac, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ntryrac = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ntryrac = (*env)->GetBooleanField(env, tryrac, booleanW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstemr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &__nm, __nw + offsetw, __nz + offsetz, &ldz, &nzc, __nisuppz + offsetisuppz, &__ntryrac, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetBooleanField(env, tryrac, booleanW_val_fieldID, __ntryrac);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsteqr_)(const char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsteqr_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsterf_)(int *n, double *d, double *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsterfK(JNIEnv *env, UNUSED jobject obj, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__nd = NULL; double *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  dsterf_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstev_)(const char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nz = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dstev_(__njobz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstevd_)(const char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstevd_(__njobz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstevr_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dstevr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dstevx_)(const char *jobz, const char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dstevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; double *__nd = NULL; double *__ne = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dstevx_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsycon_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdouble anorm, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsycon_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsyev_)(const char *jobz, const char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nw = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsyev_(__njobz, __nuplo, &n, __na + offseta, &lda, __nw + offsetw, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsyevd_)(const char *jobz, const char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nw = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsyevd_(__njobz, __nuplo, &n, __na + offseta, &lda, __nw + offsetw, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsyevr_)(const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, int *isuppz, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__na = NULL; double *__nw = NULL; double *__nz = NULL; int *__nisuppz = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsyevr_(__njobz, __nrange, __nuplo, &n, __na + offseta, &lda, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsyevx_)(const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__na = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dsyevx_(__njobz, __nrange, __nuplo, &n, __na + offseta, &lda, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsygs2_)(int *itype, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygs2K(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dsygs2_(&itype, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsygst_)(int *itype, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dsygst_(&itype, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsygv_)(int *itype, const char *jobz, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *w, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nw = NULL; double *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsygv_(&itype, __njobz, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nw + offsetw, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsygvd_)(int *itype, const char *jobz, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *w, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray w, jint offsetw, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nw = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsygvd_(&itype, __njobz, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nw + offsetw, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsygvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsygvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble vl, jdouble vu, jint il, jint iu, jdouble abstol, jobject m, jdoubleArray w, jint offsetw, jdoubleArray z, jint offsetz, jint ldz, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nw = NULL; double *__nz = NULL; double *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  dsygvx_(&itype, __njobz, __nrange, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsyrfs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsyrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsyrfs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsysv_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsysvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsysv_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsysvx_)(const char *fact, const char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsysvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jobject rcond, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__naf = NULL; int *__nipiv = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dsysvx_(__nfact, __nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytd2_)(const char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytd2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  dsytd2_(__nuplo, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytf2_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  dsytf2_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytrd_)(const char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray d, jint offsetd, jdoubleArray e, jint offsete, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; double *__nd = NULL; double *__ne = NULL; double *__ntau = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsytrd_(__nuplo, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytrf_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsytrf_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytri_)(const char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dsytri_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dsytrs_)(const char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dsytrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; double *__na = NULL; int *__nipiv = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dsytrs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtbcon_)(const char *norm, const char *uplo, const char *diag, int *n, int *kd, double *ab, int *ldab, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint kd, jdoubleArray ab, jint offsetab, jint ldab, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double __nrcond = 0; int __ninfo = 0; double *__nab = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtbcon_(__nnorm, __nuplo, __ndiag, &n, &kd, __nab + offsetab, &ldab, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtbrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__nab = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtbrfs_(__nuplo, __ntrans, __ndiag, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtbtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jdoubleArray ab, jint offsetab, jint ldab, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__nab = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dtbtrs_(__nuplo, __ntrans, __ndiag, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgevc_)(const char *side, const char *howmny, int *select, int *n, double *s, int *lds, double *p, int *ldp, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray s, jint offsets, jint lds, jdoubleArray p, jint offsetp, jint ldp, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__ns = NULL; double *__np = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__np = (*env)->GetPrimitiveArrayCritical(env, p, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtgevc_(__nside, __nhowmny, __nselect + offsetselect, &n, __ns + offsets, &lds, __np + offsetp, &ldp, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__np) (*env)->ReleasePrimitiveArrayCritical(env, p, __np, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgex2_)(int *wantq, int *wantz, int *n, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *j1, int *n1, int *n2, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgex2K(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jint j1, jint n1, jint n2, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nq = NULL; double *__nz = NULL; double *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtgex2_(&__nwantq, &__nwantz, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &j1, &n1, &n2, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgexc_)(int *wantq, int *wantz, int *n, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *ifst, int *ilst, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject ifst, jobject ilst, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __nifst = 0; int __nilst = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nq = NULL; double *__nz = NULL; double *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtgexc_(&__nwantq, &__nwantz, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__nifst, &__nilst, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgsen_)(int *ijob, int *wantq, int *wantz, int *select, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *q, int *ldq, double *z, int *ldz, int *m, double *pl, double *pr, double *dif, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsenK(JNIEnv *env, UNUSED jobject obj, jint ijob, jboolean wantq, jboolean wantz, jbooleanArray select, jint offsetselect, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray z, jint offsetz, jint ldz, jobject m, jobject pl, jobject pr, jdoubleArray dif, jint offsetdif, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __nm = 0; double __npl = 0; double __npr = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__na = NULL; double *__nb = NULL; double *__nalphar = NULL; double *__nalphai = NULL; double *__nbeta = NULL; double *__nq = NULL; double *__nz = NULL; double *__ndif = NULL; double *__nwork = NULL; int *__niwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npl = (*env)->GetDoubleField(env, pl, doubleW_val_fieldID);
  __npr = (*env)->GetDoubleField(env, pr, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtgsen_(&ijob, &__nwantq, &__nwantz, __nselect + offsetselect, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__nm, &__npl, &__npr, __ndif + offsetdif, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, pr, doubleW_val_fieldID, __npr);
  if (!failed) (*env)->SetDoubleField(env, pl, doubleW_val_fieldID, __npl);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgsja_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *ncycle, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsjaK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jint k, jint l, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdouble tola, jdouble tolb, jdoubleArray alpha, jint offsetalpha, jdoubleArray beta, jint offsetbeta, jdoubleArray u, jint offsetu, jint ldu, jdoubleArray v, jint offsetv, jint ldv, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray work, jint offsetwork, jobject ncycle, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nncycle = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nalpha = NULL; double *__nbeta = NULL; double *__nu = NULL; double *__nv = NULL; double *__nq = NULL; double *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nncycle = (*env)->GetIntField(env, ncycle, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtgsja_(__njobu, __njobv, __njobq, &m, &p, &n, &k, &l, __na + offseta, &lda, __nb + offsetb, &ldb, &tola, &tolb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __nwork + offsetwork, &__nncycle, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ncycle, intW_val_fieldID, __nncycle);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgsna_)(const char *job, const char *howmny, int *select, int *n, double *a, int *lda, double *b, int *ldb, double *vl, int *ldvl, double *vr, int *ldvr, double *s, double *dif, int *mm, int *m, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray s, jint offsets, jdoubleArray dif, jint offsetdif, jint mm, jobject m, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__na = NULL; double *__nb = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__ns = NULL; double *__ndif = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtgsna_(__njob, __nhowmny, __nselect + offsetselect, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __ns + offsets, __ndif + offsetdif, &mm, &__nm, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgsy2_)(const char *trans, int *ijob, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *d, int *ldd, double *e, int *lde, double *f, int *ldf, double *scale, double *rdsum, double *rdscal, int *iwork, int *pq, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsy2K(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray d, jint offsetd, jint ldd, jdoubleArray e, jint offsete, jint lde, jdoubleArray f, jint offsetf, jint ldf, jobject scale, jobject rdsum, jobject rdscal, jintArray iwork, jint offsetiwork, jobject pq, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; double __nscale = 0; double __nrdsum = 0; double __nrdscal = 0; int __npq = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL; double *__nd = NULL; double *__ne = NULL; double *__nf = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __nrdsum = (*env)->GetDoubleField(env, rdsum, doubleW_val_fieldID);
  __nrdscal = (*env)->GetDoubleField(env, rdscal, doubleW_val_fieldID);
  __npq = (*env)->GetIntField(env, pq, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtgsy2_(__ntrans, &ijob, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, __nd + offsetd, &ldd, __ne + offsete, &lde, __nf + offsetf, &ldf, &__nscale, &__nrdsum, &__nrdscal, __niwork + offsetiwork, &__npq, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, pq, intW_val_fieldID, __npq);
  if (!failed) (*env)->SetDoubleField(env, rdscal, doubleW_val_fieldID, __nrdscal);
  if (!failed) (*env)->SetDoubleField(env, rdsum, doubleW_val_fieldID, __nrdsum);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtgsyl_)(const char *trans, int *ijob, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *d, int *ldd, double *e, int *lde, double *f, int *ldf, double *scale, double *dif, double *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtgsylK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jdoubleArray d, jint offsetd, jint ldd, jdoubleArray e, jint offsete, jint lde, jdoubleArray f, jint offsetf, jint ldf, jobject scale, jobject dif, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; double __nscale = 0; double __ndif = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL; double *__nd = NULL; double *__ne = NULL; double *__nf = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ndif = (*env)->GetDoubleField(env, dif, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtgsyl_(__ntrans, &ijob, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, __nd + offsetd, &ldd, __ne + offsete, &lde, __nf + offsetf, &ldf, &__nscale, &__ndif, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, dif, doubleW_val_fieldID, __ndif);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtpcon_)(const char *norm, const char *uplo, const char *diag, int *n, double *ap, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtpconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double __nrcond = 0; int __ninfo = 0; double *__nap = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtpcon_(__nnorm, __nuplo, __ndiag, &n, __nap + offsetap, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtprfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__nap = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtprfs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtptri_)(const char *uplo, const char *diag, int *n, double *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  dtptri_(__nuplo, __ndiag, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtptrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray ap, jint offsetap, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__nap = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dtptrs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrcon_)(const char *norm, const char *uplo, const char *diag, int *n, double *a, int *lda, double *rcond, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject rcond, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; double __nrcond = 0; int __ninfo = 0; double *__na = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetDoubleField(env, rcond, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtrcon_(__nnorm, __nuplo, __ndiag, &n, __na + offseta, &lda, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, rcond, doubleW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrevc_)(const char *side, const char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__nt = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtrevc_(__nside, __nhowmny, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrexc_)(const char *compq, int *n, double *t, int *ldt, double *q, int *ldq, int *ifst, int *ilst, double *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrexcK(JNIEnv *env, UNUSED jobject obj, jstring compq, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jobject ifst, jobject ilst, jdoubleArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompq = NULL; int __nifst = 0; int __nilst = 0; int __ninfo = 0; double *__nt = NULL; double *__nq = NULL; double *__nwork = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtrexc_(__ncompq, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, &__nifst, &__nilst, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray x, jint offsetx, jint ldx, jdoubleArray ferr, jint offsetferr, jdoubleArray berr, jint offsetberr, jdoubleArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nx = NULL; double *__nferr = NULL; double *__nberr = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtrrfs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrsen_)(const char *job, const char *compq, int *select, int *n, double *t, int *ldt, double *q, int *ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsenK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray q, jint offsetq, jint ldq, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jobject m, jobject s, jobject sep, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompq = NULL; int __nm = 0; double __ns = 0; double __nsep = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__nt = NULL; double *__nq = NULL; double *__nwr = NULL; double *__nwi = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ns = (*env)->GetDoubleField(env, s, doubleW_val_fieldID);
  __nsep = (*env)->GetDoubleField(env, sep, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtrsen_(__njob, __ncompq, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, __nwr + offsetwr, __nwi + offsetwi, &__nm, &__ns, &__nsep, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, sep, doubleW_val_fieldID, __nsep);
  if (!failed) (*env)->SetDoubleField(env, s, doubleW_val_fieldID, __ns);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrsna_)(const char *job, const char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, double *s, double *sep, int *mm, int *m, double *work, int *ldwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jdoubleArray t, jint offsett, jint ldt, jdoubleArray vl, jint offsetvl, jint ldvl, jdoubleArray vr, jint offsetvr, jint ldvr, jdoubleArray s, jint offsets, jdoubleArray sep, jint offsetsep, jint mm, jobject m, jdoubleArray work, jint offsetwork, jint ldwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; double *__nt = NULL; double *__nvl = NULL; double *__nvr = NULL; double *__ns = NULL; double *__nsep = NULL; double *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  dtrsna_(__njob, __nhowmny, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __ns + offsets, __nsep + offsetsep, &mm, &__nm, __nwork + offsetwork, &ldwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrsyl_)(const char *trana, const char *tranb, int *isgn, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *Ldc, double *scale, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrsylK(JNIEnv *env, UNUSED jobject obj, jstring trana, jstring tranb, jint isgn, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jdoubleArray c, jint offsetc, jint Ldc, jobject scale, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrana = NULL; const char *__ntranb = NULL; double __nscale = 0; int __ninfo = 0; double *__na = NULL; double *__nb = NULL; double *__nc = NULL;
  if (!(__ntrana = (*env)->GetStringUTFChars(env, trana, NULL))) goto fail;
  if (!(__ntranb = (*env)->GetStringUTFChars(env, tranb, NULL))) goto fail;
  __nscale = (*env)->GetDoubleField(env, scale, doubleW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  dtrsyl_(__ntrana, __ntranb, &isgn, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, &__nscale, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetDoubleField(env, scale, doubleW_val_fieldID, __nscale);
  if (__ntranb) (*env)->ReleaseStringUTFChars(env, tranb, __ntranb);
  if (__ntrana) (*env)->ReleaseStringUTFChars(env, trana, __ntrana);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrti2_)(const char *uplo, const char *diag, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrti2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dtrti2_(__nuplo, __ndiag, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrtri_)(const char *uplo, const char *diag, int *n, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrtriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  dtrtri_(__nuplo, __ndiag, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtrtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtrtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; double *__na = NULL; double *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  dtrtrs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtzrqf_)(int *m, int *n, double *a, int *lda, double *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtzrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  dtzrqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*dtzrzf_)(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dtzrzfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray tau, jint offsettau, jdoubleArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; double *__na = NULL; double *__ntau = NULL; double *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  dtzrzf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*ieeeck_)(int *ispec, float *zero, float *one);

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_ieeeckK(JNIEnv *env, UNUSED jobject obj, jint ispec, jfloat zero, jfloat one) {
  jint __ret;
  jboolean failed = FALSE;
  

  __ret = ieeeck_(&ispec, &zero, &one);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static int (*ilaenv_)(int *ispec, const char *name, const char *opts, int *n1, int *n2, int *n3, int *n4);

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_ilaenvK(JNIEnv *env, UNUSED jobject obj, jint ispec, jstring name, jstring opts, jint n1, jint n2, jint n3, jint n4) {
  jint __ret;
  jboolean failed = FALSE;
  const char *__nname = NULL; const char *__nopts = NULL;
  if (!(__nname = (*env)->GetStringUTFChars(env, name, NULL))) goto fail;
  if (!(__nopts = (*env)->GetStringUTFChars(env, opts, NULL))) goto fail;
  __ret = ilaenv_(&ispec, __nname, __nopts, &n1, &n2, &n3, &n4);
done:
  if (__nopts) (*env)->ReleaseStringUTFChars(env, opts, __nopts);
  if (__nname) (*env)->ReleaseStringUTFChars(env, name, __nname);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*ilaver_)(int *vers_major, int *vers_minor, int *vers_patch);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ilaverK(JNIEnv *env, UNUSED jobject obj, jobject vers_major, jobject vers_minor, jobject vers_patch) {
  jboolean failed = FALSE;
  int __nvers_major = 0; int __nvers_minor = 0; int __nvers_patch = 0;
  __nvers_major = (*env)->GetIntField(env, vers_major, intW_val_fieldID);
  __nvers_minor = (*env)->GetIntField(env, vers_minor, intW_val_fieldID);
  __nvers_patch = (*env)->GetIntField(env, vers_patch, intW_val_fieldID);
  ilaver_(&__nvers_major, &__nvers_minor, &__nvers_patch);
done:
  if (!failed) (*env)->SetIntField(env, vers_patch, intW_val_fieldID, __nvers_patch);
  if (!failed) (*env)->SetIntField(env, vers_minor, intW_val_fieldID, __nvers_minor);
  if (!failed) (*env)->SetIntField(env, vers_major, intW_val_fieldID, __nvers_major);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*iparmq_)(int *ispec, const char *name, const char *opts, int *n, int *ilo, int *ihi, int *lwork);

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_iparmqK(JNIEnv *env, UNUSED jobject obj, jint ispec, jstring name, jstring opts, jint n, jint ilo, jint ihi, jint lwork) {
  jint __ret;
  jboolean failed = FALSE;
  const char *__nname = NULL; const char *__nopts = NULL;
  if (!(__nname = (*env)->GetStringUTFChars(env, name, NULL))) goto fail;
  if (!(__nopts = (*env)->GetStringUTFChars(env, opts, NULL))) goto fail;
  __ret = iparmq_(&ispec, __nname, __nopts, &n, &ilo, &ihi, &lwork);
done:
  if (__nopts) (*env)->ReleaseStringUTFChars(env, opts, __nopts);
  if (__nname) (*env)->ReleaseStringUTFChars(env, name, __nname);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static int (*lsamen_)(int *n, const char *ca, const char *cb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_lsamenK(JNIEnv *env, UNUSED jobject obj, jint n, jstring ca, jstring cb) {
  jboolean __ret;
  jboolean failed = FALSE;
  const char *__nca = NULL; const char *__ncb = NULL;
  if (!(__nca = (*env)->GetStringUTFChars(env, ca, NULL))) goto fail;
  if (!(__ncb = (*env)->GetStringUTFChars(env, cb, NULL))) goto fail;
  __ret = lsamen_(&n, __nca, __ncb);
done:
  if (__ncb) (*env)->ReleaseStringUTFChars(env, cb, __ncb);
  if (__nca) (*env)->ReleaseStringUTFChars(env, ca, __nca);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*sbdsdc_)(const char *uplo, const char *compq, int *n, float *d, float *e, float *u, int *ldu, float *vt, int *ldvt, float *q, int *iq, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sbdsdcK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring compq, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray q, jint offsetq, jintArray iq, jint offsetiq, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ncompq = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nu = NULL; float *__nvt = NULL; float *__nq = NULL; int *__niq = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__niq = (*env)->GetPrimitiveArrayCritical(env, iq, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sbdsdc_(__nuplo, __ncompq, &n, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nq + offsetq, __niq + offsetiq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niq) (*env)->ReleasePrimitiveArrayCritical(env, iq, __niq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sbdsqr_)(const char *uplo, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, float *vt, int *ldvt, float *u, int *ldu, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sbdsqrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint ncvt, jint nru, jint ncc, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray u, jint offsetu, jint ldu, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nvt = NULL; float *__nu = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sbdsqr_(__nuplo, &n, &ncvt, &nru, &ncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &ldvt, __nu + offsetu, &ldu, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sdisna_)(const char *job, int *m, int *n, float *d, float *sep, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sdisnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jint m, jint n, jfloatArray d, jint offsetd, jfloatArray sep, jint offsetsep, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __ninfo = 0; float *__nd = NULL; float *__nsep = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) goto fail;
  sdisna_(__njob, &m, &n, __nd + offsetd, __nsep + offsetsep, &__ninfo);
done:
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbbrd_)(const char *vect, int *m, int *n, int *ncc, int *kl, int *ku, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *pt, int *ldpt, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbbrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint ncc, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray pt, jint offsetpt, jint ldpt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; int __ninfo = 0; float *__nab = NULL; float *__nd = NULL; float *__ne = NULL; float *__nq = NULL; float *__npt = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__npt = (*env)->GetPrimitiveArrayCritical(env, pt, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgbbrd_(__nvect, &m, &n, &ncc, &kl, &ku, __nab + offsetab, &ldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __npt + offsetpt, &ldpt, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__npt) (*env)->ReleasePrimitiveArrayCritical(env, pt, __npt, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbcon_)(const char *norm, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float __nrcond = 0; int __ninfo = 0; float *__nab = NULL; int *__nipiv = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgbcon_(__nnorm, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbequ_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  jboolean failed = FALSE;
  float __nrowcnd = 0; float __ncolcnd = 0; float __namax = 0; int __ninfo = 0; float *__nab = NULL; float *__nr = NULL; float *__nc = NULL;
  __nrowcnd = (*env)->GetFloatField(env, rowcnd, floatW_val_fieldID);
  __ncolcnd = (*env)->GetFloatField(env, colcnd, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  sgbequ_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!failed) (*env)->SetFloatField(env, colcnd, floatW_val_fieldID, __ncolcnd);
  if (!failed) (*env)->SetFloatField(env, rowcnd, floatW_val_fieldID, __nrowcnd);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbrfs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__nab = NULL; float *__nafb = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgbrfs_(__ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbsv_)(int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nab = NULL; int *__nipiv = NULL; float *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgbsv_(&n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbsvx_)(const char *fact, const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jintArray ipiv, jint offsetipiv, jobject equed, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float __nrcond = 0; int __ninfo = 0; float *__nab = NULL; float *__nafb = NULL; int *__nipiv = NULL; float *__nr = NULL; float *__nc = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgbsvx_(__nfact, __ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbtf2_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nab = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  sgbtf2_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbtrf_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nab = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  sgbtrf_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgbtrs_)(const char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgbtrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint kl, jint ku, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__nab = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgbtrs_(__ntrans, &n, &kl, &ku, &nrhs, __nab + offsetab, &ldab, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgebak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, float *scale, int *m, float *v, int *ldv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jfloatArray scale, jint offsetscale, jint m, jfloatArray v, jint offsetv, jint ldv, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nside = NULL; int __ninfo = 0; float *__nscale = NULL; float *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  sgebak_(__njob, __nside, &n, &ilo, &ihi, __nscale + offsetscale, &m, __nv + offsetv, &ldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgebal_)(const char *job, int *n, float *a, int *lda, int *ilo, int *ihi, float *scale, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jfloatArray a, jint offseta, jint lda, jobject ilo, jobject ihi, jfloatArray scale, jint offsetscale, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __nilo = 0; int __nihi = 0; int __ninfo = 0; float *__na = NULL; float *__nscale = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  sgebal_(__njob, &n, __na + offseta, &lda, &__nilo, &__nihi, __nscale + offsetscale, &__ninfo);
done:
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgebd2_)(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebd2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntauq = NULL; float *__ntaup = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgebd2_(&m, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgebrd_)(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgebrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntauq = NULL; float *__ntaup = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgebrd_(&m, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgecon_)(const char *norm, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray a, jint offseta, jint lda, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgecon_(__nnorm, &n, __na + offseta, &lda, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeequ_)(int *m, int *n, float *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeequK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jobject rowcnd, jobject colcnd, jobject amax, jobject info) {
  jboolean failed = FALSE;
  float __nrowcnd = 0; float __ncolcnd = 0; float __namax = 0; int __ninfo = 0; float *__na = NULL; float *__nr = NULL; float *__nc = NULL;
  __nrowcnd = (*env)->GetFloatField(env, rowcnd, floatW_val_fieldID);
  __ncolcnd = (*env)->GetFloatField(env, colcnd, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  sgeequ_(&m, &n, __na + offseta, &lda, __nr + offsetr, __nc + offsetc, &__nrowcnd, &__ncolcnd, &__namax, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!failed) (*env)->SetFloatField(env, colcnd, floatW_val_fieldID, __ncolcnd);
  if (!failed) (*env)->SetFloatField(env, rowcnd, floatW_val_fieldID, __nrowcnd);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeev_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; float *__na = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeev_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jfloatArray scale, jint offsetscale, jobject abnrm, jfloatArray rconde, jint offsetrconde, jfloatArray rcondv, jint offsetrcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nbalanc = NULL; const char *__njobvl = NULL; const char *__njobvr = NULL; const char *__nsense = NULL; int __nilo = 0; int __nihi = 0; float __nabnrm = 0; int __ninfo = 0; float *__na = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nscale = NULL; float *__nrconde = NULL; float *__nrcondv = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) goto fail;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetFloatField(env, abnrm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nscale = (*env)->GetPrimitiveArrayCritical(env, scale, NULL))) goto fail;
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) goto fail;
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgeevx_(__nbalanc, __njobvl, __njobvr, __nsense, &n, __na + offseta, &lda, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &__nilo, &__nihi, __nscale + offsetscale, &__nabnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, failed ? JNI_ABORT : 0);
  if (__nscale) (*env)->ReleasePrimitiveArrayCritical(env, scale, __nscale, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, abnrm, floatW_val_fieldID, __nabnrm);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgegs_)(const char *jobvsl, const char *jobvsr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgegsK(JNIEnv *env, UNUSED jobject obj, jstring jobvsl, jstring jobvsr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vsl, jint offsetvsl, jint ldvsl, jfloatArray vsr, jint offsetvsr, jint ldvsr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvsl = NULL; const char *__njobvsr = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nvsl = NULL; float *__nvsr = NULL; float *__nwork = NULL;
  if (!(__njobvsl = (*env)->GetStringUTFChars(env, jobvsl, NULL))) goto fail;
  if (!(__njobvsr = (*env)->GetStringUTFChars(env, jobvsr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvsl = (*env)->GetPrimitiveArrayCritical(env, vsl, NULL))) goto fail;
  if (!(__nvsr = (*env)->GetPrimitiveArrayCritical(env, vsr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgegs_(__njobvsl, __njobvsr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvsl + offsetvsl, &ldvsl, __nvsr + offsetvsr, &ldvsr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvsr) (*env)->ReleasePrimitiveArrayCritical(env, vsr, __nvsr, failed ? JNI_ABORT : 0);
  if (__nvsl) (*env)->ReleasePrimitiveArrayCritical(env, vsl, __nvsl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvsr) (*env)->ReleaseStringUTFChars(env, jobvsr, __njobvsr);
  if (__njobvsl) (*env)->ReleaseStringUTFChars(env, jobvsl, __njobvsl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgegv_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgegvK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgegv_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgehd2_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgehd2K(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgehd2_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgehrd_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgehrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgehrd_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelq2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgelq2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelqf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgelqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgels_)(const char *trans, int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgels_(__ntrans, &m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelsd_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray s, jint offsets, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__ns = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgelsd_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __ns + offsets, &rcond, &__nrank, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelss_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelssK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray s, jint offsets, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__ns = NULL; float *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgelss_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __ns + offsets, &rcond, &__nrank, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelsx_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *jpvt, float *rcond, int *rank, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsxK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; int *__njpvt = NULL; float *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgelsx_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __njpvt + offsetjpvt, &rcond, &__nrank, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgelsy_)(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *jpvt, float *rcond, int *rank, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgelsyK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jintArray jpvt, jint offsetjpvt, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nrank = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; int *__njpvt = NULL; float *__nwork = NULL;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgelsy_(&m, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __njpvt + offsetjpvt, &rcond, &__nrank, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeql2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeql2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeql2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeqlf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqlfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeqlf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeqp3_)(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqp3K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__njpvt = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeqp3_(&m, &n, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeqpf_)(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqpfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__njpvt = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeqpf_(&m, &n, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeqr2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeqr2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgeqrf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeqrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgeqrf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgerfs_)(const char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgerfs_(__ntrans, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgerq2_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerq2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgerq2_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgerqf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgerqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgerqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgesc2_)(int *n, float *a, int *lda, float *rhs, int *ipiv, int *jpiv, float *scale);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesc2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray rhs, jint offsetrhs, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject scale) {
  jboolean failed = FALSE;
  float __nscale = 0; float *__na = NULL; float *__nrhs = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  sgesc2_(&n, __na + offseta, &lda, __nrhs + offsetrhs, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__nscale);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgesdd_)(const char *jobz, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesddK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; float *__na = NULL; float *__ns = NULL; float *__nu = NULL; float *__nvt = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgesdd_(__njobz, &m, &n, __na + offseta, &lda, __ns + offsets, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgesv_)(int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgesv_(&n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgesvd_)(const char *jobu, const char *jobvt, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobvt, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobvt = NULL; int __ninfo = 0; float *__na = NULL; float *__ns = NULL; float *__nu = NULL; float *__nvt = NULL; float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobvt = (*env)->GetStringUTFChars(env, jobvt, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgesvd_(__njobu, __njobvt, &m, &n, __na + offseta, &lda, __ns + offsets, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvt) (*env)->ReleaseStringUTFChars(env, jobvt, __njobvt);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgesvx_)(const char *fact, const char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgesvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jobject equed, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; int *__nipiv = NULL; float *__nr = NULL; float *__nc = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgesvx_(__nfact, __ntrans, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nequed, __nr + offsetr, __nc + offsetc, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgetc2_)(int *n, float *a, int *lda, int *ipiv, int *jpiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetc2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  sgetc2_(&n, __na + offseta, &lda, __nipiv + offsetipiv, __njpiv + offsetjpiv, &__ninfo);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgetf2_)(int *m, int *n, float *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetf2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  sgetf2_(&m, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgetrf_)(int *m, int *n, float *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetrfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  sgetrf_(&m, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgetri_)(int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetriK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgetri_(&n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgetrs_)(const char *trans, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgetrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgetrs_(__ntrans, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggbak_)(const char *job, const char *side, int *n, int *ilo, int *ihi, float *lscale, float *rscale, int *m, float *v, int *ldv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggbakK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring side, jint n, jint ilo, jint ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jint m, jfloatArray v, jint offsetv, jint ldv, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nside = NULL; int __ninfo = 0; float *__nlscale = NULL; float *__nrscale = NULL; float *__nv = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  sggbak_(__njob, __nside, &n, &ilo, &ihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &m, __nv + offsetv, &ldv, &__ninfo);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggbal_)(const char *job, int *n, float *a, int *lda, float *b, int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggbalK(JNIEnv *env, UNUSED jobject obj, jstring job, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject ilo, jobject ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; int __nilo = 0; int __nihi = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nlscale = NULL; float *__nrscale = NULL; float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggbal_(__njob, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggev_)(const char *jobvl, const char *jobvr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggevK(JNIEnv *env, UNUSED jobject obj, jstring jobvl, jstring jobvr, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobvl = NULL; const char *__njobvr = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggev_(__njobvl, __njobvr, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggevx_)(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *bwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggevxK(JNIEnv *env, UNUSED jobject obj, jstring balanc, jstring jobvl, jstring jobvr, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jobject ilo, jobject ihi, jfloatArray lscale, jint offsetlscale, jfloatArray rscale, jint offsetrscale, jobject abnrm, jobject bbnrm, jfloatArray rconde, jint offsetrconde, jfloatArray rcondv, jint offsetrcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nbalanc = NULL; const char *__njobvl = NULL; const char *__njobvr = NULL; const char *__nsense = NULL; int __nilo = 0; int __nihi = 0; float __nabnrm = 0; float __nbbnrm = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nlscale = NULL; float *__nrscale = NULL; float *__nrconde = NULL; float *__nrcondv = NULL; float *__nwork = NULL; int *__niwork = NULL; jboolean *__jbwork = NULL; int *__nbwork = NULL;
  if (!(__nbalanc = (*env)->GetStringUTFChars(env, balanc, NULL))) goto fail;
  if (!(__njobvl = (*env)->GetStringUTFChars(env, jobvl, NULL))) goto fail;
  if (!(__njobvr = (*env)->GetStringUTFChars(env, jobvr, NULL))) goto fail;
  if (!(__nsense = (*env)->GetStringUTFChars(env, sense, NULL))) goto fail;
  __nilo = (*env)->GetIntField(env, ilo, intW_val_fieldID);
  __nihi = (*env)->GetIntField(env, ihi, intW_val_fieldID);
  __nabnrm = (*env)->GetFloatField(env, abnrm, floatW_val_fieldID);
  __nbbnrm = (*env)->GetFloatField(env, bbnrm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nlscale = (*env)->GetPrimitiveArrayCritical(env, lscale, NULL))) goto fail;
  if (!(__nrscale = (*env)->GetPrimitiveArrayCritical(env, rscale, NULL))) goto fail;
  if (!(__nrconde = (*env)->GetPrimitiveArrayCritical(env, rconde, NULL))) goto fail;
  if (!(__nrcondv = (*env)->GetPrimitiveArrayCritical(env, rcondv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__jbwork = (*env)->GetPrimitiveArrayCritical(env, bwork, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, bwork); if (length <= 0) goto fail; if (!(__nbwork = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nbwork[i] = __jbwork[i]; } } while(0);
  sggevx_(__nbalanc, __njobvl, __njobvr, __nsense, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &__nilo, &__nihi, __nlscale + offsetlscale, __nrscale + offsetrscale, &__nabnrm, &__nbbnrm, __nrconde + offsetrconde, __nrcondv + offsetrcondv, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nbwork + offsetbwork, &__ninfo);
done:
  if (__nbwork) { free(__nbwork); } if (__jbwork) (*env)->ReleasePrimitiveArrayCritical(env, bwork, __nbwork, JNI_ABORT);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nrcondv) (*env)->ReleasePrimitiveArrayCritical(env, rcondv, __nrcondv, failed ? JNI_ABORT : 0);
  if (__nrconde) (*env)->ReleasePrimitiveArrayCritical(env, rconde, __nrconde, failed ? JNI_ABORT : 0);
  if (__nrscale) (*env)->ReleasePrimitiveArrayCritical(env, rscale, __nrscale, failed ? JNI_ABORT : 0);
  if (__nlscale) (*env)->ReleasePrimitiveArrayCritical(env, lscale, __nlscale, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, bbnrm, floatW_val_fieldID, __nbbnrm);
  if (!failed) (*env)->SetFloatField(env, abnrm, floatW_val_fieldID, __nabnrm);
  if (!failed) (*env)->SetIntField(env, ihi, intW_val_fieldID, __nihi);
  if (!failed) (*env)->SetIntField(env, ilo, intW_val_fieldID, __nilo);
  if (__nsense) (*env)->ReleaseStringUTFChars(env, sense, __nsense);
  if (__njobvr) (*env)->ReleaseStringUTFChars(env, jobvr, __njobvr);
  if (__njobvl) (*env)->ReleaseStringUTFChars(env, jobvl, __njobvl);
  if (__nbalanc) (*env)->ReleaseStringUTFChars(env, balanc, __nbalanc);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggglm_)(int *n, int *m, int *p, float *a, int *lda, float *b, int *ldb, float *d, float *x, float *y, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggglmK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray d, jint offsetd, jfloatArray x, jint offsetx, jfloatArray y, jint offsety, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nd = NULL; float *__nx = NULL; float *__ny = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggglm_(&n, &m, &p, __na + offseta, &lda, __nb + offsetb, &ldb, __nd + offsetd, __nx + offsetx, __ny + offsety, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgghrd_)(const char *compq, const char *compz, int *n, int *ilo, int *ihi, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgghrdK(JNIEnv *env, UNUSED jobject obj, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompq = NULL; const char *__ncompz = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nq = NULL; float *__nz = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  sgghrd_(__ncompq, __ncompz, &n, &ilo, &ihi, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgglse_)(int *m, int *n, int *p, float *a, int *lda, float *b, int *ldb, float *c, float *d, float *x, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgglseK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jfloatArray d, jint offsetd, jfloatArray x, jint offsetx, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL; float *__nd = NULL; float *__nx = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sgglse_(&m, &n, &p, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, __nd + offsetd, __nx + offsetx, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggqrf_)(int *n, int *m, int *p, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggqrfK(JNIEnv *env, UNUSED jobject obj, jint n, jint m, jint p, jfloatArray a, jint offseta, jint lda, jfloatArray taua, jint offsettaua, jfloatArray b, jint offsetb, jint ldb, jfloatArray taub, jint offsettaub, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntaua = NULL; float *__nb = NULL; float *__ntaub = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggqrf_(&n, &m, &p, __na + offseta, &lda, __ntaua + offsettaua, __nb + offsetb, &ldb, __ntaub + offsettaub, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggrqf_)(int *m, int *p, int *n, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint p, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray taua, jint offsettaua, jfloatArray b, jint offsetb, jint ldb, jfloatArray taub, jint offsettaub, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntaua = NULL; float *__nb = NULL; float *__ntaub = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntaua = (*env)->GetPrimitiveArrayCritical(env, taua, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__ntaub = (*env)->GetPrimitiveArrayCritical(env, taub, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggrqf_(&m, &p, &n, __na + offseta, &lda, __ntaua + offsettaua, __nb + offsetb, &ldb, __ntaub + offsettaub, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntaub) (*env)->ReleasePrimitiveArrayCritical(env, taub, __ntaub, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntaua) (*env)->ReleasePrimitiveArrayCritical(env, taua, __ntaua, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggsvd_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *n, int *p, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggsvdK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint n, jint p, jobject k, jobject l, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alpha, jint offsetalpha, jfloatArray beta, jint offsetbeta, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nk = 0; int __nl = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalpha = NULL; float *__nbeta = NULL; float *__nu = NULL; float *__nv = NULL; float *__nq = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sggsvd_(__njobu, __njobv, __njobq, &m, &n, &p, &__nk, &__nl, __na + offseta, &lda, __nb + offsetb, &ldb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sggsvp_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, int *k, int *l, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, int *iwork, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggsvpK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat tola, jfloat tolb, jobject k, jobject l, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jintArray iwork, jint offsetiwork, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nk = 0; int __nl = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nu = NULL; float *__nv = NULL; float *__nq = NULL; int *__niwork = NULL; float *__ntau = NULL; float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nl = (*env)->GetIntField(env, l, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sggsvp_(__njobu, __njobv, __njobq, &m, &p, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &tola, &tolb, &__nk, &__nl, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __niwork + offsetiwork, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, l, intW_val_fieldID, __nl);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgtcon_)(const char *norm, int *n, float *dl, float *d, float *du, float *du2, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float __nrcond = 0; int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndu2 = NULL; int *__nipiv = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgtcon_(__nnorm, &n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgtrfs_)(const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtrfsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray dlf, jint offsetdlf, jfloatArray df, jint offsetdf, jfloatArray duf, jint offsetduf, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndlf = NULL; float *__ndf = NULL; float *__nduf = NULL; float *__ndu2 = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgtrfs_(__ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgtsv_)(int *n, int *nrhs, float *dl, float *d, float *du, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgtsv_(&n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgtsvx_)(const char *fact, const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray dlf, jint offsetdlf, jfloatArray df, jint offsetdf, jfloatArray duf, jint offsetduf, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__ntrans = NULL; float __nrcond = 0; int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndlf = NULL; float *__ndf = NULL; float *__nduf = NULL; float *__ndu2 = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndlf = (*env)->GetPrimitiveArrayCritical(env, dlf, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nduf = (*env)->GetPrimitiveArrayCritical(env, duf, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sgtsvx_(__nfact, __ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndlf + offsetdlf, __ndf + offsetdf, __nduf + offsetduf, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__nduf) (*env)->ReleasePrimitiveArrayCritical(env, duf, __nduf, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ndlf) (*env)->ReleasePrimitiveArrayCritical(env, dlf, __ndlf, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgttrf_)(int *n, float *dl, float *d, float *du, float *du2, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndu2 = NULL; int *__nipiv = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  sgttrf_(&n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgttrs_)(const char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *du2, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgttrsK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; int __ninfo = 0; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndu2 = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgttrs_(__ntrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sgtts2_)(int *itrans, int *n, int *nrhs, float *dl, float *d, float *du, float *du2, int *ipiv, float *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgtts2K(JNIEnv *env, UNUSED jobject obj, jint itrans, jint n, jint nrhs, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray du2, jint offsetdu2, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__ndu2 = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__ndu2 = (*env)->GetPrimitiveArrayCritical(env, du2, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sgtts2_(&itrans, &n, &nrhs, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __ndu2 + offsetdu2, __nipiv + offsetipiv, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__ndu2) (*env)->ReleasePrimitiveArrayCritical(env, du2, __ndu2, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*shgeqz_)(const char *job, const char *compq, const char *compz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *t, int *ldt, float *alphar, float *alphai, float *beta, float *q, int *ldq, float *z, int *ldz, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shgeqzK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jstring compz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray t, jint offsett, jint ldt, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompq = NULL; const char *__ncompz = NULL; int __ninfo = 0; float *__nh = NULL; float *__nt = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nq = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  shgeqz_(__njob, __ncompq, __ncompz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nt + offsett, &ldt, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &ldq, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*shsein_)(const char *side, const char *eigsrc, const char *initv, int *select, int *n, float *h, int *ldh, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *ifaill, int *ifailr, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shseinK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring eigsrc, jstring initv, jbooleanArray select, jint offsetselect, jint n, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jintArray ifaill, jint offsetifaill, jintArray ifailr, jint offsetifailr, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__neigsrc = NULL; const char *__ninitv = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__nh = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL; int *__nifaill = NULL; int *__nifailr = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__neigsrc = (*env)->GetStringUTFChars(env, eigsrc, NULL))) goto fail;
  if (!(__ninitv = (*env)->GetStringUTFChars(env, initv, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__nifaill = (*env)->GetPrimitiveArrayCritical(env, ifaill, NULL))) goto fail;
  if (!(__nifailr = (*env)->GetPrimitiveArrayCritical(env, ifailr, NULL))) goto fail;
  shsein_(__nside, __neigsrc, __ninitv, __nselect + offsetselect, &n, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, __nifaill + offsetifaill, __nifailr + offsetifailr, &__ninfo);
done:
  if (__nifailr) (*env)->ReleasePrimitiveArrayCritical(env, ifailr, __nifailr, failed ? JNI_ABORT : 0);
  if (__nifaill) (*env)->ReleasePrimitiveArrayCritical(env, ifaill, __nifaill, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ninitv) (*env)->ReleaseStringUTFChars(env, initv, __ninitv);
  if (__neigsrc) (*env)->ReleaseStringUTFChars(env, eigsrc, __neigsrc);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*shseqr_)(const char *job, const char *compz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, float *z, int *ldz, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_shseqrK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompz = NULL; int __ninfo = 0; float *__nh = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  shseqr_(__njob, __ncompz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*sisnan_)(float *sin);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_sisnanK(JNIEnv *env, UNUSED jobject obj, jfloat sin) {
  jboolean __ret;
  jboolean failed = FALSE;
  

  __ret = sisnan_(&sin);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*slabad_)(float *small, float *large);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slabadK(JNIEnv *env, UNUSED jobject obj, jobject small, jobject large) {
  jboolean failed = FALSE;
  float __nsmall = 0; float __nlarge = 0;
  __nsmall = (*env)->GetFloatField(env, small, floatW_val_fieldID);
  __nlarge = (*env)->GetFloatField(env, large, floatW_val_fieldID);
  slabad_(&__nsmall, &__nlarge);
done:
  if (!failed) (*env)->SetFloatField(env, large, floatW_val_fieldID, __nlarge);
  if (!failed) (*env)->SetFloatField(env, small, floatW_val_fieldID, __nsmall);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slabrd_)(int *m, int *n, int *nb, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *x, int *ldx, float *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slabrdK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tauq, jint offsettauq, jfloatArray taup, jint offsettaup, jfloatArray x, jint offsetx, jint ldx, jfloatArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  float *__na = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntauq = NULL; float *__ntaup = NULL; float *__nx = NULL; float *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntauq = (*env)->GetPrimitiveArrayCritical(env, tauq, NULL))) goto fail;
  if (!(__ntaup = (*env)->GetPrimitiveArrayCritical(env, taup, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  slabrd_(&m, &n, &nb, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntauq + offsettauq, __ntaup + offsettaup, __nx + offsetx, &ldx, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__ntaup) (*env)->ReleasePrimitiveArrayCritical(env, taup, __ntaup, failed ? JNI_ABORT : 0);
  if (__ntauq) (*env)->ReleasePrimitiveArrayCritical(env, tauq, __ntauq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slacn2_)(int *n, float *v, float *x, int *isgn, float *est, int *kase, int *isave);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slacn2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray v, jint offsetv, jfloatArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase, jintArray isave, jint offsetisave) {
  jboolean failed = FALSE;
  float __nest = 0; int __nkase = 0; float *__nv = NULL; float *__nx = NULL; int *__nisgn = NULL; int *__nisave = NULL;
  __nest = (*env)->GetFloatField(env, est, floatW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) goto fail;
  if (!(__nisave = (*env)->GetPrimitiveArrayCritical(env, isave, NULL))) goto fail;
  slacn2_(&n, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase, __nisave + offsetisave);
done:
  if (__nisave) (*env)->ReleasePrimitiveArrayCritical(env, isave, __nisave, failed ? JNI_ABORT : 0);
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!failed) (*env)->SetFloatField(env, est, floatW_val_fieldID, __nest);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slacon_)(int *n, float *v, float *x, int *isgn, float *est, int *kase);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaconK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray v, jint offsetv, jfloatArray x, jint offsetx, jintArray isgn, jint offsetisgn, jobject est, jobject kase) {
  jboolean failed = FALSE;
  float __nest = 0; int __nkase = 0; float *__nv = NULL; float *__nx = NULL; int *__nisgn = NULL;
  __nest = (*env)->GetFloatField(env, est, floatW_val_fieldID);
  __nkase = (*env)->GetIntField(env, kase, intW_val_fieldID);
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nisgn = (*env)->GetPrimitiveArrayCritical(env, isgn, NULL))) goto fail;
  slacon_(&n, __nv + offsetv, __nx + offsetx, __nisgn + offsetisgn, &__nest, &__nkase);
done:
  if (__nisgn) (*env)->ReleasePrimitiveArrayCritical(env, isgn, __nisgn, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kase, intW_val_fieldID, __nkase);
  if (!failed) (*env)->SetFloatField(env, est, floatW_val_fieldID, __nest);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slacpy_)(const char *uplo, int *m, int *n, float *a, int *lda, float *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slacpyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  slacpy_(__nuplo, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sladiv_)(float *a, float *b, float *c, float *d, float *p, float *q);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sladivK(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jfloat d, jobject p, jobject q) {
  jboolean failed = FALSE;
  float __np = 0; float __nq = 0;
  __np = (*env)->GetFloatField(env, p, floatW_val_fieldID);
  __nq = (*env)->GetFloatField(env, q, floatW_val_fieldID);
  sladiv_(&a, &b, &c, &d, &__np, &__nq);
done:
  if (!failed) (*env)->SetFloatField(env, q, floatW_val_fieldID, __nq);
  if (!failed) (*env)->SetFloatField(env, p, floatW_val_fieldID, __np);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slae2_)(float *a, float *b, float *c, float *rt1, float *rt2);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slae2K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jobject rt1, jobject rt2) {
  jboolean failed = FALSE;
  float __nrt1 = 0; float __nrt2 = 0;
  __nrt1 = (*env)->GetFloatField(env, rt1, floatW_val_fieldID);
  __nrt2 = (*env)->GetFloatField(env, rt2, floatW_val_fieldID);
  slae2_(&a, &b, &c, &__nrt1, &__nrt2);
done:
  if (!failed) (*env)->SetFloatField(env, rt2, floatW_val_fieldID, __nrt2);
  if (!failed) (*env)->SetFloatField(env, rt1, floatW_val_fieldID, __nrt1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaebz_)(int *ijob, int *nitmax, int *n, int *mmax, int *minp, int *nbmin, float *abstol, float *reltol, float *pivmin, float *d, float *e, float *e2, int *nval, float *ab, float *c, int *mout, int *nab, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaebzK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint nitmax, jint n, jint mmax, jint minp, jint nbmin, jfloat abstol, jfloat reltol, jfloat pivmin, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jintArray nval, jint offsetnval, jfloatArray ab, jint offsetab, jfloatArray c, jint offsetc, jobject mout, jintArray nab, jint offsetnab, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __nmout = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__ne2 = NULL; int *__nnval = NULL; float *__nab = NULL; float *__nc = NULL; int *__nnab = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nmout = (*env)->GetIntField(env, mout, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nnval = (*env)->GetPrimitiveArrayCritical(env, nval, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nnab = (*env)->GetPrimitiveArrayCritical(env, nab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slaebz_(&ijob, &nitmax, &n, &mmax, &minp, &nbmin, &abstol, &reltol, &pivmin, __nd + offsetd, __ne + offsete, __ne2 + offsete2, __nnval + offsetnval, __nab + offsetab, __nc + offsetc, &__nmout, __nnab + offsetnab, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nnab) (*env)->ReleasePrimitiveArrayCritical(env, nab, __nnab, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nnval) (*env)->ReleasePrimitiveArrayCritical(env, nval, __nnval, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, mout, intW_val_fieldID, __nmout);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed0_)(int *icompq, int *qsiz, int *n, float *d, float *e, float *q, int *ldq, float *qstore, int *ldqs, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint qsiz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray qstore, jint offsetqstore, jint ldqs, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nq = NULL; float *__nqstore = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slaed0_(&icompq, &qsiz, &n, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __nqstore + offsetqstore, &ldqs, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed1_)(int *n, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  float __nrho = 0; int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; int *__nindxq = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slaed1_(&n, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed2_)(int *k, int *n, int *n1, float *d, float *q, int *ldq, int *indxq, float *rho, float *z, float *dlamda, float *w, float *q2, int *indx, int *indxc, int *indxp, int *coltyp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed2K(JNIEnv *env, UNUSED jobject obj, jobject k, jint n, jint n1, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jfloatArray z, jint offsetz, jfloatArray dlamda, jint offsetdlamda, jfloatArray w, jint offsetw, jfloatArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray indxc, jint offsetindxc, jintArray indxp, jint offsetindxp, jintArray coltyp, jint offsetcoltyp, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; float __nrho = 0; int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; int *__nindxq = NULL; float *__nz = NULL; float *__ndlamda = NULL; float *__nw = NULL; float *__nq2 = NULL; int *__nindx = NULL; int *__nindxc = NULL; int *__nindxp = NULL; int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  if (!(__nindxc = (*env)->GetPrimitiveArrayCritical(env, indxc, NULL))) goto fail;
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) goto fail;
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) goto fail;
  slaed2_(&__nk, &n, &n1, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, __nz + offsetz, __ndlamda + offsetdlamda, __nw + offsetw, __nq2 + offsetq2, __nindx + offsetindx, __nindxc + offsetindxc, __nindxp + offsetindxp, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, failed ? JNI_ABORT : 0);
  if (__nindxc) (*env)->ReleasePrimitiveArrayCritical(env, indxc, __nindxc, failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed3_)(int *k, int *n, int *n1, float *d, float *q, int *ldq, float *rho, float *dlamda, float *q2, int *indx, int *ctot, float *w, float *s, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed3K(JNIEnv *env, UNUSED jobject obj, jint k, jint n, jint n1, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloat rho, jfloatArray dlamda, jint offsetdlamda, jfloatArray q2, jint offsetq2, jintArray indx, jint offsetindx, jintArray ctot, jint offsetctot, jfloatArray w, jint offsetw, jfloatArray s, jint offsets, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; float *__ndlamda = NULL; float *__nq2 = NULL; int *__nindx = NULL; int *__nctot = NULL; float *__nw = NULL; float *__ns = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slaed3_(&k, &n, &n1, __nd + offsetd, __nq + offsetq, &ldq, &rho, __ndlamda + offsetdlamda, __nq2 + offsetq2, __nindx + offsetindx, __nctot + offsetctot, __nw + offsetw, __ns + offsets, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, failed ? JNI_ABORT : 0);
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed4_)(int *n, int *i, float *d, float *z, float *delta, float *rho, float *dlam, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dlam, jobject info) {
  jboolean failed = FALSE;
  float __ndlam = 0; int __ninfo = 0; float *__nd = NULL; float *__nz = NULL; float *__ndelta = NULL;
  __ndlam = (*env)->GetFloatField(env, dlam, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  slaed4_(&n, &i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndlam, &__ninfo);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, dlam, floatW_val_fieldID, __ndlam);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed5_)(int *i, float *d, float *z, float *delta, float *rho, float *dlam);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed5K(JNIEnv *env, UNUSED jobject obj, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dlam) {
  jboolean failed = FALSE;
  float __ndlam = 0; float *__nd = NULL; float *__nz = NULL; float *__ndelta = NULL;
  __ndlam = (*env)->GetFloatField(env, dlam, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  slaed5_(&i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndlam);
done:
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, dlam, floatW_val_fieldID, __ndlam);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed6_)(int *kniter, int *orgati, float *rho, float *d, float *z, float *finit, float *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed6K(JNIEnv *env, UNUSED jobject obj, jint kniter, jboolean orgati, jfloat rho, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloat finit, jobject tau, jobject info) {
  jboolean failed = FALSE;
  int __norgati; float __ntau = 0; int __ninfo = 0; float *__nd = NULL; float *__nz = NULL;
  __norgati = orgati;
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slaed6_(&kniter, &__norgati, &rho, __nd + offsetd, __nz + offsetz, &finit, &__ntau, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (!failed) orgati = __norgati;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed7_)(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint n, jint qsiz, jint tlvls, jint curlvl, jint curpbm, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray qstore, jint offsetqstore, jintArray qptr, jint offsetqptr, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  float __nrho = 0; int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; int *__nindxq = NULL; float *__nqstore = NULL; int *__nqptr = NULL; int *__nprmptr = NULL; int *__nperm = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nqstore = (*env)->GetPrimitiveArrayCritical(env, qstore, NULL))) goto fail;
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) goto fail;
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slaed7_(&icompq, &n, &qsiz, &tlvls, &curlvl, &curpbm, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nqstore + offsetqstore, __nqptr + offsetqptr, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, failed ? JNI_ABORT : 0);
  if (__nqstore) (*env)->ReleasePrimitiveArrayCritical(env, qstore, __nqstore, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed8_)(int *icompq, int *k, int *n, int *qsiz, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *z, float *dlamda, float *q2, int *ldq2, float *w, int *perm, int *givptr, int *givcol, float *givnum, int *indxp, int *indx, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jobject k, jint n, jint qsiz, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jintArray indxq, jint offsetindxq, jobject rho, jint cutpnt, jfloatArray z, jint offsetz, jfloatArray dlamda, jint offsetdlamda, jfloatArray q2, jint offsetq2, jint ldq2, jfloatArray w, jint offsetw, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jintArray indxp, jint offsetindxp, jintArray indx, jint offsetindx, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; float __nrho = 0; int __ngivptr = 0; int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; int *__nindxq = NULL; float *__nz = NULL; float *__ndlamda = NULL; float *__nq2 = NULL; float *__nw = NULL; int *__nperm = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL; int *__nindxp = NULL; int *__nindx = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nrho = (*env)->GetFloatField(env, rho, floatW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nindxq = (*env)->GetPrimitiveArrayCritical(env, indxq, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nq2 = (*env)->GetPrimitiveArrayCritical(env, q2, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nindxp = (*env)->GetPrimitiveArrayCritical(env, indxp, NULL))) goto fail;
  if (!(__nindx = (*env)->GetPrimitiveArrayCritical(env, indx, NULL))) goto fail;
  slaed8_(&icompq, &__nk, &n, &qsiz, __nd + offsetd, __nq + offsetq, &ldq, __nindxq + offsetindxq, &__nrho, &cutpnt, __nz + offsetz, __ndlamda + offsetdlamda, __nq2 + offsetq2, &ldq2, __nw + offsetw, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nindxp + offsetindxp, __nindx + offsetindx, &__ninfo);
done:
  if (__nindx) (*env)->ReleasePrimitiveArrayCritical(env, indx, __nindx, failed ? JNI_ABORT : 0);
  if (__nindxp) (*env)->ReleasePrimitiveArrayCritical(env, indxp, __nindxp, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq2) (*env)->ReleasePrimitiveArrayCritical(env, q2, __nq2, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nindxq) (*env)->ReleasePrimitiveArrayCritical(env, indxq, __nindxq, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetFloatField(env, rho, floatW_val_fieldID, __nrho);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaed9_)(int *k, int *kstart, int *kstop, int *n, float *d, float *q, int *ldq, float *rho, float *dlamda, float *w, float *s, int *lds, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaed9K(JNIEnv *env, UNUSED jobject obj, jint k, jint kstart, jint kstop, jint n, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloat rho, jfloatArray dlamda, jint offsetdlamda, jfloatArray w, jint offsetw, jfloatArray s, jint offsets, jint lds, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; float *__ndlamda = NULL; float *__nw = NULL; float *__ns = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndlamda = (*env)->GetPrimitiveArrayCritical(env, dlamda, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slaed9_(&k, &kstart, &kstop, &n, __nd + offsetd, __nq + offsetq, &ldq, &rho, __ndlamda + offsetdlamda, __nw + offsetw, __ns + offsets, &lds, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ndlamda) (*env)->ReleasePrimitiveArrayCritical(env, dlamda, __ndlamda, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaeda_)(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *q, int *qptr, float *z, float *ztemp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaedaK(JNIEnv *env, UNUSED jobject obj, jint n, jint tlvls, jint curlvl, jint curpbm, jintArray prmptr, jint offsetprmptr, jintArray perm, jint offsetperm, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jfloatArray givnum, jint offsetgivnum, jfloatArray q, jint offsetq, jintArray qptr, jint offsetqptr, jfloatArray z, jint offsetz, jfloatArray ztemp, jint offsetztemp, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; int *__nprmptr = NULL; int *__nperm = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL; float *__nq = NULL; int *__nqptr = NULL; float *__nz = NULL; float *__nztemp = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nprmptr = (*env)->GetPrimitiveArrayCritical(env, prmptr, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nqptr = (*env)->GetPrimitiveArrayCritical(env, qptr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nztemp = (*env)->GetPrimitiveArrayCritical(env, ztemp, NULL))) goto fail;
  slaeda_(&n, &tlvls, &curlvl, &curpbm, __nprmptr + offsetprmptr, __nperm + offsetperm, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, __ngivnum + offsetgivnum, __nq + offsetq, __nqptr + offsetqptr, __nz + offsetz, __nztemp + offsetztemp, &__ninfo);
done:
  if (__nztemp) (*env)->ReleasePrimitiveArrayCritical(env, ztemp, __nztemp, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nqptr) (*env)->ReleasePrimitiveArrayCritical(env, qptr, __nqptr, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nprmptr) (*env)->ReleasePrimitiveArrayCritical(env, prmptr, __nprmptr, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaein_)(int *rightv, int *noinit, int *n, float *h, int *ldh, float *wr, float *wi, float *vr, float *vi, float *b, int *ldb, float *work, float *eps3, float *smlnum, float *bignum, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaeinK(JNIEnv *env, UNUSED jobject obj, jboolean rightv, jboolean noinit, jint n, jfloatArray h, jint offseth, jint ldh, jfloat wr, jfloat wi, jfloatArray vr, jint offsetvr, jfloatArray vi, jint offsetvi, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jfloat eps3, jfloat smlnum, jfloat bignum, jobject info) {
  jboolean failed = FALSE;
  int __nrightv; int __nnoinit; int __ninfo = 0; float *__nh = NULL; float *__nvr = NULL; float *__nvi = NULL; float *__nb = NULL; float *__nwork = NULL;
  __nrightv = rightv;
  __nnoinit = noinit;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nvi = (*env)->GetPrimitiveArrayCritical(env, vi, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaein_(&__nrightv, &__nnoinit, &n, __nh + offseth, &ldh, &wr, &wi, __nvr + offsetvr, __nvi + offsetvi, __nb + offsetb, &ldb, __nwork + offsetwork, &eps3, &smlnum, &bignum, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nvi) (*env)->ReleasePrimitiveArrayCritical(env, vi, __nvi, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) noinit = __nnoinit;
  if (!failed) rightv = __nrightv;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaev2_)(float *a, float *b, float *c, float *rt1, float *rt2, float *cs1, float *sn1);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaev2K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b, jfloat c, jobject rt1, jobject rt2, jobject cs1, jobject sn1) {
  jboolean failed = FALSE;
  float __nrt1 = 0; float __nrt2 = 0; float __ncs1 = 0; float __nsn1 = 0;
  __nrt1 = (*env)->GetFloatField(env, rt1, floatW_val_fieldID);
  __nrt2 = (*env)->GetFloatField(env, rt2, floatW_val_fieldID);
  __ncs1 = (*env)->GetFloatField(env, cs1, floatW_val_fieldID);
  __nsn1 = (*env)->GetFloatField(env, sn1, floatW_val_fieldID);
  slaev2_(&a, &b, &c, &__nrt1, &__nrt2, &__ncs1, &__nsn1);
done:
  if (!failed) (*env)->SetFloatField(env, sn1, floatW_val_fieldID, __nsn1);
  if (!failed) (*env)->SetFloatField(env, cs1, floatW_val_fieldID, __ncs1);
  if (!failed) (*env)->SetFloatField(env, rt2, floatW_val_fieldID, __nrt2);
  if (!failed) (*env)->SetFloatField(env, rt1, floatW_val_fieldID, __nrt1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaexc_)(int *wantq, int *n, float *t, int *ldt, float *q, int *ldq, int *j1, int *n1, int *n2, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jint j1, jint n1, jint n2, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __ninfo = 0; float *__nt = NULL; float *__nq = NULL; float *__nwork = NULL;
  __nwantq = wantq;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaexc_(&__nwantq, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, &j1, &n1, &n2, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slag2_)(float *a, int *lda, float *b, int *ldb, float *safmin, float *scale1, float *scale2, float *wr1, float *wr2, float *wi);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slag2K(JNIEnv *env, UNUSED jobject obj, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat safmin, jobject scale1, jobject scale2, jobject wr1, jobject wr2, jobject wi) {
  jboolean failed = FALSE;
  float __nscale1 = 0; float __nscale2 = 0; float __nwr1 = 0; float __nwr2 = 0; float __nwi = 0; float *__na = NULL; float *__nb = NULL;
  __nscale1 = (*env)->GetFloatField(env, scale1, floatW_val_fieldID);
  __nscale2 = (*env)->GetFloatField(env, scale2, floatW_val_fieldID);
  __nwr1 = (*env)->GetFloatField(env, wr1, floatW_val_fieldID);
  __nwr2 = (*env)->GetFloatField(env, wr2, floatW_val_fieldID);
  __nwi = (*env)->GetFloatField(env, wi, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  slag2_(__na + offseta, &lda, __nb + offsetb, &ldb, &safmin, &__nscale1, &__nscale2, &__nwr1, &__nwr2, &__nwi);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, wi, floatW_val_fieldID, __nwi);
  if (!failed) (*env)->SetFloatField(env, wr2, floatW_val_fieldID, __nwr2);
  if (!failed) (*env)->SetFloatField(env, wr1, floatW_val_fieldID, __nwr1);
  if (!failed) (*env)->SetFloatField(env, scale2, floatW_val_fieldID, __nscale2);
  if (!failed) (*env)->SetFloatField(env, scale1, floatW_val_fieldID, __nscale1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slag2d_)(int *m, int *n, float *sa, int *ldsa, double *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slag2dK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray sa, jint offsetsa, jint ldsa, jdoubleArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nsa = NULL; double *__na = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nsa = (*env)->GetPrimitiveArrayCritical(env, sa, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slag2d_(&m, &n, __nsa + offsetsa, &ldsa, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nsa) (*env)->ReleasePrimitiveArrayCritical(env, sa, __nsa, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slags2_)(int *upper, float *a1, float *a2, float *a3, float *b1, float *b2, float *b3, float *csu, float *snu, float *csv, float *snv, float *csq, float *snq);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slags2K(JNIEnv *env, UNUSED jobject obj, jboolean upper, jfloat a1, jfloat a2, jfloat a3, jfloat b1, jfloat b2, jfloat b3, jobject csu, jobject snu, jobject csv, jobject snv, jobject csq, jobject snq) {
  jboolean failed = FALSE;
  int __nupper; float __ncsu = 0; float __nsnu = 0; float __ncsv = 0; float __nsnv = 0; float __ncsq = 0; float __nsnq = 0;
  __nupper = upper;
  __ncsu = (*env)->GetFloatField(env, csu, floatW_val_fieldID);
  __nsnu = (*env)->GetFloatField(env, snu, floatW_val_fieldID);
  __ncsv = (*env)->GetFloatField(env, csv, floatW_val_fieldID);
  __nsnv = (*env)->GetFloatField(env, snv, floatW_val_fieldID);
  __ncsq = (*env)->GetFloatField(env, csq, floatW_val_fieldID);
  __nsnq = (*env)->GetFloatField(env, snq, floatW_val_fieldID);
  slags2_(&__nupper, &a1, &a2, &a3, &b1, &b2, &b3, &__ncsu, &__nsnu, &__ncsv, &__nsnv, &__ncsq, &__nsnq);
done:
  if (!failed) (*env)->SetFloatField(env, snq, floatW_val_fieldID, __nsnq);
  if (!failed) (*env)->SetFloatField(env, csq, floatW_val_fieldID, __ncsq);
  if (!failed) (*env)->SetFloatField(env, snv, floatW_val_fieldID, __nsnv);
  if (!failed) (*env)->SetFloatField(env, csv, floatW_val_fieldID, __ncsv);
  if (!failed) (*env)->SetFloatField(env, snu, floatW_val_fieldID, __nsnu);
  if (!failed) (*env)->SetFloatField(env, csu, floatW_val_fieldID, __ncsu);
  if (!failed) upper = __nupper;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slagtf_)(int *n, float *a, float *lambda, float *b, float *c, float *tol, float *d, int *in, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jfloat lambda, jfloatArray b, jint offsetb, jfloatArray c, jint offsetc, jfloat tol, jfloatArray d, jint offsetd, jintArray in, jint offsetin, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL; float *__nd = NULL; int *__nin = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) goto fail;
  slagtf_(&n, __na + offseta, &lambda, __nb + offsetb, __nc + offsetc, &tol, __nd + offsetd, __nin + offsetin, &__ninfo);
done:
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slagtm_)(const char *trans, int *n, int *nrhs, float *alpha, float *dl, float *d, float *du, float *x, int *ldx, float *beta, float *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtmK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint n, jint nrhs, jfloat alpha, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu, jfloatArray x, jint offsetx, jint ldx, jfloat beta, jfloatArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL; float *__nx = NULL; float *__nb = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  slagtm_(__ntrans, &n, &nrhs, &alpha, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu, __nx + offsetx, &ldx, &beta, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slagts_)(int *job, int *n, float *a, float *b, float *c, float *d, int *in, float *y, float *tol, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagtsK(JNIEnv *env, UNUSED jobject obj, jint job, jint n, jfloatArray a, jint offseta, jfloatArray b, jint offsetb, jfloatArray c, jint offsetc, jfloatArray d, jint offsetd, jintArray in, jint offsetin, jfloatArray y, jint offsety, jobject tol, jobject info) {
  jboolean failed = FALSE;
  float __ntol = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL; float *__nd = NULL; int *__nin = NULL; float *__ny = NULL;
  __ntol = (*env)->GetFloatField(env, tol, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nin = (*env)->GetPrimitiveArrayCritical(env, in, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  slagts_(&job, &n, __na + offseta, __nb + offsetb, __nc + offsetc, __nd + offsetd, __nin + offsetin, __ny + offsety, &__ntol, &__ninfo);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nin) (*env)->ReleasePrimitiveArrayCritical(env, in, __nin, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, tol, floatW_val_fieldID, __ntol);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slagv2_)(float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *csl, float *snl, float *csr, float *snr);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slagv2K(JNIEnv *env, UNUSED jobject obj, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jobject csl, jobject snl, jobject csr, jobject snr) {
  jboolean failed = FALSE;
  float __ncsl = 0; float __nsnl = 0; float __ncsr = 0; float __nsnr = 0; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL;
  __ncsl = (*env)->GetFloatField(env, csl, floatW_val_fieldID);
  __nsnl = (*env)->GetFloatField(env, snl, floatW_val_fieldID);
  __ncsr = (*env)->GetFloatField(env, csr, floatW_val_fieldID);
  __nsnr = (*env)->GetFloatField(env, snr, floatW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  slagv2_(__na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, &__ncsl, &__nsnl, &__ncsr, &__nsnr);
done:
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, snr, floatW_val_fieldID, __nsnr);
  if (!failed) (*env)->SetFloatField(env, csr, floatW_val_fieldID, __ncsr);
  if (!failed) (*env)->SetFloatField(env, snl, floatW_val_fieldID, __nsnl);
  if (!failed) (*env)->SetFloatField(env, csl, floatW_val_fieldID, __ncsl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slahqr_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahqrK(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; float *__nh = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nz = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slahqr_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slahr2_)(int *n, int *k, int *nb, float *a, int *lda, float *tau, float *t, int *ldt, float *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahr2K(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt, jfloatArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  float *__na = NULL; float *__ntau = NULL; float *__nt = NULL; float *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  slahr2_(&n, &k, &nb, __na + offseta, &lda, __ntau + offsettau, __nt + offsett, &ldt, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slahrd_)(int *n, int *k, int *nb, float *a, int *lda, float *tau, float *t, int *ldt, float *y, int *ldy);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slahrdK(JNIEnv *env, UNUSED jobject obj, jint n, jint k, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt, jfloatArray y, jint offsety, jint ldy) {
  jboolean failed = FALSE;
  float *__na = NULL; float *__ntau = NULL; float *__nt = NULL; float *__ny = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  slahrd_(&n, &k, &nb, __na + offseta, &lda, __ntau + offsettau, __nt + offsett, &ldt, __ny + offsety, &ldy);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaic1_)(int *job, int *j, float *x, float *sest, float *w, float *gamma, float *sestpr, float *s, float *c);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaic1K(JNIEnv *env, UNUSED jobject obj, jint job, jint j, jfloatArray x, jint offsetx, jfloat sest, jfloatArray w, jint offsetw, jfloat gamma, jobject sestpr, jobject s, jobject c) {
  jboolean failed = FALSE;
  float __nsestpr = 0; float __ns = 0; float __nc = 0; float *__nx = NULL; float *__nw = NULL;
  __nsestpr = (*env)->GetFloatField(env, sestpr, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  slaic1_(&job, &j, __nx + offsetx, &sest, __nw + offsetw, &gamma, &__nsestpr, &__ns, &__nc);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!failed) (*env)->SetFloatField(env, sestpr, floatW_val_fieldID, __nsestpr);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*slaisnan_)(float *sin1, float *sin2);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_slaisnanK(JNIEnv *env, UNUSED jobject obj, jfloat sin1, jfloat sin2) {
  jboolean __ret;
  jboolean failed = FALSE;
  

  __ret = slaisnan_(&sin1, &sin2);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaln2_)(int *ltrans, int *na, int *nw, float *smin, float *ca, float *a, int *lda, float *d1, float *d2, float *b, int *ldb, float *wr, float *wi, float *x, int *ldx, float *scale, float *xnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaln2K(JNIEnv *env, UNUSED jobject obj, jboolean ltrans, jint na, jint nw, jfloat smin, jfloat ca, jfloatArray a, jint offseta, jint lda, jfloat d1, jfloat d2, jfloatArray b, jint offsetb, jint ldb, jfloat wr, jfloat wi, jfloatArray x, jint offsetx, jint ldx, jobject scale, jobject xnorm, jobject info) {
  jboolean failed = FALSE;
  int __nltrans; float __nscale = 0; float __nxnorm = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nx = NULL;
  __nltrans = ltrans;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nxnorm = (*env)->GetFloatField(env, xnorm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slaln2_(&__nltrans, &na, &nw, &smin, &ca, __na + offseta, &lda, &d1, &d2, __nb + offsetb, &ldb, &wr, &wi, __nx + offsetx, &ldx, &__nscale, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, xnorm, floatW_val_fieldID, __nxnorm);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (!failed) ltrans = __nltrans;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slals0_)(int *icompq, int *nl, int *nr, int *sqre, int *nrhs, float *b, int *ldb, float *bx, int *ldbx, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *poles, float *difl, float *difr, float *z, int *k, float *c, float *s, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slals0K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jint nrhs, jfloatArray b, jint offsetb, jint ldb, jfloatArray bx, jint offsetbx, jint ldbx, jintArray perm, jint offsetperm, jint givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jfloatArray poles, jint offsetpoles, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jint k, jfloat c, jfloat s, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nb = NULL; float *__nbx = NULL; int *__nperm = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL; float *__npoles = NULL; float *__ndifl = NULL; float *__ndifr = NULL; float *__nz = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slals0_(&icompq, &nl, &nr, &sqre, &nrhs, __nb + offsetb, &ldb, __nbx + offsetbx, &ldbx, __nperm + offsetperm, &givptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &k, &c, &s, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slalsa_)(int *icompq, int *smlsiz, int *n, int *nrhs, float *b, int *ldb, float *bx, int *ldbx, float *u, int *ldu, float *vt, int *k, float *difl, float *difr, float *z, float *poles, int *givptr, int *givcol, int *ldgcol, int *perm, float *givnum, float *c, float *s, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slalsaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint nrhs, jfloatArray b, jint offsetb, jint ldb, jfloatArray bx, jint offsetbx, jint ldbx, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jintArray k, jint offsetk, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jfloatArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jfloatArray givnum, jint offsetgivnum, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nb = NULL; float *__nbx = NULL; float *__nu = NULL; float *__nvt = NULL; int *__nk = NULL; float *__ndifl = NULL; float *__ndifr = NULL; float *__nz = NULL; float *__npoles = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; int *__nperm = NULL; float *__ngivnum = NULL; float *__nc = NULL; float *__ns = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nbx = (*env)->GetPrimitiveArrayCritical(env, bx, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slalsa_(&icompq, &smlsiz, &n, &nrhs, __nb + offsetb, &ldb, __nbx + offsetbx, &ldbx, __nu + offsetu, &ldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &ldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbx) (*env)->ReleasePrimitiveArrayCritical(env, bx, __nbx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slalsd_)(const char *uplo, int *smlsiz, int *n, int *nrhs, float *d, float *e, float *b, int *ldb, float *rcond, int *rank, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slalsdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint smlsiz, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jfloat rcond, jobject rank, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __nrank = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nb = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrank = (*env)->GetIntField(env, rank, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slalsd_(__nuplo, &smlsiz, &n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &rcond, &__nrank, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rank, intW_val_fieldID, __nrank);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slamrg_)(int *n1, int *n2, float *a, int *strd1, int *strd2, int *index);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamrgK(JNIEnv *env, UNUSED jobject obj, jint n1, jint n2, jfloatArray a, jint offseta, jint strd1, jint strd2, jintArray index, jint offsetindex) {
  jboolean failed = FALSE;
  float *__na = NULL; int *__nindex = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nindex = (*env)->GetPrimitiveArrayCritical(env, index, NULL))) goto fail;
  slamrg_(&n1, &n2, __na + offseta, &strd1, &strd2, __nindex + offsetindex);
done:
  if (__nindex) (*env)->ReleasePrimitiveArrayCritical(env, index, __nindex, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static int (*slaneg_)(int *n, float *d, float *lld, float *sigma, float *pivmin, int *r);

jint Java_dev_ludovic_netlib_lapack_JNILAPACK_slanegK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray lld, jint offsetlld, jfloat sigma, jfloat pivmin, jint r) {
  jint __ret;
  jboolean failed = FALSE;
  float *__nd = NULL; float *__nlld = NULL;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  __ret = slaneg_(&n, __nd + offsetd, __nlld + offsetlld, &sigma, &pivmin, &r);
done:
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slangb_)(const char *norm, int *n, int *kl, int *ku, float *ab, int *ldab, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float *__nab = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slangb_(__nnorm, &n, &kl, &ku, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slange_)(const char *norm, int *m, int *n, float *a, int *lda, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangeK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float *__na = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slange_(__nnorm, &m, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slangt_)(const char *norm, int *n, float *dl, float *d, float *du);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slangtK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray dl, jint offsetdl, jfloatArray d, jint offsetd, jfloatArray du, jint offsetdu) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float *__ndl = NULL; float *__nd = NULL; float *__ndu = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__ndl = (*env)->GetPrimitiveArrayCritical(env, dl, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ndu = (*env)->GetPrimitiveArrayCritical(env, du, NULL))) goto fail;
  __ret = slangt_(__nnorm, &n, __ndl + offsetdl, __nd + offsetd, __ndu + offsetdu);
done:
  if (__ndu) (*env)->ReleasePrimitiveArrayCritical(env, du, __ndu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ndl) (*env)->ReleasePrimitiveArrayCritical(env, dl, __ndl, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slanhs_)(const char *norm, int *n, float *a, int *lda, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanhsK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float *__na = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slanhs_(__nnorm, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slansb_)(const char *norm, const char *uplo, int *n, int *k, float *ab, int *ldab, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slansbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jint k, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; float *__nab = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slansb_(__nnorm, __nuplo, &n, &k, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slansp_)(const char *norm, const char *uplo, int *n, float *ap, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanspK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; float *__nap = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slansp_(__nnorm, __nuplo, &n, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slanst_)(const char *norm, int *n, float *d, float *e);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slanstK(JNIEnv *env, UNUSED jobject obj, jstring norm, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; float *__nd = NULL; float *__ne = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  __ret = slanst_(__nnorm, &n, __nd + offsetd, __ne + offsete);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slansy_)(const char *norm, const char *uplo, int *n, float *a, int *lda, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slansyK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; float *__na = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slansy_(__nnorm, __nuplo, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slantb_)(const char *norm, const char *uplo, const char *diag, int *n, int *k, float *ab, int *ldab, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantbK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint k, jfloatArray ab, jint offsetab, jint ldab, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float *__nab = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slantb_(__nnorm, __nuplo, __ndiag, &n, &k, __nab + offsetab, &ldab, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slantp_)(const char *norm, const char *uplo, const char *diag, int *n, float *ap, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantpK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float *__nap = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slantp_(__nnorm, __nuplo, __ndiag, &n, __nap + offsetap, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slantr_)(const char *norm, const char *uplo, const char *diag, int *m, int *n, float *a, int *lda, float *work);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slantrK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray work, jint offsetwork) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float *__na = NULL; float *__nwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  __ret = slantr_(__nnorm, __nuplo, __ndiag, &m, &n, __na + offseta, &lda, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*slanv2_)(float *a, float *b, float *c, float *d, float *rt1r, float *rt1i, float *rt2r, float *rt2i, float *cs, float *sn);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slanv2K(JNIEnv *env, UNUSED jobject obj, jobject a, jobject b, jobject c, jobject d, jobject rt1r, jobject rt1i, jobject rt2r, jobject rt2i, jobject cs, jobject sn) {
  jboolean failed = FALSE;
  float __na = 0; float __nb = 0; float __nc = 0; float __nd = 0; float __nrt1r = 0; float __nrt1i = 0; float __nrt2r = 0; float __nrt2i = 0; float __ncs = 0; float __nsn = 0;
  __na = (*env)->GetFloatField(env, a, floatW_val_fieldID);
  __nb = (*env)->GetFloatField(env, b, floatW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __nd = (*env)->GetFloatField(env, d, floatW_val_fieldID);
  __nrt1r = (*env)->GetFloatField(env, rt1r, floatW_val_fieldID);
  __nrt1i = (*env)->GetFloatField(env, rt1i, floatW_val_fieldID);
  __nrt2r = (*env)->GetFloatField(env, rt2r, floatW_val_fieldID);
  __nrt2i = (*env)->GetFloatField(env, rt2i, floatW_val_fieldID);
  __ncs = (*env)->GetFloatField(env, cs, floatW_val_fieldID);
  __nsn = (*env)->GetFloatField(env, sn, floatW_val_fieldID);
  slanv2_(&__na, &__nb, &__nc, &__nd, &__nrt1r, &__nrt1i, &__nrt2r, &__nrt2i, &__ncs, &__nsn);
done:
  if (!failed) (*env)->SetFloatField(env, sn, floatW_val_fieldID, __nsn);
  if (!failed) (*env)->SetFloatField(env, cs, floatW_val_fieldID, __ncs);
  if (!failed) (*env)->SetFloatField(env, rt2i, floatW_val_fieldID, __nrt2i);
  if (!failed) (*env)->SetFloatField(env, rt2r, floatW_val_fieldID, __nrt2r);
  if (!failed) (*env)->SetFloatField(env, rt1i, floatW_val_fieldID, __nrt1i);
  if (!failed) (*env)->SetFloatField(env, rt1r, floatW_val_fieldID, __nrt1r);
  if (!failed) (*env)->SetFloatField(env, d, floatW_val_fieldID, __nd);
  if (!failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!failed) (*env)->SetFloatField(env, b, floatW_val_fieldID, __nb);
  if (!failed) (*env)->SetFloatField(env, a, floatW_val_fieldID, __na);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slapll_)(int *n, float *x, int *incx, float *y, int *incy, float *ssmin);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slapllK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jobject ssmin) {
  jboolean failed = FALSE;
  float __nssmin = 0; float *__nx = NULL; float *__ny = NULL;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  slapll_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, &__nssmin);
done:
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slapmt_)(int *forwrd, int *m, int *n, float *x, int *ldx, int *k);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slapmtK(JNIEnv *env, UNUSED jobject obj, jboolean forwrd, jint m, jint n, jfloatArray x, jint offsetx, jint ldx, jintArray k, jint offsetk) {
  jboolean failed = FALSE;
  int __nforwrd; float *__nx = NULL; int *__nk = NULL;
  __nforwrd = forwrd;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  slapmt_(&__nforwrd, &m, &n, __nx + offsetx, &ldx, __nk + offsetk);
done:
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) forwrd = __nforwrd;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static float (*slapy2_)(float *x, float *y);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slapy2K(JNIEnv *env, UNUSED jobject obj, jfloat x, jfloat y) {
  jfloat __ret;
  jboolean failed = FALSE;
  

  __ret = slapy2_(&x, &y);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slapy3_)(float *x, float *y, float *z);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slapy3K(JNIEnv *env, UNUSED jobject obj, jfloat x, jfloat y, jfloat z) {
  jfloat __ret;
  jboolean failed = FALSE;
  

  __ret = slapy3_(&x, &y, &z);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqgb_)(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqgbK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint kl, jint ku, jfloatArray ab, jint offsetab, jint ldab, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloat rowcnd, jfloat colcnd, jfloat amax, jobject equed) {
  jboolean failed = FALSE;
  char *__nequed = NULL; jstring __jequed = NULL;; float *__nab = NULL; float *__nr = NULL; float *__nc = NULL;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  slaqgb_(&m, &n, &kl, &ku, __nab + offsetab, &ldab, __nr + offsetr, __nc + offsetc, &rowcnd, &colcnd, &amax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqge_)(int *m, int *n, float *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqgeK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray r, jint offsetr, jfloatArray c, jint offsetc, jfloat rowcnd, jfloat colcnd, jfloat amax, jobject equed) {
  jboolean failed = FALSE;
  char *__nequed = NULL; jstring __jequed = NULL;; float *__na = NULL; float *__nr = NULL; float *__nc = NULL;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nr = (*env)->GetPrimitiveArrayCritical(env, r, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  slaqge_(&m, &n, __na + offseta, &lda, __nr + offsetr, __nc + offsetc, &rowcnd, &colcnd, &amax, __nequed);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nr) (*env)->ReleasePrimitiveArrayCritical(env, r, __nr, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqp2_)(int *m, int *n, int *offset, float *a, int *lda, int *jpvt, float *tau, float *vn1, float *vn2, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqp2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray vn1, jint offsetvn1, jfloatArray vn2, jint offsetvn2, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  float *__na = NULL; int *__njpvt = NULL; float *__ntau = NULL; float *__nvn1 = NULL; float *__nvn2 = NULL; float *__nwork = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) goto fail;
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqp2_(&m, &n, &offset, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqps_)(int *m, int *n, int *offset, int *nb, int *kb, float *a, int *lda, int *jpvt, float *tau, float *vn1, float *vn2, float *auxv, float *f, int *ldf);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqpsK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint offset, jint nb, jobject kb, jfloatArray a, jint offseta, jint lda, jintArray jpvt, jint offsetjpvt, jfloatArray tau, jint offsettau, jfloatArray vn1, jint offsetvn1, jfloatArray vn2, jint offsetvn2, jfloatArray auxv, jint offsetauxv, jfloatArray f, jint offsetf, jint ldf) {
  jboolean failed = FALSE;
  int __nkb = 0; float *__na = NULL; int *__njpvt = NULL; float *__ntau = NULL; float *__nvn1 = NULL; float *__nvn2 = NULL; float *__nauxv = NULL; float *__nf = NULL;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__njpvt = (*env)->GetPrimitiveArrayCritical(env, jpvt, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nvn1 = (*env)->GetPrimitiveArrayCritical(env, vn1, NULL))) goto fail;
  if (!(__nvn2 = (*env)->GetPrimitiveArrayCritical(env, vn2, NULL))) goto fail;
  if (!(__nauxv = (*env)->GetPrimitiveArrayCritical(env, auxv, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  slaqps_(&m, &n, &offset, &nb, &__nkb, __na + offseta, &lda, __njpvt + offsetjpvt, __ntau + offsettau, __nvn1 + offsetvn1, __nvn2 + offsetvn2, __nauxv + offsetauxv, __nf + offsetf, &ldf);
done:
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__nauxv) (*env)->ReleasePrimitiveArrayCritical(env, auxv, __nauxv, failed ? JNI_ABORT : 0);
  if (__nvn2) (*env)->ReleasePrimitiveArrayCritical(env, vn2, __nvn2, failed ? JNI_ABORT : 0);
  if (__nvn1) (*env)->ReleasePrimitiveArrayCritical(env, vn1, __nvn1, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__njpvt) (*env)->ReleasePrimitiveArrayCritical(env, jpvt, __njpvt, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr0_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr0K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; float *__nh = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nz = NULL; float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqr0_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr1_)(int *n, float *h, int *ldh, float *sr1, float *si1, float *sr2, float *si2, float *v);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray h, jint offseth, jint ldh, jfloat sr1, jfloat si1, jfloat sr2, jfloat si2, jfloatArray v, jint offsetv) {
  jboolean failed = FALSE;
  float *__nh = NULL; float *__nv = NULL;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  slaqr1_(&n, __nh + offseth, &ldh, &sr1, &si1, &sr2, &si2, __nv + offsetv);
done:
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr2_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, int *ns, int *nd, float *sr, float *si, float *v, int *ldv, int *nh, float *t, int *ldt, int *nv, float *wv, int *ldwv, float *work, int *lwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr2K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray v, jint offsetv, jint ldv, jint nh, jfloatArray t, jint offsett, jint ldt, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jfloatArray work, jint offsetwork, jint lwork) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __nns = 0; int __nnd = 0; float *__nh = NULL; float *__nz = NULL; float *__nsr = NULL; float *__nsi = NULL; float *__nv = NULL; float *__nt = NULL; float *__nwv = NULL; float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqr2_(&__nwantt, &__nwantz, &n, &ktop, &kbot, &nw, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &ldv, &nh, __nt + offsett, &ldt, &nv, __nwv + offsetwv, &ldwv, __nwork + offsetwork, &lwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr3_)(int *wantt, int *wantz, int *n, int *ktop, int *kbot, int *nw, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, int *ns, int *nd, float *sr, float *si, float *v, int *ldv, int *nh, float *t, int *ldt, int *nv, float *wv, int *ldwv, float *work, int *lwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr3K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ktop, jint kbot, jint nw, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jobject ns, jobject nd, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray v, jint offsetv, jint ldv, jint nh, jfloatArray t, jint offsett, jint ldt, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jfloatArray work, jint offsetwork, jint lwork) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __nns = 0; int __nnd = 0; float *__nh = NULL; float *__nz = NULL; float *__nsr = NULL; float *__nsi = NULL; float *__nv = NULL; float *__nt = NULL; float *__nwv = NULL; float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __nns = (*env)->GetIntField(env, ns, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqr3_(&__nwantt, &__nwantz, &n, &ktop, &kbot, &nw, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, &__nns, &__nnd, __nsr + offsetsr, __nsi + offsetsi, __nv + offsetv, &ldv, &nh, __nt + offsett, &ldt, &nv, __nwv + offsetwv, &ldwv, __nwork + offsetwork, &lwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, ns, intW_val_fieldID, __nns);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr4_)(int *wantt, int *wantz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, int *iloz, int *ihiz, float *z, int *ldz, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr4K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint n, jint ilo, jint ihi, jfloatArray h, jint offseth, jint ldh, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; int __ninfo = 0; float *__nh = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nz = NULL; float *__nwork = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqr4_(&__nwantt, &__nwantz, &n, &ilo, &ihi, __nh + offseth, &ldh, __nwr + offsetwr, __nwi + offsetwi, &iloz, &ihiz, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqr5_)(int *wantt, int *wantz, int *kacc22, int *n, int *ktop, int *kbot, int *nshfts, float *sr, float *si, float *h, int *ldh, int *iloz, int *ihiz, float *z, int *ldz, float *v, int *ldv, float *u, int *ldu, int *nv, float *wv, int *ldwv, int *nh, float *wh, int *ldwh);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqr5K(JNIEnv *env, UNUSED jobject obj, jboolean wantt, jboolean wantz, jint kacc22, jint n, jint ktop, jint kbot, jint nshfts, jfloatArray sr, jint offsetsr, jfloatArray si, jint offsetsi, jfloatArray h, jint offseth, jint ldh, jint iloz, jint ihiz, jfloatArray z, jint offsetz, jint ldz, jfloatArray v, jint offsetv, jint ldv, jfloatArray u, jint offsetu, jint ldu, jint nv, jfloatArray wv, jint offsetwv, jint ldwv, jint nh, jfloatArray wh, jint offsetwh, jint ldwh) {
  jboolean failed = FALSE;
  int __nwantt; int __nwantz; float *__nsr = NULL; float *__nsi = NULL; float *__nh = NULL; float *__nz = NULL; float *__nv = NULL; float *__nu = NULL; float *__nwv = NULL; float *__nwh = NULL;
  __nwantt = wantt;
  __nwantz = wantz;
  if (!(__nsr = (*env)->GetPrimitiveArrayCritical(env, sr, NULL))) goto fail;
  if (!(__nsi = (*env)->GetPrimitiveArrayCritical(env, si, NULL))) goto fail;
  if (!(__nh = (*env)->GetPrimitiveArrayCritical(env, h, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nwv = (*env)->GetPrimitiveArrayCritical(env, wv, NULL))) goto fail;
  if (!(__nwh = (*env)->GetPrimitiveArrayCritical(env, wh, NULL))) goto fail;
  slaqr5_(&__nwantt, &__nwantz, &kacc22, &n, &ktop, &kbot, &nshfts, __nsr + offsetsr, __nsi + offsetsi, __nh + offseth, &ldh, &iloz, &ihiz, __nz + offsetz, &ldz, __nv + offsetv, &ldv, __nu + offsetu, &ldu, &nv, __nwv + offsetwv, &ldwv, &nh, __nwh + offsetwh, &ldwh);
done:
  if (__nwh) (*env)->ReleasePrimitiveArrayCritical(env, wh, __nwh, failed ? JNI_ABORT : 0);
  if (__nwv) (*env)->ReleasePrimitiveArrayCritical(env, wv, __nwv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nh) (*env)->ReleasePrimitiveArrayCritical(env, h, __nh, failed ? JNI_ABORT : 0);
  if (__nsi) (*env)->ReleasePrimitiveArrayCritical(env, si, __nsi, failed ? JNI_ABORT : 0);
  if (__nsr) (*env)->ReleasePrimitiveArrayCritical(env, sr, __nsr, failed ? JNI_ABORT : 0);
  if (!failed) wantz = __nwantz;
  if (!failed) wantt = __nwantt;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqsb_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *s, float *scond, float *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqsbK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float *__nab = NULL; float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slaqsb_(__nuplo, &n, &kd, __nab + offsetab, &ldab, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqsp_)(const char *uplo, int *n, float *ap, float *s, float *scond, float *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqspK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float *__nap = NULL; float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slaqsp_(__nuplo, &n, __nap + offsetap, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqsy_)(const char *uplo, int *n, float *a, int *lda, float *s, float *scond, float *amax, char *equed);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqsyK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jfloat scond, jfloat amax, jobject equed) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float *__na = NULL; float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slaqsy_(__nuplo, &n, __na + offseta, &lda, __ns + offsets, &scond, &amax, __nequed);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaqtr_)(int *ltran, int *lreal, int *n, float *t, int *ldt, float *b, float *w, float *scale, float *x, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaqtrK(JNIEnv *env, UNUSED jobject obj, jboolean ltran, jboolean lreal, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray b, jint offsetb, jfloat w, jobject scale, jfloatArray x, jint offsetx, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __nltran; int __nlreal; float __nscale = 0; int __ninfo = 0; float *__nt = NULL; float *__nb = NULL; float *__nx = NULL; float *__nwork = NULL;
  __nltran = ltran;
  __nlreal = lreal;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slaqtr_(&__nltran, &__nlreal, &n, __nt + offsett, &ldt, __nb + offsetb, &w, &__nscale, __nx + offsetx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (!failed) lreal = __nlreal;
  if (!failed) ltran = __nltran;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slar1v_)(int *n, int *b1, int *bn, float *lambda, float *d, float *l, float *ld, float *lld, float *pivmin, float *gaptol, float *z, int *wantnc, int *negcnt, float *ztz, float *mingma, int *r, int *isuppz, float *nrminv, float *resid, float *rqcorr, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slar1vK(JNIEnv *env, UNUSED jobject obj, jint n, jint b1, jint bn, jfloat lambda, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloatArray ld, jint offsetld, jfloatArray lld, jint offsetlld, jfloat pivmin, jfloat gaptol, jfloatArray z, jint offsetz, jboolean wantnc, jobject negcnt, jobject ztz, jobject mingma, jobject r, jintArray isuppz, jint offsetisuppz, jobject nrminv, jobject resid, jobject rqcorr, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  int __nwantnc; int __nnegcnt = 0; float __nztz = 0; float __nmingma = 0; int __nr = 0; float __nnrminv = 0; float __nresid = 0; float __nrqcorr = 0; float *__nd = NULL; float *__nl = NULL; float *__nld = NULL; float *__nlld = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL;
  __nwantnc = wantnc;
  __nnegcnt = (*env)->GetIntField(env, negcnt, intW_val_fieldID);
  __nztz = (*env)->GetFloatField(env, ztz, floatW_val_fieldID);
  __nmingma = (*env)->GetFloatField(env, mingma, floatW_val_fieldID);
  __nr = (*env)->GetIntField(env, r, intW_val_fieldID);
  __nnrminv = (*env)->GetFloatField(env, nrminv, floatW_val_fieldID);
  __nresid = (*env)->GetFloatField(env, resid, floatW_val_fieldID);
  __nrqcorr = (*env)->GetFloatField(env, rqcorr, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slar1v_(&n, &b1, &bn, &lambda, __nd + offsetd, __nl + offsetl, __nld + offsetld, __nlld + offsetlld, &pivmin, &gaptol, __nz + offsetz, &__nwantnc, &__nnegcnt, &__nztz, &__nmingma, &__nr, __nisuppz + offsetisuppz, &__nnrminv, &__nresid, &__nrqcorr, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, rqcorr, floatW_val_fieldID, __nrqcorr);
  if (!failed) (*env)->SetFloatField(env, resid, floatW_val_fieldID, __nresid);
  if (!failed) (*env)->SetFloatField(env, nrminv, floatW_val_fieldID, __nnrminv);
  if (!failed) (*env)->SetIntField(env, r, intW_val_fieldID, __nr);
  if (!failed) (*env)->SetFloatField(env, mingma, floatW_val_fieldID, __nmingma);
  if (!failed) (*env)->SetFloatField(env, ztz, floatW_val_fieldID, __nztz);
  if (!failed) (*env)->SetIntField(env, negcnt, intW_val_fieldID, __nnegcnt);
  if (!failed) wantnc = __nwantnc;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slar2v_)(int *n, float *x, float *y, float *z, int *incx, float *c, float *s, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slar2vK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jfloatArray y, jint offsety, jfloatArray z, jint offsetz, jint incx, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jint incc) {
  jboolean failed = FALSE;
  float *__nx = NULL; float *__ny = NULL; float *__nz = NULL; float *__nc = NULL; float *__ns = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slar2v_(&n, __nx + offsetx, __ny + offsety, __nz + offsetz, &incx, __nc + offsetc, __ns + offsets, &incc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarf_)(const char *side, int *m, int *n, float *v, int *incv, float *tau, float *c, int *Ldc, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; float *__nv = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarf_(__nside, &m, &n, __nv + offsetv, &incv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarfb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, float *v, int *ldv, float *t, int *ldt, float *c, int *Ldc, float *work, int *ldwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray t, jint offsett, jint ldt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint ldwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; const char *__ndirect = NULL; const char *__nstorev = NULL; float *__nv = NULL; float *__nt = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarfb_(__nside, __ntrans, __ndirect, __nstorev, &m, &n, &k, __nv + offsetv, &ldv, __nt + offsett, &ldt, __nc + offsetc, &Ldc, __nwork + offsetwork, &ldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarfg_)(int *n, float *alpha, float *x, int *incx, float *tau);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfgK(JNIEnv *env, UNUSED jobject obj, jint n, jobject alpha, jfloatArray x, jint offsetx, jint incx, jobject tau) {
  jboolean failed = FALSE;
  float __nalpha = 0; float __ntau = 0; float *__nx = NULL;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slarfg_(&n, &__nalpha, __nx + offsetx, &incx, &__ntau);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (!failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarft_)(const char *direct, const char *storev, int *n, int *k, float *v, int *ldv, float *tau, float *t, int *ldt);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarftK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt) {
  jboolean failed = FALSE;
  const char *__ndirect = NULL; const char *__nstorev = NULL; float *__nv = NULL; float *__ntau = NULL; float *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  slarft_(__ndirect, __nstorev, &n, &k, __nv + offsetv, &ldv, __ntau + offsettau, __nt + offsett, &ldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarfx_)(const char *side, int *m, int *n, float *v, float *tau, float *c, int *Ldc, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarfxK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; float *__nv = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarfx_(__nside, &m, &n, __nv + offsetv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slargv_)(int *n, float *x, int *incx, float *y, int *incy, float *c, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slargvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jfloatArray c, jint offsetc, jint incc) {
  jboolean failed = FALSE;
  float *__nx = NULL; float *__ny = NULL; float *__nc = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  slargv_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, __nc + offsetc, &incc);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarnv_)(int *idist, int *iseed, int *n, float *x);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarnvK(JNIEnv *env, UNUSED jobject obj, jint idist, jintArray iseed, jint offsetiseed, jint n, jfloatArray x, jint offsetx) {
  jboolean failed = FALSE;
  int *__niseed = NULL; float *__nx = NULL;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slarnv_(&idist, __niseed + offsetiseed, &n, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarra_)(int *n, float *d, float *e, float *e2, float *spltol, float *tnrm, int *nsplit, int *isplit, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarraK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat spltol, jfloat tnrm, jobject nsplit, jintArray isplit, jint offsetisplit, jobject info) {
  jboolean failed = FALSE;
  int __nnsplit = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__ne2 = NULL; int *__nisplit = NULL;
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  slarra_(&n, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &spltol, &tnrm, &__nnsplit, __nisplit + offsetisplit, &__ninfo);
done:
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrb_)(int *n, float *d, float *lld, int *ifirst, int *ilast, float *rtol1, float *rtol2, int *offset, float *w, float *wgap, float *werr, float *work, int *iwork, float *pivmin, float *spdiam, int *twist, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrbK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray lld, jint offsetlld, jint ifirst, jint ilast, jfloat rtol1, jfloat rtol2, jint offset, jfloatArray w, jint offsetw, jfloatArray wgap, jint offsetwgap, jfloatArray werr, jint offsetwerr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jfloat pivmin, jfloat spdiam, jint twist, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__nlld = NULL; float *__nw = NULL; float *__nwgap = NULL; float *__nwerr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nlld = (*env)->GetPrimitiveArrayCritical(env, lld, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slarrb_(&n, __nd + offsetd, __nlld + offsetlld, &ifirst, &ilast, &rtol1, &rtol2, &offset, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &pivmin, &spdiam, &twist, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nlld) (*env)->ReleasePrimitiveArrayCritical(env, lld, __nlld, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrc_)(const char *jobt, int *n, float *vl, float *vu, float *d, float *e, float *pivmin, int *eigcnt, int *lcnt, int *rcnt, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrcK(JNIEnv *env, UNUSED jobject obj, jstring jobt, jint n, jfloat vl, jfloat vu, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat pivmin, jobject eigcnt, jobject lcnt, jobject rcnt, jobject info) {
  jboolean failed = FALSE;
  const char *__njobt = NULL; int __neigcnt = 0; int __nlcnt = 0; int __nrcnt = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL;
  if (!(__njobt = (*env)->GetStringUTFChars(env, jobt, NULL))) goto fail;
  __neigcnt = (*env)->GetIntField(env, eigcnt, intW_val_fieldID);
  __nlcnt = (*env)->GetIntField(env, lcnt, intW_val_fieldID);
  __nrcnt = (*env)->GetIntField(env, rcnt, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  slarrc_(__njobt, &n, &vl, &vu, __nd + offsetd, __ne + offsete, &pivmin, &__neigcnt, &__nlcnt, &__nrcnt, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, rcnt, intW_val_fieldID, __nrcnt);
  if (!failed) (*env)->SetIntField(env, lcnt, intW_val_fieldID, __nlcnt);
  if (!failed) (*env)->SetIntField(env, eigcnt, intW_val_fieldID, __neigcnt);
  if (__njobt) (*env)->ReleaseStringUTFChars(env, jobt, __njobt);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrd_)(const char *range, const char *order, int *n, float *vl, float *vu, int *il, int *iu, float *gers, float *reltol, float *d, float *e, float *e2, float *pivmin, int *nsplit, int *isplit, int *m, float *w, float *werr, float *wl, float *wu, int *iblock, int *indexw, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrdK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jfloat vl, jfloat vu, jint il, jint iu, jfloatArray gers, jint offsetgers, jfloat reltol, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat pivmin, jint nsplit, jintArray isplit, jint offsetisplit, jobject m, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jobject wl, jobject wu, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; const char *__norder = NULL; int __nm = 0; float __nwl = 0; float __nwu = 0; int __ninfo = 0; float *__ngers = NULL; float *__nd = NULL; float *__ne = NULL; float *__ne2 = NULL; int *__nisplit = NULL; float *__nw = NULL; float *__nwerr = NULL; int *__niblock = NULL; int *__nindexw = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nwl = (*env)->GetFloatField(env, wl, floatW_val_fieldID);
  __nwu = (*env)->GetFloatField(env, wu, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slarrd_(__nrange, __norder, &n, &vl, &vu, &il, &iu, __ngers + offsetgers, &reltol, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &pivmin, &nsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, &__nwl, &__nwu, __niblock + offsetiblock, __nindexw + offsetindexw, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, wu, floatW_val_fieldID, __nwu);
  if (!failed) (*env)->SetFloatField(env, wl, floatW_val_fieldID, __nwl);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarre_)(const char *range, int *n, float *vl, float *vu, int *il, int *iu, float *d, float *e, float *e2, float *rtol1, float *rtol2, float *spltol, int *nsplit, int *isplit, int *m, float *w, float *werr, float *wgap, int *iblock, int *indexw, float *gers, float *pivmin, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarreK(JNIEnv *env, UNUSED jobject obj, jstring range, jint n, jobject vl, jobject vu, jint il, jint iu, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray e2, jint offsete2, jfloat rtol1, jfloat rtol2, jfloat spltol, jobject nsplit, jintArray isplit, jint offsetisplit, jobject m, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray gers, jint offsetgers, jobject pivmin, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; float __nvl = 0; float __nvu = 0; int __nnsplit = 0; int __nm = 0; float __npivmin = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__ne2 = NULL; int *__nisplit = NULL; float *__nw = NULL; float *__nwerr = NULL; float *__nwgap = NULL; int *__niblock = NULL; int *__nindexw = NULL; float *__ngers = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nvl = (*env)->GetFloatField(env, vl, floatW_val_fieldID);
  __nvu = (*env)->GetFloatField(env, vu, floatW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npivmin = (*env)->GetFloatField(env, pivmin, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slarre_(__nrange, &n, &__nvl, &__nvu, &il, &iu, __nd + offsetd, __ne + offsete, __ne2 + offsete2, &rtol1, &rtol2, &spltol, &__nnsplit, __nisplit + offsetisplit, &__nm, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, &__npivmin, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, pivmin, floatW_val_fieldID, __npivmin);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!failed) (*env)->SetFloatField(env, vu, floatW_val_fieldID, __nvu);
  if (!failed) (*env)->SetFloatField(env, vl, floatW_val_fieldID, __nvl);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrf_)(int *n, float *d, float *l, float *ld, int *clstrt, int *clend, float *w, float *wgap, float *werr, float *spdiam, float *clgapl, float *clgapr, float *pivmin, float *sigma, float *dplus, float *lplus, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloatArray ld, jint offsetld, jint clstrt, jint clend, jfloatArray w, jint offsetw, jfloatArray wgap, jint offsetwgap, jfloatArray werr, jint offsetwerr, jfloat spdiam, jfloat clgapl, jfloat clgapr, jfloat pivmin, jobject sigma, jfloatArray dplus, jint offsetdplus, jfloatArray lplus, jint offsetlplus, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  float __nsigma = 0; int __ninfo = 0; float *__nd = NULL; float *__nl = NULL; float *__nld = NULL; float *__nw = NULL; float *__nwgap = NULL; float *__nwerr = NULL; float *__ndplus = NULL; float *__nlplus = NULL; float *__nwork = NULL;
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nld = (*env)->GetPrimitiveArrayCritical(env, ld, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__ndplus = (*env)->GetPrimitiveArrayCritical(env, dplus, NULL))) goto fail;
  if (!(__nlplus = (*env)->GetPrimitiveArrayCritical(env, lplus, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarrf_(&n, __nd + offsetd, __nl + offsetl, __nld + offsetld, &clstrt, &clend, __nw + offsetw, __nwgap + offsetwgap, __nwerr + offsetwerr, &spdiam, &clgapl, &clgapr, &pivmin, &__nsigma, __ndplus + offsetdplus, __nlplus + offsetlplus, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nlplus) (*env)->ReleasePrimitiveArrayCritical(env, lplus, __nlplus, failed ? JNI_ABORT : 0);
  if (__ndplus) (*env)->ReleasePrimitiveArrayCritical(env, dplus, __ndplus, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nld) (*env)->ReleasePrimitiveArrayCritical(env, ld, __nld, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrj_)(int *n, float *d, float *e2, int *ifirst, int *ilast, float *rtol, int *offset, float *w, float *werr, float *work, int *iwork, float *pivmin, float *spdiam, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrjK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e2, jint offsete2, jint ifirst, jint ilast, jfloat rtol, jint offset, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jfloat pivmin, jfloat spdiam, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne2 = NULL; float *__nw = NULL; float *__nwerr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slarrj_(&n, __nd + offsetd, __ne2 + offsete2, &ifirst, &ilast, &rtol, &offset, __nw + offsetw, __nwerr + offsetwerr, __nwork + offsetwork, __niwork + offsetiwork, &pivmin, &spdiam, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrk_)(int *n, int *iw, float *gl, float *gu, float *d, float *e2, float *pivmin, float *reltol, float *w, float *werr, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrkK(JNIEnv *env, UNUSED jobject obj, jint n, jint iw, jfloat gl, jfloat gu, jfloatArray d, jint offsetd, jfloatArray e2, jint offsete2, jfloat pivmin, jfloat reltol, jobject w, jobject werr, jobject info) {
  jboolean failed = FALSE;
  float __nw = 0; float __nwerr = 0; int __ninfo = 0; float *__nd = NULL; float *__ne2 = NULL;
  __nw = (*env)->GetFloatField(env, w, floatW_val_fieldID);
  __nwerr = (*env)->GetFloatField(env, werr, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne2 = (*env)->GetPrimitiveArrayCritical(env, e2, NULL))) goto fail;
  slarrk_(&n, &iw, &gl, &gu, __nd + offsetd, __ne2 + offsete2, &pivmin, &reltol, &__nw, &__nwerr, &__ninfo);
done:
  if (__ne2) (*env)->ReleasePrimitiveArrayCritical(env, e2, __ne2, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, werr, floatW_val_fieldID, __nwerr);
  if (!failed) (*env)->SetFloatField(env, w, floatW_val_fieldID, __nw);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrr_)(int *n, float *d, float *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrrK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  slarrr_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarrv_)(int *n, float *vl, float *vu, float *d, float *l, float *pivmin, int *isplit, int *m, int *dol, int *dou, float *minrgp, float *rtol1, float *rtol2, float *w, float *werr, float *wgap, int *iblock, int *indexw, float *gers, float *z, int *ldz, int *isuppz, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarrvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloat vl, jfloat vu, jfloatArray d, jint offsetd, jfloatArray l, jint offsetl, jfloat pivmin, jintArray isplit, jint offsetisplit, jint m, jint dol, jint dou, jfloat minrgp, jobject rtol1, jobject rtol2, jfloatArray w, jint offsetw, jfloatArray werr, jint offsetwerr, jfloatArray wgap, jint offsetwgap, jintArray iblock, jint offsetiblock, jintArray indexw, jint offsetindexw, jfloatArray gers, jint offsetgers, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  float __nrtol1 = 0; float __nrtol2 = 0; int __ninfo = 0; float *__nd = NULL; float *__nl = NULL; int *__nisplit = NULL; float *__nw = NULL; float *__nwerr = NULL; float *__nwgap = NULL; int *__niblock = NULL; int *__nindexw = NULL; float *__ngers = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nrtol1 = (*env)->GetFloatField(env, rtol1, floatW_val_fieldID);
  __nrtol2 = (*env)->GetFloatField(env, rtol2, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nl = (*env)->GetPrimitiveArrayCritical(env, l, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwerr = (*env)->GetPrimitiveArrayCritical(env, werr, NULL))) goto fail;
  if (!(__nwgap = (*env)->GetPrimitiveArrayCritical(env, wgap, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nindexw = (*env)->GetPrimitiveArrayCritical(env, indexw, NULL))) goto fail;
  if (!(__ngers = (*env)->GetPrimitiveArrayCritical(env, gers, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slarrv_(&n, &vl, &vu, __nd + offsetd, __nl + offsetl, &pivmin, __nisplit + offsetisplit, &m, &dol, &dou, &minrgp, &__nrtol1, &__nrtol2, __nw + offsetw, __nwerr + offsetwerr, __nwgap + offsetwgap, __niblock + offsetiblock, __nindexw + offsetindexw, __ngers + offsetgers, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ngers) (*env)->ReleasePrimitiveArrayCritical(env, gers, __ngers, failed ? JNI_ABORT : 0);
  if (__nindexw) (*env)->ReleasePrimitiveArrayCritical(env, indexw, __nindexw, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nwgap) (*env)->ReleasePrimitiveArrayCritical(env, wgap, __nwgap, failed ? JNI_ABORT : 0);
  if (__nwerr) (*env)->ReleasePrimitiveArrayCritical(env, werr, __nwerr, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__nl) (*env)->ReleasePrimitiveArrayCritical(env, l, __nl, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rtol2, floatW_val_fieldID, __nrtol2);
  if (!failed) (*env)->SetFloatField(env, rtol1, floatW_val_fieldID, __nrtol1);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slartg_)(float *f, float *g, float *cs, float *sn, float *r);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slartgK(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jobject cs, jobject sn, jobject r) {
  jboolean failed = FALSE;
  float __ncs = 0; float __nsn = 0; float __nr = 0;
  __ncs = (*env)->GetFloatField(env, cs, floatW_val_fieldID);
  __nsn = (*env)->GetFloatField(env, sn, floatW_val_fieldID);
  __nr = (*env)->GetFloatField(env, r, floatW_val_fieldID);
  slartg_(&f, &g, &__ncs, &__nsn, &__nr);
done:
  if (!failed) (*env)->SetFloatField(env, r, floatW_val_fieldID, __nr);
  if (!failed) (*env)->SetFloatField(env, sn, floatW_val_fieldID, __nsn);
  if (!failed) (*env)->SetFloatField(env, cs, floatW_val_fieldID, __ncs);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slartv_)(int *n, float *x, int *incx, float *y, int *incy, float *c, float *s, int *incc);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slartvK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jfloatArray y, jint offsety, jint incy, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jint incc) {
  jboolean failed = FALSE;
  float *__nx = NULL; float *__ny = NULL; float *__nc = NULL; float *__ns = NULL;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ny = (*env)->GetPrimitiveArrayCritical(env, y, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  slartv_(&n, __nx + offsetx, &incx, __ny + offsety, &incy, __nc + offsetc, __ns + offsets, &incc);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ny) (*env)->ReleasePrimitiveArrayCritical(env, y, __ny, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaruv_)(int *iseed, int *n, float *x);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaruvK(JNIEnv *env, UNUSED jobject obj, jintArray iseed, jint offsetiseed, jint n, jfloatArray x, jint offsetx) {
  jboolean failed = FALSE;
  int *__niseed = NULL; float *__nx = NULL;
  if (!(__niseed = (*env)->GetPrimitiveArrayCritical(env, iseed, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slaruv_(__niseed + offsetiseed, &n, __nx + offsetx);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__niseed) (*env)->ReleasePrimitiveArrayCritical(env, iseed, __niseed, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarz_)(const char *side, int *m, int *n, int *l, float *v, int *incv, float *tau, float *c, int *Ldc, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarzK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jint l, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; float *__nv = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarz_(__nside, &m, &n, &l, __nv + offsetv, &incv, &tau, __nc + offsetc, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarzb_)(const char *side, const char *trans, const char *direct, const char *storev, int *m, int *n, int *k, int *l, float *v, int *ldv, float *t, int *ldt, float *c, int *Ldc, float *work, int *ldwork);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarzbK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jstring direct, jstring storev, jint m, jint n, jint k, jint l, jfloatArray v, jint offsetv, jint ldv, jfloatArray t, jint offsett, jint ldt, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint ldwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; const char *__ndirect = NULL; const char *__nstorev = NULL; float *__nv = NULL; float *__nt = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slarzb_(__nside, __ntrans, __ndirect, __nstorev, &m, &n, &k, &l, __nv + offsetv, &ldv, __nt + offsett, &ldt, __nc + offsetc, &Ldc, __nwork + offsetwork, &ldwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slarzt_)(const char *direct, const char *storev, int *n, int *k, float *v, int *ldv, float *tau, float *t, int *ldt);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slarztK(JNIEnv *env, UNUSED jobject obj, jstring direct, jstring storev, jint n, jint k, jfloatArray v, jint offsetv, jint ldv, jfloatArray tau, jint offsettau, jfloatArray t, jint offsett, jint ldt) {
  jboolean failed = FALSE;
  const char *__ndirect = NULL; const char *__nstorev = NULL; float *__nv = NULL; float *__ntau = NULL; float *__nt = NULL;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nstorev = (*env)->GetStringUTFChars(env, storev, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  slarzt_(__ndirect, __nstorev, &n, &k, __nv + offsetv, &ldv, __ntau + offsettau, __nt + offsett, &ldt);
done:
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nstorev) (*env)->ReleaseStringUTFChars(env, storev, __nstorev);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slas2_)(float *f, float *g, float *h, float *ssmin, float *ssmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slas2K(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jfloat h, jobject ssmin, jobject ssmax) {
  jboolean failed = FALSE;
  float __nssmin = 0; float __nssmax = 0;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  __nssmax = (*env)->GetFloatField(env, ssmax, floatW_val_fieldID);
  slas2_(&f, &g, &h, &__nssmin, &__nssmax);
done:
  if (!failed) (*env)->SetFloatField(env, ssmax, floatW_val_fieldID, __nssmax);
  if (!failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slascl_)(const char *type, int *kl, int *ku, float *cfrom, float *cto, int *m, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasclK(JNIEnv *env, UNUSED jobject obj, jstring type, jint kl, jint ku, jfloat cfrom, jfloat cto, jint m, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__ntype = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__ntype = (*env)->GetStringUTFChars(env, type, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slascl_(__ntype, &kl, &ku, &cfrom, &cto, &m, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntype) (*env)->ReleaseStringUTFChars(env, type, __ntype);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd0_)(int *n, int *sqre, float *d, float *e, float *u, int *ldu, float *vt, int *ldvt, int *smlsiz, int *iwork, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd0K(JNIEnv *env, UNUSED jobject obj, jint n, jint sqre, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jint smlsiz, jintArray iwork, jint offsetiwork, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nu = NULL; float *__nvt = NULL; int *__niwork = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasd0_(&n, &sqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, &smlsiz, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd1_)(int *nl, int *nr, int *sqre, float *d, float *alpha, float *beta, float *u, int *ldu, float *vt, int *ldvt, int *idxq, int *iwork, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd1K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jfloatArray d, jint offsetd, jobject alpha, jobject beta, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jintArray idxq, jint offsetidxq, jintArray iwork, jint offsetiwork, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  float __nalpha = 0; float __nbeta = 0; int __ninfo = 0; float *__nd = NULL; float *__nu = NULL; float *__nvt = NULL; int *__nidxq = NULL; int *__niwork = NULL; float *__nwork = NULL;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __nbeta = (*env)->GetFloatField(env, beta, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasd1_(&nl, &nr, &sqre, __nd + offsetd, &__nalpha, &__nbeta, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __nidxq + offsetidxq, __niwork + offsetiwork, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, beta, floatW_val_fieldID, __nbeta);
  if (!failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd2_)(int *nl, int *nr, int *sqre, int *k, float *d, float *z, float *alpha, float *beta, float *u, int *ldu, float *vt, int *ldvt, float *dsigma, float *u2, int *ldu2, float *vt2, int *ldvt2, int *idxp, int *idx, int *idxc, int *idxq, int *coltyp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd2K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jobject k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloat alpha, jfloat beta, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray dsigma, jint offsetdsigma, jfloatArray u2, jint offsetu2, jint ldu2, jfloatArray vt2, jint offsetvt2, jint ldvt2, jintArray idxp, jint offsetidxp, jintArray idx, jint offsetidx, jintArray idxc, jint offsetidxc, jintArray idxq, jint offsetidxq, jintArray coltyp, jint offsetcoltyp, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; int __ninfo = 0; float *__nd = NULL; float *__nz = NULL; float *__nu = NULL; float *__nvt = NULL; float *__ndsigma = NULL; float *__nu2 = NULL; float *__nvt2 = NULL; int *__nidxp = NULL; int *__nidx = NULL; int *__nidxc = NULL; int *__nidxq = NULL; int *__ncoltyp = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) goto fail;
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) goto fail;
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) goto fail;
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) goto fail;
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__ncoltyp = (*env)->GetPrimitiveArrayCritical(env, coltyp, NULL))) goto fail;
  slasd2_(&nl, &nr, &sqre, &__nk, __nd + offsetd, __nz + offsetz, &alpha, &beta, __nu + offsetu, &ldu, __nvt + offsetvt, &ldvt, __ndsigma + offsetdsigma, __nu2 + offsetu2, &ldu2, __nvt2 + offsetvt2, &ldvt2, __nidxp + offsetidxp, __nidx + offsetidx, __nidxc + offsetidxc, __nidxq + offsetidxq, __ncoltyp + offsetcoltyp, &__ninfo);
done:
  if (__ncoltyp) (*env)->ReleasePrimitiveArrayCritical(env, coltyp, __ncoltyp, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd3_)(int *nl, int *nr, int *sqre, int *k, float *d, float *q, int *ldq, float *dsigma, float *u, int *ldu, float *u2, int *ldu2, float *vt, int *ldvt, float *vt2, int *ldvt2, int *idxc, int *ctot, float *z, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd3K(JNIEnv *env, UNUSED jobject obj, jint nl, jint nr, jint sqre, jint k, jfloatArray d, jint offsetd, jfloatArray q, jint offsetq, jint ldq, jfloatArray dsigma, jint offsetdsigma, jfloatArray u, jint offsetu, jint ldu, jfloatArray u2, jint offsetu2, jint ldu2, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray vt2, jint offsetvt2, jint ldvt2, jintArray idxc, jint offsetidxc, jintArray ctot, jint offsetctot, jfloatArray z, jint offsetz, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__nq = NULL; float *__ndsigma = NULL; float *__nu = NULL; float *__nu2 = NULL; float *__nvt = NULL; float *__nvt2 = NULL; int *__nidxc = NULL; int *__nctot = NULL; float *__nz = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nu2 = (*env)->GetPrimitiveArrayCritical(env, u2, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nvt2 = (*env)->GetPrimitiveArrayCritical(env, vt2, NULL))) goto fail;
  if (!(__nidxc = (*env)->GetPrimitiveArrayCritical(env, idxc, NULL))) goto fail;
  if (!(__nctot = (*env)->GetPrimitiveArrayCritical(env, ctot, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasd3_(&nl, &nr, &sqre, &k, __nd + offsetd, __nq + offsetq, &ldq, __ndsigma + offsetdsigma, __nu + offsetu, &ldu, __nu2 + offsetu2, &ldu2, __nvt + offsetvt, &ldvt, __nvt2 + offsetvt2, &ldvt2, __nidxc + offsetidxc, __nctot + offsetctot, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nctot) (*env)->ReleasePrimitiveArrayCritical(env, ctot, __nctot, failed ? JNI_ABORT : 0);
  if (__nidxc) (*env)->ReleasePrimitiveArrayCritical(env, idxc, __nidxc, failed ? JNI_ABORT : 0);
  if (__nvt2) (*env)->ReleasePrimitiveArrayCritical(env, vt2, __nvt2, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu2) (*env)->ReleasePrimitiveArrayCritical(env, u2, __nu2, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd4_)(int *n, int *i, float *d, float *z, float *delta, float *rho, float *sigma, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd4K(JNIEnv *env, UNUSED jobject obj, jint n, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject sigma, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  float __nsigma = 0; int __ninfo = 0; float *__nd = NULL; float *__nz = NULL; float *__ndelta = NULL; float *__nwork = NULL;
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasd4_(&n, &i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__nsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd5_)(int *i, float *d, float *z, float *delta, float *rho, float *dsigma, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd5K(JNIEnv *env, UNUSED jobject obj, jint i, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray delta, jint offsetdelta, jfloat rho, jobject dsigma, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  float __ndsigma = 0; float *__nd = NULL; float *__nz = NULL; float *__ndelta = NULL; float *__nwork = NULL;
  __ndsigma = (*env)->GetFloatField(env, dsigma, floatW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndelta = (*env)->GetPrimitiveArrayCritical(env, delta, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasd5_(&i, __nd + offsetd, __nz + offsetz, __ndelta + offsetdelta, &rho, &__ndsigma, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndelta) (*env)->ReleasePrimitiveArrayCritical(env, delta, __ndelta, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, dsigma, floatW_val_fieldID, __ndsigma);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd6_)(int *icompq, int *nl, int *nr, int *sqre, float *d, float *vf, float *vl, float *alpha, float *beta, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *poles, float *difl, float *difr, float *z, int *k, float *c, float *s, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd6K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jfloatArray d, jint offsetd, jfloatArray vf, jint offsetvf, jfloatArray vl, jint offsetvl, jobject alpha, jobject beta, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jfloatArray poles, jint offsetpoles, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jobject k, jobject c, jobject s, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  float __nalpha = 0; float __nbeta = 0; int __ngivptr = 0; int __nk = 0; float __nc = 0; float __ns = 0; int __ninfo = 0; float *__nd = NULL; float *__nvf = NULL; float *__nvl = NULL; int *__nidxq = NULL; int *__nperm = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL; float *__npoles = NULL; float *__ndifl = NULL; float *__ndifr = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nalpha = (*env)->GetFloatField(env, alpha, floatW_val_fieldID);
  __nbeta = (*env)->GetFloatField(env, beta, floatW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slasd6_(&icompq, &nl, &nr, &sqre, __nd + offsetd, __nvf + offsetvf, __nvl + offsetvl, &__nalpha, &__nbeta, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, __npoles + offsetpoles, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, &__nk, &__nc, &__ns, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetFloatField(env, beta, floatW_val_fieldID, __nbeta);
  if (!failed) (*env)->SetFloatField(env, alpha, floatW_val_fieldID, __nalpha);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd7_)(int *icompq, int *nl, int *nr, int *sqre, int *k, float *d, float *z, float *zw, float *vf, float *vfw, float *vl, float *vlw, float *alpha, float *beta, float *dsigma, int *idx, int *idxp, int *idxq, int *perm, int *givptr, int *givcol, int *ldgcol, float *givnum, int *ldgnum, float *c, float *s, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd7K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint nl, jint nr, jint sqre, jobject k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray zw, jint offsetzw, jfloatArray vf, jint offsetvf, jfloatArray vfw, jint offsetvfw, jfloatArray vl, jint offsetvl, jfloatArray vlw, jint offsetvlw, jfloat alpha, jfloat beta, jfloatArray dsigma, jint offsetdsigma, jintArray idx, jint offsetidx, jintArray idxp, jint offsetidxp, jintArray idxq, jint offsetidxq, jintArray perm, jint offsetperm, jobject givptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jfloatArray givnum, jint offsetgivnum, jint ldgnum, jobject c, jobject s, jobject info) {
  jboolean failed = FALSE;
  int __nk = 0; int __ngivptr = 0; float __nc = 0; float __ns = 0; int __ninfo = 0; float *__nd = NULL; float *__nz = NULL; float *__nzw = NULL; float *__nvf = NULL; float *__nvfw = NULL; float *__nvl = NULL; float *__nvlw = NULL; float *__ndsigma = NULL; int *__nidx = NULL; int *__nidxp = NULL; int *__nidxq = NULL; int *__nperm = NULL; int *__ngivcol = NULL; float *__ngivnum = NULL;
  __nk = (*env)->GetIntField(env, k, intW_val_fieldID);
  __ngivptr = (*env)->GetIntField(env, givptr, intW_val_fieldID);
  __nc = (*env)->GetFloatField(env, c, floatW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nzw = (*env)->GetPrimitiveArrayCritical(env, zw, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvfw = (*env)->GetPrimitiveArrayCritical(env, vfw, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvlw = (*env)->GetPrimitiveArrayCritical(env, vlw, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nidx = (*env)->GetPrimitiveArrayCritical(env, idx, NULL))) goto fail;
  if (!(__nidxp = (*env)->GetPrimitiveArrayCritical(env, idxp, NULL))) goto fail;
  if (!(__nidxq = (*env)->GetPrimitiveArrayCritical(env, idxq, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  slasd7_(&icompq, &nl, &nr, &sqre, &__nk, __nd + offsetd, __nz + offsetz, __nzw + offsetzw, __nvf + offsetvf, __nvfw + offsetvfw, __nvl + offsetvl, __nvlw + offsetvlw, &alpha, &beta, __ndsigma + offsetdsigma, __nidx + offsetidx, __nidxp + offsetidxp, __nidxq + offsetidxq, __nperm + offsetperm, &__ngivptr, __ngivcol + offsetgivcol, &ldgcol, __ngivnum + offsetgivnum, &ldgnum, &__nc, &__ns, &__ninfo);
done:
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__nidxq) (*env)->ReleasePrimitiveArrayCritical(env, idxq, __nidxq, failed ? JNI_ABORT : 0);
  if (__nidxp) (*env)->ReleasePrimitiveArrayCritical(env, idxp, __nidxp, failed ? JNI_ABORT : 0);
  if (__nidx) (*env)->ReleasePrimitiveArrayCritical(env, idx, __nidx, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__nvlw) (*env)->ReleasePrimitiveArrayCritical(env, vlw, __nvlw, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvfw) (*env)->ReleasePrimitiveArrayCritical(env, vfw, __nvfw, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nzw) (*env)->ReleasePrimitiveArrayCritical(env, zw, __nzw, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!failed) (*env)->SetFloatField(env, c, floatW_val_fieldID, __nc);
  if (!failed) (*env)->SetIntField(env, givptr, intW_val_fieldID, __ngivptr);
  if (!failed) (*env)->SetIntField(env, k, intW_val_fieldID, __nk);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasd8_)(int *icompq, int *k, float *d, float *z, float *vf, float *vl, float *difl, float *difr, int *lddifr, float *dsigma, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasd8K(JNIEnv *env, UNUSED jobject obj, jint icompq, jint k, jfloatArray d, jint offsetd, jfloatArray z, jint offsetz, jfloatArray vf, jint offsetvf, jfloatArray vl, jint offsetvl, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jint lddifr, jfloatArray dsigma, jint offsetdsigma, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__nz = NULL; float *__nvf = NULL; float *__nvl = NULL; float *__ndifl = NULL; float *__ndifr = NULL; float *__ndsigma = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nvf = (*env)->GetPrimitiveArrayCritical(env, vf, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__ndsigma = (*env)->GetPrimitiveArrayCritical(env, dsigma, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasd8_(&icompq, &k, __nd + offsetd, __nz + offsetz, __nvf + offsetvf, __nvl + offsetvl, __ndifl + offsetdifl, __ndifr + offsetdifr, &lddifr, __ndsigma + offsetdsigma, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndsigma) (*env)->ReleasePrimitiveArrayCritical(env, dsigma, __ndsigma, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nvf) (*env)->ReleasePrimitiveArrayCritical(env, vf, __nvf, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasda_)(int *icompq, int *smlsiz, int *n, int *sqre, float *d, float *e, float *u, int *ldu, float *vt, int *k, float *difl, float *difr, float *z, float *poles, int *givptr, int *givcol, int *ldgcol, int *perm, float *givnum, float *c, float *s, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdaK(JNIEnv *env, UNUSED jobject obj, jint icompq, jint smlsiz, jint n, jint sqre, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray u, jint offsetu, jint ldu, jfloatArray vt, jint offsetvt, jintArray k, jint offsetk, jfloatArray difl, jint offsetdifl, jfloatArray difr, jint offsetdifr, jfloatArray z, jint offsetz, jfloatArray poles, jint offsetpoles, jintArray givptr, jint offsetgivptr, jintArray givcol, jint offsetgivcol, jint ldgcol, jintArray perm, jint offsetperm, jfloatArray givnum, jint offsetgivnum, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nu = NULL; float *__nvt = NULL; int *__nk = NULL; float *__ndifl = NULL; float *__ndifr = NULL; float *__nz = NULL; float *__npoles = NULL; int *__ngivptr = NULL; int *__ngivcol = NULL; int *__nperm = NULL; float *__ngivnum = NULL; float *__nc = NULL; float *__ns = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nk = (*env)->GetPrimitiveArrayCritical(env, k, NULL))) goto fail;
  if (!(__ndifl = (*env)->GetPrimitiveArrayCritical(env, difl, NULL))) goto fail;
  if (!(__ndifr = (*env)->GetPrimitiveArrayCritical(env, difr, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__npoles = (*env)->GetPrimitiveArrayCritical(env, poles, NULL))) goto fail;
  if (!(__ngivptr = (*env)->GetPrimitiveArrayCritical(env, givptr, NULL))) goto fail;
  if (!(__ngivcol = (*env)->GetPrimitiveArrayCritical(env, givcol, NULL))) goto fail;
  if (!(__nperm = (*env)->GetPrimitiveArrayCritical(env, perm, NULL))) goto fail;
  if (!(__ngivnum = (*env)->GetPrimitiveArrayCritical(env, givnum, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  slasda_(&icompq, &smlsiz, &n, &sqre, __nd + offsetd, __ne + offsete, __nu + offsetu, &ldu, __nvt + offsetvt, __nk + offsetk, __ndifl + offsetdifl, __ndifr + offsetdifr, __nz + offsetz, __npoles + offsetpoles, __ngivptr + offsetgivptr, __ngivcol + offsetgivcol, &ldgcol, __nperm + offsetperm, __ngivnum + offsetgivnum, __nc + offsetc, __ns + offsets, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ngivnum) (*env)->ReleasePrimitiveArrayCritical(env, givnum, __ngivnum, failed ? JNI_ABORT : 0);
  if (__nperm) (*env)->ReleasePrimitiveArrayCritical(env, perm, __nperm, failed ? JNI_ABORT : 0);
  if (__ngivcol) (*env)->ReleasePrimitiveArrayCritical(env, givcol, __ngivcol, failed ? JNI_ABORT : 0);
  if (__ngivptr) (*env)->ReleasePrimitiveArrayCritical(env, givptr, __ngivptr, failed ? JNI_ABORT : 0);
  if (__npoles) (*env)->ReleasePrimitiveArrayCritical(env, poles, __npoles, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ndifr) (*env)->ReleasePrimitiveArrayCritical(env, difr, __ndifr, failed ? JNI_ABORT : 0);
  if (__ndifl) (*env)->ReleasePrimitiveArrayCritical(env, difl, __ndifl, failed ? JNI_ABORT : 0);
  if (__nk) (*env)->ReleasePrimitiveArrayCritical(env, k, __nk, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasdq_)(const char *uplo, int *sqre, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, float *vt, int *ldvt, float *u, int *ldu, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdqK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint sqre, jint n, jint ncvt, jint nru, jint ncc, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray vt, jint offsetvt, jint ldvt, jfloatArray u, jint offsetu, jint ldu, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nvt = NULL; float *__nu = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nvt = (*env)->GetPrimitiveArrayCritical(env, vt, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasdq_(__nuplo, &sqre, &n, &ncvt, &nru, &ncc, __nd + offsetd, __ne + offsete, __nvt + offsetvt, &ldvt, __nu + offsetu, &ldu, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nvt) (*env)->ReleasePrimitiveArrayCritical(env, vt, __nvt, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasdt_)(int *n, int *lvl, int *nd, int *inode, int *ndiml, int *ndimr, int *msub);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasdtK(JNIEnv *env, UNUSED jobject obj, jint n, jobject lvl, jobject nd, jintArray inode, jint offsetinode, jintArray ndiml, jint offsetndiml, jintArray ndimr, jint offsetndimr, jint msub) {
  jboolean failed = FALSE;
  int __nlvl = 0; int __nnd = 0; int *__ninode = NULL; int *__nndiml = NULL; int *__nndimr = NULL;
  __nlvl = (*env)->GetIntField(env, lvl, intW_val_fieldID);
  __nnd = (*env)->GetIntField(env, nd, intW_val_fieldID);
  if (!(__ninode = (*env)->GetPrimitiveArrayCritical(env, inode, NULL))) goto fail;
  if (!(__nndiml = (*env)->GetPrimitiveArrayCritical(env, ndiml, NULL))) goto fail;
  if (!(__nndimr = (*env)->GetPrimitiveArrayCritical(env, ndimr, NULL))) goto fail;
  slasdt_(&n, &__nlvl, &__nnd, __ninode + offsetinode, __nndiml + offsetndiml, __nndimr + offsetndimr, &msub);
done:
  if (__nndimr) (*env)->ReleasePrimitiveArrayCritical(env, ndimr, __nndimr, failed ? JNI_ABORT : 0);
  if (__nndiml) (*env)->ReleasePrimitiveArrayCritical(env, ndiml, __nndiml, failed ? JNI_ABORT : 0);
  if (__ninode) (*env)->ReleasePrimitiveArrayCritical(env, inode, __ninode, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, nd, intW_val_fieldID, __nnd);
  if (!failed) (*env)->SetIntField(env, lvl, intW_val_fieldID, __nlvl);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaset_)(const char *uplo, int *m, int *n, float *alpha, float *beta, float *a, int *lda);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasetK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint m, jint n, jfloat alpha, jfloat beta, jfloatArray a, jint offseta, jint lda) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slaset_(__nuplo, &m, &n, &alpha, &beta, __na + offseta, &lda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq1_)(int *n, float *d, float *e, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq1K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slasq1_(&n, __nd + offsetd, __ne + offsete, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq2_)(int *n, float *z, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq2K(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray z, jint offsetz, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nz = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasq2_(&n, __nz + offsetz, &__ninfo);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq3_)(int *i0, int *n0, float *z, int *pp, float *dmin, float *sigma, float *desig, float *qmax, int *nfail, int *iter, int *ndiv, int *ieee);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq3K(JNIEnv *env, UNUSED jobject obj, jint i0, jobject n0, jfloatArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee) {
  jboolean failed = FALSE;
  int __nn0 = 0; float __ndmin = 0; float __nsigma = 0; float __ndesig = 0; float __nqmax = 0; int __nnfail = 0; int __niter = 0; int __nndiv = 0; int __nieee; float *__nz = NULL;
  __nn0 = (*env)->GetIntField(env, n0, intW_val_fieldID);
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __nsigma = (*env)->GetFloatField(env, sigma, floatW_val_fieldID);
  __ndesig = (*env)->GetFloatField(env, desig, floatW_val_fieldID);
  __nqmax = (*env)->GetFloatField(env, qmax, floatW_val_fieldID);
  __nnfail = (*env)->GetIntField(env, nfail, intW_val_fieldID);
  __niter = (*env)->GetIntField(env, iter, intW_val_fieldID);
  __nndiv = (*env)->GetIntField(env, ndiv, intW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasq3_(&i0, &__nn0, __nz + offsetz, &pp, &__ndmin, &__nsigma, &__ndesig, &__nqmax, &__nnfail, &__niter, &__nndiv, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) ieee = __nieee;
  if (!failed) (*env)->SetIntField(env, ndiv, intW_val_fieldID, __nndiv);
  if (!failed) (*env)->SetIntField(env, iter, intW_val_fieldID, __niter);
  if (!failed) (*env)->SetIntField(env, nfail, intW_val_fieldID, __nnfail);
  if (!failed) (*env)->SetFloatField(env, qmax, floatW_val_fieldID, __nqmax);
  if (!failed) (*env)->SetFloatField(env, desig, floatW_val_fieldID, __ndesig);
  if (!failed) (*env)->SetFloatField(env, sigma, floatW_val_fieldID, __nsigma);
  if (!failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (!failed) (*env)->SetIntField(env, n0, intW_val_fieldID, __nn0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq4_)(int *i0, int *n0, float *z, int *pp, int *n0in, float *dmin, float *dmin1, float *dmin2, float *dn, float *dn1, float *dn2, float *tau, int *ttype);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq4K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jint n0in, jfloat dmin, jfloat dmin1, jfloat dmin2, jfloat dn, jfloat dn1, jfloat dn2, jobject tau, jobject ttype) {
  jboolean failed = FALSE;
  float __ntau = 0; int __nttype = 0; float *__nz = NULL;
  __ntau = (*env)->GetFloatField(env, tau, floatW_val_fieldID);
  __nttype = (*env)->GetIntField(env, ttype, intW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasq4_(&i0, &n0, __nz + offsetz, &pp, &n0in, &dmin, &dmin1, &dmin2, &dn, &dn1, &dn2, &__ntau, &__nttype);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, ttype, intW_val_fieldID, __nttype);
  if (!failed) (*env)->SetFloatField(env, tau, floatW_val_fieldID, __ntau);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq5_)(int *i0, int *n0, float *z, int *pp, float *tau, float *dmin, float *dmin1, float *dmin2, float *dn, float *dnm1, float *dnm2, int *ieee);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq5K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jfloat tau, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2, jboolean ieee) {
  jboolean failed = FALSE;
  float __ndmin = 0; float __ndmin1 = 0; float __ndmin2 = 0; float __ndn = 0; float __ndnm1 = 0; float __ndnm2 = 0; int __nieee; float *__nz = NULL;
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __ndmin1 = (*env)->GetFloatField(env, dmin1, floatW_val_fieldID);
  __ndmin2 = (*env)->GetFloatField(env, dmin2, floatW_val_fieldID);
  __ndn = (*env)->GetFloatField(env, dn, floatW_val_fieldID);
  __ndnm1 = (*env)->GetFloatField(env, dnm1, floatW_val_fieldID);
  __ndnm2 = (*env)->GetFloatField(env, dnm2, floatW_val_fieldID);
  __nieee = ieee;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasq5_(&i0, &n0, __nz + offsetz, &pp, &tau, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2, &__nieee);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) ieee = __nieee;
  if (!failed) (*env)->SetFloatField(env, dnm2, floatW_val_fieldID, __ndnm2);
  if (!failed) (*env)->SetFloatField(env, dnm1, floatW_val_fieldID, __ndnm1);
  if (!failed) (*env)->SetFloatField(env, dn, floatW_val_fieldID, __ndn);
  if (!failed) (*env)->SetFloatField(env, dmin2, floatW_val_fieldID, __ndmin2);
  if (!failed) (*env)->SetFloatField(env, dmin1, floatW_val_fieldID, __ndmin1);
  if (!failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasq6_)(int *i0, int *n0, float *z, int *pp, float *dmin, float *dmin1, float *dmin2, float *dn, float *dnm1, float *dnm2);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasq6K(JNIEnv *env, UNUSED jobject obj, jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jobject dmin, jobject dmin1, jobject dmin2, jobject dn, jobject dnm1, jobject dnm2) {
  jboolean failed = FALSE;
  float __ndmin = 0; float __ndmin1 = 0; float __ndmin2 = 0; float __ndn = 0; float __ndnm1 = 0; float __ndnm2 = 0; float *__nz = NULL;
  __ndmin = (*env)->GetFloatField(env, dmin, floatW_val_fieldID);
  __ndmin1 = (*env)->GetFloatField(env, dmin1, floatW_val_fieldID);
  __ndmin2 = (*env)->GetFloatField(env, dmin2, floatW_val_fieldID);
  __ndn = (*env)->GetFloatField(env, dn, floatW_val_fieldID);
  __ndnm1 = (*env)->GetFloatField(env, dnm1, floatW_val_fieldID);
  __ndnm2 = (*env)->GetFloatField(env, dnm2, floatW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  slasq6_(&i0, &n0, __nz + offsetz, &pp, &__ndmin, &__ndmin1, &__ndmin2, &__ndn, &__ndnm1, &__ndnm2);
done:
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, dnm2, floatW_val_fieldID, __ndnm2);
  if (!failed) (*env)->SetFloatField(env, dnm1, floatW_val_fieldID, __ndnm1);
  if (!failed) (*env)->SetFloatField(env, dn, floatW_val_fieldID, __ndn);
  if (!failed) (*env)->SetFloatField(env, dmin2, floatW_val_fieldID, __ndmin2);
  if (!failed) (*env)->SetFloatField(env, dmin1, floatW_val_fieldID, __ndmin1);
  if (!failed) (*env)->SetFloatField(env, dmin, floatW_val_fieldID, __ndmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasr_)(const char *side, const char *pivot, const char *direct, int *m, int *n, float *c, float *s, float *a, int *lda);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring pivot, jstring direct, jint m, jint n, jfloatArray c, jint offsetc, jfloatArray s, jint offsets, jfloatArray a, jint offseta, jint lda) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__npivot = NULL; const char *__ndirect = NULL; float *__nc = NULL; float *__ns = NULL; float *__na = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__npivot = (*env)->GetStringUTFChars(env, pivot, NULL))) goto fail;
  if (!(__ndirect = (*env)->GetStringUTFChars(env, direct, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slasr_(__nside, __npivot, __ndirect, &m, &n, __nc + offsetc, __ns + offsets, __na + offseta, &lda);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ndirect) (*env)->ReleaseStringUTFChars(env, direct, __ndirect);
  if (__npivot) (*env)->ReleaseStringUTFChars(env, pivot, __npivot);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasrt_)(const char *id, int *n, float *d, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasrtK(JNIEnv *env, UNUSED jobject obj, jstring id, jint n, jfloatArray d, jint offsetd, jobject info) {
  jboolean failed = FALSE;
  const char *__nid = NULL; int __ninfo = 0; float *__nd = NULL;
  if (!(__nid = (*env)->GetStringUTFChars(env, id, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  slasrt_(__nid, &n, __nd + offsetd, &__ninfo);
done:
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nid) (*env)->ReleaseStringUTFChars(env, id, __nid);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slassq_)(int *n, float *x, int *incx, float *scale, float *sumsq);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slassqK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray x, jint offsetx, jint incx, jobject scale, jobject sumsq) {
  jboolean failed = FALSE;
  float __nscale = 0; float __nsumsq = 0; float *__nx = NULL;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nsumsq = (*env)->GetFloatField(env, sumsq, floatW_val_fieldID);
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slassq_(&n, __nx + offsetx, &incx, &__nscale, &__nsumsq);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, sumsq, floatW_val_fieldID, __nsumsq);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasv2_)(float *f, float *g, float *h, float *ssmin, float *ssmax, float *snr, float *csr, float *snl, float *csl);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasv2K(JNIEnv *env, UNUSED jobject obj, jfloat f, jfloat g, jfloat h, jobject ssmin, jobject ssmax, jobject snr, jobject csr, jobject snl, jobject csl) {
  jboolean failed = FALSE;
  float __nssmin = 0; float __nssmax = 0; float __nsnr = 0; float __ncsr = 0; float __nsnl = 0; float __ncsl = 0;
  __nssmin = (*env)->GetFloatField(env, ssmin, floatW_val_fieldID);
  __nssmax = (*env)->GetFloatField(env, ssmax, floatW_val_fieldID);
  __nsnr = (*env)->GetFloatField(env, snr, floatW_val_fieldID);
  __ncsr = (*env)->GetFloatField(env, csr, floatW_val_fieldID);
  __nsnl = (*env)->GetFloatField(env, snl, floatW_val_fieldID);
  __ncsl = (*env)->GetFloatField(env, csl, floatW_val_fieldID);
  slasv2_(&f, &g, &h, &__nssmin, &__nssmax, &__nsnr, &__ncsr, &__nsnl, &__ncsl);
done:
  if (!failed) (*env)->SetFloatField(env, csl, floatW_val_fieldID, __ncsl);
  if (!failed) (*env)->SetFloatField(env, snl, floatW_val_fieldID, __nsnl);
  if (!failed) (*env)->SetFloatField(env, csr, floatW_val_fieldID, __ncsr);
  if (!failed) (*env)->SetFloatField(env, snr, floatW_val_fieldID, __nsnr);
  if (!failed) (*env)->SetFloatField(env, ssmax, floatW_val_fieldID, __nssmax);
  if (!failed) (*env)->SetFloatField(env, ssmin, floatW_val_fieldID, __nssmin);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slaswp_)(int *n, float *a, int *lda, int *k1, int *k2, int *ipiv, int *incx);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slaswpK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jint k1, jint k2, jintArray ipiv, jint offsetipiv, jint incx) {
  jboolean failed = FALSE;
  float *__na = NULL; int *__nipiv = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  slaswp_(&n, __na + offseta, &lda, &k1, &k2, __nipiv + offsetipiv, &incx);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasy2_)(int *ltranl, int *ltranr, int *isgn, int *n1, int *n2, float *tl, int *ldtl, float *tr, int *ldtr, float *b, int *ldb, float *scale, float *x, int *ldx, float *xnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasy2K(JNIEnv *env, UNUSED jobject obj, jboolean ltranl, jboolean ltranr, jint isgn, jint n1, jint n2, jfloatArray tl, jint offsettl, jint ldtl, jfloatArray tr, jint offsettr, jint ldtr, jfloatArray b, jint offsetb, jint ldb, jobject scale, jfloatArray x, jint offsetx, jint ldx, jobject xnorm, jobject info) {
  jboolean failed = FALSE;
  int __nltranl; int __nltranr; float __nscale = 0; float __nxnorm = 0; int __ninfo = 0; float *__ntl = NULL; float *__ntr = NULL; float *__nb = NULL; float *__nx = NULL;
  __nltranl = ltranl;
  __nltranr = ltranr;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nxnorm = (*env)->GetFloatField(env, xnorm, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__ntl = (*env)->GetPrimitiveArrayCritical(env, tl, NULL))) goto fail;
  if (!(__ntr = (*env)->GetPrimitiveArrayCritical(env, tr, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  slasy2_(&__nltranl, &__nltranr, &isgn, &n1, &n2, __ntl + offsettl, &ldtl, __ntr + offsettr, &ldtr, __nb + offsetb, &ldb, &__nscale, __nx + offsetx, &ldx, &__nxnorm, &__ninfo);
done:
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ntr) (*env)->ReleasePrimitiveArrayCritical(env, tr, __ntr, failed ? JNI_ABORT : 0);
  if (__ntl) (*env)->ReleasePrimitiveArrayCritical(env, tl, __ntl, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, xnorm, floatW_val_fieldID, __nxnorm);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (!failed) ltranr = __nltranr;
  if (!failed) ltranl = __nltranl;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slasyf_)(const char *uplo, int *n, int *nb, int *kb, float *a, int *lda, int *ipiv, float *w, int *ldw, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slasyfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jobject kb, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray w, jint offsetw, jint ldw, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __nkb = 0; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nkb = (*env)->GetIntField(env, kb, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  slasyf_(__nuplo, &n, &nb, &__nkb, __na + offseta, &lda, __nipiv + offsetipiv, __nw + offsetw, &ldw, &__ninfo);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, kb, intW_val_fieldID, __nkb);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatbs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, int *kd, float *ab, int *ldab, float *x, float *scale, float *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatbsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; float __nscale = 0; int __ninfo = 0; float *__nab = NULL; float *__nx = NULL; float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  slatbs_(__nuplo, __ntrans, __ndiag, __nnormin, &n, &kd, __nab + offsetab, &ldab, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatdf_)(int *ijob, int *n, float *z, int *ldz, float *rhs, float *rdsum, float *rdscal, int *ipiv, int *jpiv);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatdfK(JNIEnv *env, UNUSED jobject obj, jint ijob, jint n, jfloatArray z, jint offsetz, jint ldz, jfloatArray rhs, jint offsetrhs, jobject rdsum, jobject rdscal, jintArray ipiv, jint offsetipiv, jintArray jpiv, jint offsetjpiv) {
  jboolean failed = FALSE;
  float __nrdsum = 0; float __nrdscal = 0; float *__nz = NULL; float *__nrhs = NULL; int *__nipiv = NULL; int *__njpiv = NULL;
  __nrdsum = (*env)->GetFloatField(env, rdsum, floatW_val_fieldID);
  __nrdscal = (*env)->GetFloatField(env, rdscal, floatW_val_fieldID);
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nrhs = (*env)->GetPrimitiveArrayCritical(env, rhs, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__njpiv = (*env)->GetPrimitiveArrayCritical(env, jpiv, NULL))) goto fail;
  slatdf_(&ijob, &n, __nz + offsetz, &ldz, __nrhs + offsetrhs, &__nrdsum, &__nrdscal, __nipiv + offsetipiv, __njpiv + offsetjpiv);
done:
  if (__njpiv) (*env)->ReleasePrimitiveArrayCritical(env, jpiv, __njpiv, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nrhs) (*env)->ReleasePrimitiveArrayCritical(env, rhs, __nrhs, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetFloatField(env, rdscal, floatW_val_fieldID, __nrdscal);
  if (!failed) (*env)->SetFloatField(env, rdsum, floatW_val_fieldID, __nrdsum);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatps_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, float *ap, float *x, float *scale, float *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatpsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jfloatArray ap, jint offsetap, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; float __nscale = 0; int __ninfo = 0; float *__nap = NULL; float *__nx = NULL; float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  slatps_(__nuplo, __ntrans, __ndiag, __nnormin, &n, __nap + offsetap, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatrd_)(const char *uplo, int *n, int *nb, float *a, int *lda, float *e, float *tau, float *w, int *ldw);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nb, jfloatArray a, jint offseta, jint lda, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jfloatArray w, jint offsetw, jint ldw) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float *__na = NULL; float *__ne = NULL; float *__ntau = NULL; float *__nw = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  slatrd_(__nuplo, &n, &nb, __na + offseta, &lda, __ne + offsete, __ntau + offsettau, __nw + offsetw, &ldw);
done:
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatrs_)(const char *uplo, const char *trans, const char *diag, const char *normin, int *n, float *a, int *lda, float *x, float *scale, float *cnorm, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jstring normin, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray x, jint offsetx, jobject scale, jfloatArray cnorm, jint offsetcnorm, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; const char *__nnormin = NULL; float __nscale = 0; int __ninfo = 0; float *__na = NULL; float *__nx = NULL; float *__ncnorm = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  if (!(__nnormin = (*env)->GetStringUTFChars(env, normin, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__ncnorm = (*env)->GetPrimitiveArrayCritical(env, cnorm, NULL))) goto fail;
  slatrs_(__nuplo, __ntrans, __ndiag, __nnormin, &n, __na + offseta, &lda, __nx + offsetx, &__nscale, __ncnorm + offsetcnorm, &__ninfo);
done:
  if (__ncnorm) (*env)->ReleasePrimitiveArrayCritical(env, cnorm, __ncnorm, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__nnormin) (*env)->ReleaseStringUTFChars(env, normin, __nnormin);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatrz_)(int *m, int *n, int *l, float *a, int *lda, float *tau, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatrzK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slatrz_(&m, &n, &l, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slatzm_)(const char *side, int *m, int *n, float *v, int *incv, float *tau, float *c1, float *c2, int *Ldc, float *work);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slatzmK(JNIEnv *env, UNUSED jobject obj, jstring side, jint m, jint n, jfloatArray v, jint offsetv, jint incv, jfloat tau, jfloatArray c1, jint offsetc1, jfloatArray c2, jint offsetc2, jint Ldc, jfloatArray work, jint offsetwork) {
  jboolean failed = FALSE;
  const char *__nside = NULL; float *__nv = NULL; float *__nc1 = NULL; float *__nc2 = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nc1 = (*env)->GetPrimitiveArrayCritical(env, c1, NULL))) goto fail;
  if (!(__nc2 = (*env)->GetPrimitiveArrayCritical(env, c2, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  slatzm_(__nside, &m, &n, __nv + offsetv, &incv, &tau, __nc1 + offsetc1, __nc2 + offsetc2, &Ldc, __nwork + offsetwork);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc2) (*env)->ReleasePrimitiveArrayCritical(env, c2, __nc2, failed ? JNI_ABORT : 0);
  if (__nc1) (*env)->ReleasePrimitiveArrayCritical(env, c1, __nc1, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slauu2_)(const char *uplo, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slauu2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slauu2_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*slauum_)(const char *uplo, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slauumK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  slauum_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sopgtr_)(const char *uplo, int *n, float *ap, float *tau, float *q, int *ldq, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sopgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray tau, jint offsettau, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__ntau = NULL; float *__nq = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sopgtr_(__nuplo, &n, __nap + offsetap, __ntau + offsettau, __nq + offsetq, &ldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sopmtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, float *ap, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sopmtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jfloatArray ap, jint offsetap, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nuplo = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__nap = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sopmtr_(__nside, __nuplo, __ntrans, &m, &n, __nap + offsetap, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorg2l_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorg2lK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorg2l_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorg2r_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorg2rK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorg2r_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgbr_)(const char *vect, int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgbr_(__nvect, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorghr_)(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorghrK(JNIEnv *env, UNUSED jobject obj, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorghr_(&n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgl2_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgl2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgl2_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorglq_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorglqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorglq_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgql_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgqlK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgql_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgqr_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgqrK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgqr_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgr2_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgr2K(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgr2_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgrq_)(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgrqK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgrq_(&m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorgtr_)(const char *uplo, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorgtrK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorgtr_(__nuplo, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorm2l_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorm2lK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorm2l_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorm2r_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorm2rK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorm2r_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormbr_)(const char *vect, const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormbrK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormbr_(__nvect, __nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormhr_)(const char *side, const char *trans, int *m, int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormhrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint ilo, jint ihi, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormhr_(__nside, __ntrans, &m, &n, &ilo, &ihi, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sorml2_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sorml2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sorml2_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormlq_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormlqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormlq_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormql_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormqlK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormql_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormqr_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormqrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormqr_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormr2_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormr2K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormr2_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormr3_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormr3K(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormr3_(__nside, __ntrans, &m, &n, &k, &l, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormrq_)(const char *side, const char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormrqK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormrq_(__nside, __ntrans, &m, &n, &k, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormrz_)(const char *side, const char *trans, int *m, int *n, int *k, int *l, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormrzK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring trans, jint m, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormrz_(__nside, __ntrans, &m, &n, &k, &l, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sormtr_)(const char *side, const char *uplo, const char *trans, int *m, int *n, float *a, int *lda, float *tau, float *c, int *Ldc, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sormtrK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring uplo, jstring trans, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray c, jint offsetc, jint Ldc, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nuplo = NULL; const char *__ntrans = NULL; int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nc = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sormtr_(__nside, __nuplo, __ntrans, &m, &n, __na + offseta, &lda, __ntau + offsettau, __nc + offsetc, &Ldc, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbcon_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__nab = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  spbcon_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbequ_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, float *s, float *scond, float *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nscond = 0; float __namax = 0; int __ninfo = 0; float *__nab = NULL; float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  spbequ_(__nuplo, &n, &kd, __nab + offsetab, &ldab, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbrfs_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nafb = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  spbrfs_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbstf_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbstfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  spbstf_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbsv_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  spbsv_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbsvx_)(const char *fact, const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray afb, jint offsetafb, jint ldafb, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float __nrcond = 0; int __ninfo = 0; float *__nab = NULL; float *__nafb = NULL; float *__ns = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nafb = (*env)->GetPrimitiveArrayCritical(env, afb, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  spbsvx_(__nfact, __nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nafb + offsetafb, &ldafb, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nafb) (*env)->ReleasePrimitiveArrayCritical(env, afb, __nafb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbtf2_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  spbtf2_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbtrf_)(const char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  spbtrf_(__nuplo, &n, &kd, __nab + offsetab, &ldab, &__ninfo);
done:
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spbtrs_)(const char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  spbtrs_(__nuplo, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spocon_)(const char *uplo, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spoconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  spocon_(__nuplo, &n, __na + offseta, &lda, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spoequ_)(int *n, float *a, int *lda, float *s, float *scond, float *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spoequK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  float __nscond = 0; float __namax = 0; int __ninfo = 0; float *__na = NULL; float *__ns = NULL;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  spoequ_(&n, __na + offseta, &lda, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sporfs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sporfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sporfs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sposv_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sposvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sposv_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sposvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sposvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; float *__ns = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sposvx_(__nfact, __nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spotf2_)(const char *uplo, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  spotf2_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spotrf_)(const char *uplo, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  spotrf_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spotri_)(const char *uplo, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  spotri_(__nuplo, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spotrs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spotrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  spotrs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sppcon_)(const char *uplo, int *n, float *ap, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__nap = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sppcon_(__nuplo, &n, __nap + offsetap, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sppequ_)(const char *uplo, int *n, float *ap, float *s, float *scond, float *amax, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppequK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray s, jint offsets, jobject scond, jobject amax, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nscond = 0; float __namax = 0; int __ninfo = 0; float *__nap = NULL; float *__ns = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nscond = (*env)->GetFloatField(env, scond, floatW_val_fieldID);
  __namax = (*env)->GetFloatField(env, amax, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  sppequ_(__nuplo, &n, __nap + offsetap, __ns + offsets, &__nscond, &__namax, &__ninfo);
done:
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, amax, floatW_val_fieldID, __namax);
  if (!failed) (*env)->SetFloatField(env, scond, floatW_val_fieldID, __nscond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spprfs_)(const char *uplo, int *n, int *nrhs, float *ap, float *afp, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nafp = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  spprfs_(__nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sppsv_)(const char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sppsv_(__nuplo, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sppsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *ap, float *afp, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sppsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jobject equed, jfloatArray s, jint offsets, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; char *__nequed = NULL; jstring __jequed = NULL;; float __nrcond = 0; int __ninfo = 0; float *__nap = NULL; float *__nafp = NULL; float *__ns = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __jequed = (jstring)(*env)->GetObjectField(env, equed, StringW_val_fieldID); if (!(__nequed = (char*)(*env)->GetStringUTFChars(env, equed, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sppsvx_(__nfact, __nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nequed, __ns + offsets, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nequed) { (*env)->ReleaseStringUTFChars(env, __jequed, (const char*)__nequed); if (!failed) (*env)->SetObjectField(env, equed, StringW_val_fieldID, __jequed); }
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spptrf_)(const char *uplo, int *n, float *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  spptrf_(__nuplo, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spptri_)(const char *uplo, int *n, float *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  spptri_(__nuplo, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spptrs_)(const char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  spptrs_(__nuplo, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sptcon_)(int *n, float *d, float *e, float *anorm, float *rcond, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptconK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  float __nrcond = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nwork = NULL;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sptcon_(&n, __nd + offsetd, __ne + offsete, &anorm, &__nrcond, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spteqr_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  spteqr_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sptrfs_)(int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptrfsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray df, jint offsetdf, jfloatArray ef, jint offsetef, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__ndf = NULL; float *__nef = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sptrfs_(&n, &nrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sptsv_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptsvK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sptsv_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sptsvx_)(const char *fact, int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray df, jint offsetdf, jfloatArray ef, jint offsetef, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; float __nrcond = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__ndf = NULL; float *__nef = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ndf = (*env)->GetPrimitiveArrayCritical(env, df, NULL))) goto fail;
  if (!(__nef = (*env)->GetPrimitiveArrayCritical(env, ef, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sptsvx_(__nfact, &n, &nrhs, __nd + offsetd, __ne + offsete, __ndf + offsetdf, __nef + offsetef, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nef) (*env)->ReleasePrimitiveArrayCritical(env, ef, __nef, failed ? JNI_ABORT : 0);
  if (__ndf) (*env)->ReleasePrimitiveArrayCritical(env, df, __ndf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spttrf_)(int *n, float *d, float *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spttrfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  spttrf_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*spttrs_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_spttrsK(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nb = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  spttrs_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sptts2_)(int *n, int *nrhs, float *d, float *e, float *b, int *ldb);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sptts2K(JNIEnv *env, UNUSED jobject obj, jint n, jint nrhs, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray b, jint offsetb, jint ldb) {
  jboolean failed = FALSE;
  float *__nd = NULL; float *__ne = NULL; float *__nb = NULL;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sptts2_(&n, &nrhs, __nd + offsetd, __ne + offsete, __nb + offsetb, &ldb);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*srscl_)(int *n, float *sa, float *sx, int *incx);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_srsclK(JNIEnv *env, UNUSED jobject obj, jint n, jfloat sa, jfloatArray sx, jint offsetsx, jint incx) {
  jboolean failed = FALSE;
  float *__nsx = NULL;
  if (!(__nsx = (*env)->GetPrimitiveArrayCritical(env, sx, NULL))) goto fail;
  srscl_(&n, &sa, __nsx + offsetsx, &incx);
done:
  if (__nsx) (*env)->ReleasePrimitiveArrayCritical(env, sx, __nsx, failed ? JNI_ABORT : 0);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbev_)(const char *jobz, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssbev_(__njobz, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbevd_)(const char *jobz, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssbevd_(__njobz, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbevx_)(const char *jobz, const char *range, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray q, jint offsetq, jint ldq, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__nab = NULL; float *__nq = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  ssbevx_(__njobz, __nrange, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nq + offsetq, &ldq, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbgst_)(const char *vect, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *x, int *ldx, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgstK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray x, jint offsetx, jint ldx, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nbb = NULL; float *__nx = NULL; float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssbgst_(__nvect, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nx + offsetx, &ldx, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbgv_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *w, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nbb = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssbgv_(__njobz, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbgvd_)(const char *jobz, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nbb = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssbgvd_(__njobz, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbgvx_)(const char *jobz, const char *range, const char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbgvxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jint ka, jint kb, jfloatArray ab, jint offsetab, jint ldab, jfloatArray bb, jint offsetbb, jint ldbb, jfloatArray q, jint offsetq, jint ldq, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__nab = NULL; float *__nbb = NULL; float *__nq = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nbb = (*env)->GetPrimitiveArrayCritical(env, bb, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  ssbgvx_(__njobz, __nrange, __nuplo, &n, &ka, &kb, __nab + offsetab, &ldab, __nbb + offsetbb, &ldbb, __nq + offsetq, &ldq, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbb) (*env)->ReleasePrimitiveArrayCritical(env, bb, __nbb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssbtrd_)(const char *vect, const char *uplo, int *n, int *kd, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssbtrdK(JNIEnv *env, UNUSED jobject obj, jstring vect, jstring uplo, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nvect = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nab = NULL; float *__nd = NULL; float *__ne = NULL; float *__nq = NULL; float *__nwork = NULL;
  if (!(__nvect = (*env)->GetStringUTFChars(env, vect, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssbtrd_(__nvect, __nuplo, &n, &kd, __nab + offsetab, &ldab, __nd + offsetd, __ne + offsete, __nq + offsetq, &ldq, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nvect) (*env)->ReleaseStringUTFChars(env, vect, __nvect);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspcon_)(const char *uplo, int *n, float *ap, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__nap = NULL; int *__nipiv = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sspcon_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspev_)(const char *jobz, const char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sspev_(__njobz, __nuplo, &n, __nap + offsetap, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspevd_)(const char *jobz, const char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sspevd_(__njobz, __nuplo, &n, __nap + offsetap, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspevx_)(const char *jobz, const char *range, const char *uplo, int *n, float *ap, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__nap = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  sspevx_(__njobz, __nrange, __nuplo, &n, __nap + offsetap, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspgst_)(int *itype, const char *uplo, int *n, float *ap, float *bp, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nbp = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  sspgst_(&itype, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, &__ninfo);
done:
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspgv_)(int *itype, const char *jobz, const char *uplo, int *n, float *ap, float *bp, float *w, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nbp = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sspgv_(&itype, __njobz, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspgvd_)(int *itype, const char *jobz, const char *uplo, int *n, float *ap, float *bp, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nbp = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sspgvd_(&itype, __njobz, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspgvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, float *ap, float *bp, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspgvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray bp, jint offsetbp, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__nap = NULL; float *__nbp = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nbp = (*env)->GetPrimitiveArrayCritical(env, bp, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  sspgvx_(&itype, __njobz, __nrange, __nuplo, &n, __nap + offsetap, __nbp + offsetbp, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nbp) (*env)->ReleasePrimitiveArrayCritical(env, bp, __nbp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssprfs_)(const char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nafp = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssprfs_(__nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspsv_)(const char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspsvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  sspsv_(__nuplo, &n, &nrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sspsvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sspsvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray afp, jint offsetafp, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__nap = NULL; float *__nafp = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nafp = (*env)->GetPrimitiveArrayCritical(env, afp, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sspsvx_(__nfact, __nuplo, &n, &nrhs, __nap + offsetap, __nafp + offsetafp, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nafp) (*env)->ReleasePrimitiveArrayCritical(env, afp, __nafp, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssptrd_)(const char *uplo, int *n, float *ap, float *d, float *e, float *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  ssptrd_(__nuplo, &n, __nap + offsetap, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssptrf_)(const char *uplo, int *n, float *ap, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  ssptrf_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssptri_)(const char *uplo, int *n, float *ap, int *ipiv, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; int *__nipiv = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssptri_(__nuplo, &n, __nap + offsetap, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssptrs_)(const char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray ap, jint offsetap, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__nap = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  ssptrs_(__nuplo, &n, &nrhs, __nap + offsetap, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstebz_)(const char *range, const char *order, int *n, float *vl, float *vu, int *il, int *iu, float *abstol, float *d, float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstebzK(JNIEnv *env, UNUSED jobject obj, jstring range, jstring order, jint n, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject m, jobject nsplit, jfloatArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nrange = NULL; const char *__norder = NULL; int __nm = 0; int __nnsplit = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; int *__niblock = NULL; int *__nisplit = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__norder = (*env)->GetStringUTFChars(env, order, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __nnsplit = (*env)->GetIntField(env, nsplit, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstebz_(__nrange, __norder, &n, &vl, &vu, &il, &iu, &abstol, __nd + offsetd, __ne + offsete, &__nm, &__nnsplit, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, nsplit, intW_val_fieldID, __nnsplit);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__norder) (*env)->ReleaseStringUTFChars(env, order, __norder);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstedc_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstedcK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstedc_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstegr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstegrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstegr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstein_)(int *n, float *d, float *e, int *m, float *w, int *iblock, int *isplit, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssteinK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jint m, jfloatArray w, jint offsetw, jintArray iblock, jint offsetiblock, jintArray isplit, jint offsetisplit, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; int *__niblock = NULL; int *__nisplit = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__niblock = (*env)->GetPrimitiveArrayCritical(env, iblock, NULL))) goto fail;
  if (!(__nisplit = (*env)->GetPrimitiveArrayCritical(env, isplit, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  sstein_(&n, __nd + offsetd, __ne + offsete, &m, __nw + offsetw, __niblock + offsetiblock, __nisplit + offsetisplit, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nisplit) (*env)->ReleasePrimitiveArrayCritical(env, isplit, __nisplit, failed ? JNI_ABORT : 0);
  if (__niblock) (*env)->ReleasePrimitiveArrayCritical(env, iblock, __niblock, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstemr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, int *m, float *w, float *z, int *ldz, int *nzc, int *isuppz, int *tryrac, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstemrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jint nzc, jintArray isuppz, jint offsetisuppz, jobject tryrac, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ntryrac = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ntryrac = (*env)->GetBooleanField(env, tryrac, booleanW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstemr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &__nm, __nw + offsetw, __nz + offsetz, &ldz, &nzc, __nisuppz + offsetisuppz, &__ntryrac, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetBooleanField(env, tryrac, booleanW_val_fieldID, __ntryrac);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssteqr_)(const char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssteqrK(JNIEnv *env, UNUSED jobject obj, jstring compz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompz = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__ncompz = (*env)->GetStringUTFChars(env, compz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssteqr_(__ncompz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ncompz) (*env)->ReleaseStringUTFChars(env, compz, __ncompz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssterf_)(int *n, float *d, float *e, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssterfK(JNIEnv *env, UNUSED jobject obj, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__nd = NULL; float *__ne = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  ssterf_(&n, __nd + offsetd, __ne + offsete, &__ninfo);
done:
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstev_)(const char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nz = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  sstev_(__njobz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstevd_)(const char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstevd_(__njobz, &n, __nd + offsetd, __ne + offsete, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstevr_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  sstevr_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*sstevx_)(const char *jobz, const char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sstevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jint n, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; int __nm = 0; int __ninfo = 0; float *__nd = NULL; float *__ne = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  sstevx_(__njobz, __nrange, &n, __nd + offsetd, __ne + offsete, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssycon_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyconK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloat anorm, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssycon_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, &anorm, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssyev_)(const char *jobz, const char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nw = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssyev_(__njobz, __nuplo, &n, __na + offseta, &lda, __nw + offsetw, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssyevd_)(const char *jobz, const char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevdK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nw = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssyevd_(__njobz, __nuplo, &n, __na + offseta, &lda, __nw + offsetw, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssyevr_)(const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, int *isuppz, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevrK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jintArray isuppz, jint offsetisuppz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__na = NULL; float *__nw = NULL; float *__nz = NULL; int *__nisuppz = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nisuppz = (*env)->GetPrimitiveArrayCritical(env, isuppz, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssyevr_(__njobz, __nrange, __nuplo, &n, __na + offseta, &lda, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nisuppz + offsetisuppz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nisuppz) (*env)->ReleasePrimitiveArrayCritical(env, isuppz, __nisuppz, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssyevx_)(const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyevxK(JNIEnv *env, UNUSED jobject obj, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__na = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  ssyevx_(__njobz, __nrange, __nuplo, &n, __na + offseta, &lda, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssygs2_)(int *itype, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygs2K(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  ssygs2_(&itype, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssygst_)(int *itype, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygstK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  ssygst_(&itype, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssygv_)(int *itype, const char *jobz, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *w, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nw = NULL; float *__nwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssygv_(&itype, __njobz, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nw + offsetw, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssygvd_)(int *itype, const char *jobz, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *w, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvdK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray w, jint offsetw, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nw = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssygvd_(&itype, __njobz, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nw + offsetw, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssygvx_)(int *itype, const char *jobz, const char *range, const char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *ifail, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssygvxK(JNIEnv *env, UNUSED jobject obj, jint itype, jstring jobz, jstring range, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat vl, jfloat vu, jint il, jint iu, jfloat abstol, jobject m, jfloatArray w, jint offsetw, jfloatArray z, jint offsetz, jint ldz, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jintArray ifail, jint offsetifail, jobject info) {
  jboolean failed = FALSE;
  const char *__njobz = NULL; const char *__nrange = NULL; const char *__nuplo = NULL; int __nm = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nw = NULL; float *__nz = NULL; float *__nwork = NULL; int *__niwork = NULL; int *__nifail = NULL;
  if (!(__njobz = (*env)->GetStringUTFChars(env, jobz, NULL))) goto fail;
  if (!(__nrange = (*env)->GetStringUTFChars(env, range, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nw = (*env)->GetPrimitiveArrayCritical(env, w, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  if (!(__nifail = (*env)->GetPrimitiveArrayCritical(env, ifail, NULL))) goto fail;
  ssygvx_(&itype, __njobz, __nrange, __nuplo, &n, __na + offseta, &lda, __nb + offsetb, &ldb, &vl, &vu, &il, &iu, &abstol, &__nm, __nw + offsetw, __nz + offsetz, &ldz, __nwork + offsetwork, &lwork, __niwork + offsetiwork, __nifail + offsetifail, &__ninfo);
done:
  if (__nifail) (*env)->ReleasePrimitiveArrayCritical(env, ifail, __nifail, failed ? JNI_ABORT : 0);
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nw) (*env)->ReleasePrimitiveArrayCritical(env, w, __nw, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nrange) (*env)->ReleaseStringUTFChars(env, range, __nrange);
  if (__njobz) (*env)->ReleaseStringUTFChars(env, jobz, __njobz);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssyrfs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssyrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssyrfs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssysv_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssysvK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssysv_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssysvx_)(const char *fact, const char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssysvxK(JNIEnv *env, UNUSED jobject obj, jstring fact, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray af, jint offsetaf, jint ldaf, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jobject rcond, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nfact = NULL; const char *__nuplo = NULL; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__naf = NULL; int *__nipiv = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nfact = (*env)->GetStringUTFChars(env, fact, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__naf = (*env)->GetPrimitiveArrayCritical(env, af, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  ssysvx_(__nfact, __nuplo, &n, &nrhs, __na + offseta, &lda, __naf + offsetaf, &ldaf, __nipiv + offsetipiv, __nb + offsetb, &ldb, __nx + offsetx, &ldx, &__nrcond, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__naf) (*env)->ReleasePrimitiveArrayCritical(env, af, __naf, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nfact) (*env)->ReleaseStringUTFChars(env, fact, __nfact);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytd2_)(const char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytd2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntau = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  ssytd2_(__nuplo, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytf2_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytf2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  ssytf2_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, &__ninfo);
done:
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytrd_)(const char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrdK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray d, jint offsetd, jfloatArray e, jint offsete, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; float *__nd = NULL; float *__ne = NULL; float *__ntau = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssytrd_(__nuplo, &n, __na + offseta, &lda, __nd + offsetd, __ne + offsete, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytrf_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrfK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssytrf_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytri_)(const char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  ssytri_(__nuplo, &n, __na + offseta, &lda, __nipiv + offsetipiv, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*ssytrs_)(const char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_ssytrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jintArray ipiv, jint offsetipiv, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; int __ninfo = 0; float *__na = NULL; int *__nipiv = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nipiv = (*env)->GetPrimitiveArrayCritical(env, ipiv, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  ssytrs_(__nuplo, &n, &nrhs, __na + offseta, &lda, __nipiv + offsetipiv, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nipiv) (*env)->ReleasePrimitiveArrayCritical(env, ipiv, __nipiv, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stbcon_)(const char *norm, const char *uplo, const char *diag, int *n, int *kd, float *ab, int *ldab, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jint kd, jfloatArray ab, jint offsetab, jint ldab, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float __nrcond = 0; int __ninfo = 0; float *__nab = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stbcon_(__nnorm, __nuplo, __ndiag, &n, &kd, __nab + offsetab, &ldab, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stbrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__nab = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stbrfs_(__nuplo, __ntrans, __ndiag, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stbtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stbtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint kd, jint nrhs, jfloatArray ab, jint offsetab, jint ldab, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__nab = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nab = (*env)->GetPrimitiveArrayCritical(env, ab, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  stbtrs_(__nuplo, __ntrans, __ndiag, &n, &kd, &nrhs, __nab + offsetab, &ldab, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nab) (*env)->ReleasePrimitiveArrayCritical(env, ab, __nab, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgevc_)(const char *side, const char *howmny, int *select, int *n, float *s, int *lds, float *p, int *ldp, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray s, jint offsets, jint lds, jfloatArray p, jint offsetp, jint ldp, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__ns = NULL; float *__np = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__np = (*env)->GetPrimitiveArrayCritical(env, p, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  stgevc_(__nside, __nhowmny, __nselect + offsetselect, &n, __ns + offsets, &lds, __np + offsetp, &ldp, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__np) (*env)->ReleasePrimitiveArrayCritical(env, p, __np, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgex2_)(int *wantq, int *wantz, int *n, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *j1, int *n1, int *n2, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgex2K(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jint j1, jint n1, jint n2, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nq = NULL; float *__nz = NULL; float *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  stgex2_(&__nwantq, &__nwantz, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &j1, &n1, &n2, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgexc_)(int *wantq, int *wantz, int *n, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *ifst, int *ilst, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgexcK(JNIEnv *env, UNUSED jobject obj, jboolean wantq, jboolean wantz, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject ifst, jobject ilst, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __nifst = 0; int __nilst = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nq = NULL; float *__nz = NULL; float *__nwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  stgexc_(&__nwantq, &__nwantz, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__nifst, &__nilst, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgsen_)(int *ijob, int *wantq, int *wantz, int *select, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *q, int *ldq, float *z, int *ldz, int *m, float *pl, float *pr, float *dif, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsenK(JNIEnv *env, UNUSED jobject obj, jint ijob, jboolean wantq, jboolean wantz, jbooleanArray select, jint offsetselect, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray q, jint offsetq, jint ldq, jfloatArray z, jint offsetz, jint ldz, jobject m, jobject pl, jobject pr, jfloatArray dif, jint offsetdif, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  int __nwantq; int __nwantz; int __nm = 0; float __npl = 0; float __npr = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__na = NULL; float *__nb = NULL; float *__nalphar = NULL; float *__nalphai = NULL; float *__nbeta = NULL; float *__nq = NULL; float *__nz = NULL; float *__ndif = NULL; float *__nwork = NULL; int *__niwork = NULL;
  __nwantq = wantq;
  __nwantz = wantz;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __npl = (*env)->GetFloatField(env, pl, floatW_val_fieldID);
  __npr = (*env)->GetFloatField(env, pr, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalphar = (*env)->GetPrimitiveArrayCritical(env, alphar, NULL))) goto fail;
  if (!(__nalphai = (*env)->GetPrimitiveArrayCritical(env, alphai, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nz = (*env)->GetPrimitiveArrayCritical(env, z, NULL))) goto fail;
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stgsen_(&ijob, &__nwantq, &__nwantz, __nselect + offsetselect, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nalphar + offsetalphar, __nalphai + offsetalphai, __nbeta + offsetbeta, __nq + offsetq, &ldq, __nz + offsetz, &ldz, &__nm, &__npl, &__npr, __ndif + offsetdif, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, failed ? JNI_ABORT : 0);
  if (__nz) (*env)->ReleasePrimitiveArrayCritical(env, z, __nz, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalphai) (*env)->ReleasePrimitiveArrayCritical(env, alphai, __nalphai, failed ? JNI_ABORT : 0);
  if (__nalphar) (*env)->ReleasePrimitiveArrayCritical(env, alphar, __nalphar, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, pr, floatW_val_fieldID, __npr);
  if (!failed) (*env)->SetFloatField(env, pl, floatW_val_fieldID, __npl);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (!failed) wantz = __nwantz;
  if (!failed) wantq = __nwantq;
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgsja_)(const char *jobu, const char *jobv, const char *jobq, int *m, int *p, int *n, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *ncycle, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsjaK(JNIEnv *env, UNUSED jobject obj, jstring jobu, jstring jobv, jstring jobq, jint m, jint p, jint n, jint k, jint l, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloat tola, jfloat tolb, jfloatArray alpha, jint offsetalpha, jfloatArray beta, jint offsetbeta, jfloatArray u, jint offsetu, jint ldu, jfloatArray v, jint offsetv, jint ldv, jfloatArray q, jint offsetq, jint ldq, jfloatArray work, jint offsetwork, jobject ncycle, jobject info) {
  jboolean failed = FALSE;
  const char *__njobu = NULL; const char *__njobv = NULL; const char *__njobq = NULL; int __nncycle = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nalpha = NULL; float *__nbeta = NULL; float *__nu = NULL; float *__nv = NULL; float *__nq = NULL; float *__nwork = NULL;
  if (!(__njobu = (*env)->GetStringUTFChars(env, jobu, NULL))) goto fail;
  if (!(__njobv = (*env)->GetStringUTFChars(env, jobv, NULL))) goto fail;
  if (!(__njobq = (*env)->GetStringUTFChars(env, jobq, NULL))) goto fail;
  __nncycle = (*env)->GetIntField(env, ncycle, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nalpha = (*env)->GetPrimitiveArrayCritical(env, alpha, NULL))) goto fail;
  if (!(__nbeta = (*env)->GetPrimitiveArrayCritical(env, beta, NULL))) goto fail;
  if (!(__nu = (*env)->GetPrimitiveArrayCritical(env, u, NULL))) goto fail;
  if (!(__nv = (*env)->GetPrimitiveArrayCritical(env, v, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  stgsja_(__njobu, __njobv, __njobq, &m, &p, &n, &k, &l, __na + offseta, &lda, __nb + offsetb, &ldb, &tola, &tolb, __nalpha + offsetalpha, __nbeta + offsetbeta, __nu + offsetu, &ldu, __nv + offsetv, &ldv, __nq + offsetq, &ldq, __nwork + offsetwork, &__nncycle, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nv) (*env)->ReleasePrimitiveArrayCritical(env, v, __nv, failed ? JNI_ABORT : 0);
  if (__nu) (*env)->ReleasePrimitiveArrayCritical(env, u, __nu, failed ? JNI_ABORT : 0);
  if (__nbeta) (*env)->ReleasePrimitiveArrayCritical(env, beta, __nbeta, failed ? JNI_ABORT : 0);
  if (__nalpha) (*env)->ReleasePrimitiveArrayCritical(env, alpha, __nalpha, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ncycle, intW_val_fieldID, __nncycle);
  if (__njobq) (*env)->ReleaseStringUTFChars(env, jobq, __njobq);
  if (__njobv) (*env)->ReleaseStringUTFChars(env, jobv, __njobv);
  if (__njobu) (*env)->ReleaseStringUTFChars(env, jobu, __njobu);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgsna_)(const char *job, const char *howmny, int *select, int *n, float *a, int *lda, float *b, int *ldb, float *vl, int *ldvl, float *vr, int *ldvr, float *s, float *dif, int *mm, int *m, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray s, jint offsets, jfloatArray dif, jint offsetdif, jint mm, jobject m, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__na = NULL; float *__nb = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__ns = NULL; float *__ndif = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__ndif = (*env)->GetPrimitiveArrayCritical(env, dif, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stgsna_(__njob, __nhowmny, __nselect + offsetselect, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __ns + offsets, __ndif + offsetdif, &mm, &__nm, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ndif) (*env)->ReleasePrimitiveArrayCritical(env, dif, __ndif, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgsy2_)(const char *trans, int *ijob, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *d, int *ldd, float *e, int *lde, float *f, int *ldf, float *scale, float *rdsum, float *rdscal, int *iwork, int *pq, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsy2K(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jfloatArray d, jint offsetd, jint ldd, jfloatArray e, jint offsete, jint lde, jfloatArray f, jint offsetf, jint ldf, jobject scale, jobject rdsum, jobject rdscal, jintArray iwork, jint offsetiwork, jobject pq, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; float __nscale = 0; float __nrdsum = 0; float __nrdscal = 0; int __npq = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL; float *__nd = NULL; float *__ne = NULL; float *__nf = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __nrdsum = (*env)->GetFloatField(env, rdsum, floatW_val_fieldID);
  __nrdscal = (*env)->GetFloatField(env, rdscal, floatW_val_fieldID);
  __npq = (*env)->GetIntField(env, pq, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stgsy2_(__ntrans, &ijob, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, __nd + offsetd, &ldd, __ne + offsete, &lde, __nf + offsetf, &ldf, &__nscale, &__nrdsum, &__nrdscal, __niwork + offsetiwork, &__npq, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, pq, intW_val_fieldID, __npq);
  if (!failed) (*env)->SetFloatField(env, rdscal, floatW_val_fieldID, __nrdscal);
  if (!failed) (*env)->SetFloatField(env, rdsum, floatW_val_fieldID, __nrdsum);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stgsyl_)(const char *trans, int *ijob, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *d, int *ldd, float *e, int *lde, float *f, int *ldf, float *scale, float *dif, float *work, int *lwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stgsylK(JNIEnv *env, UNUSED jobject obj, jstring trans, jint ijob, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jfloatArray d, jint offsetd, jint ldd, jfloatArray e, jint offsete, jint lde, jfloatArray f, jint offsetf, jint ldf, jobject scale, jobject dif, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrans = NULL; float __nscale = 0; float __ndif = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL; float *__nd = NULL; float *__ne = NULL; float *__nf = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ndif = (*env)->GetFloatField(env, dif, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  if (!(__nd = (*env)->GetPrimitiveArrayCritical(env, d, NULL))) goto fail;
  if (!(__ne = (*env)->GetPrimitiveArrayCritical(env, e, NULL))) goto fail;
  if (!(__nf = (*env)->GetPrimitiveArrayCritical(env, f, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stgsyl_(__ntrans, &ijob, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, __nd + offsetd, &ldd, __ne + offsete, &lde, __nf + offsetf, &ldf, &__nscale, &__ndif, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nf) (*env)->ReleasePrimitiveArrayCritical(env, f, __nf, failed ? JNI_ABORT : 0);
  if (__ne) (*env)->ReleasePrimitiveArrayCritical(env, e, __ne, failed ? JNI_ABORT : 0);
  if (__nd) (*env)->ReleasePrimitiveArrayCritical(env, d, __nd, failed ? JNI_ABORT : 0);
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, dif, floatW_val_fieldID, __ndif);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stpcon_)(const char *norm, const char *uplo, const char *diag, int *n, float *ap, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stpconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float __nrcond = 0; int __ninfo = 0; float *__nap = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stpcon_(__nnorm, __nuplo, __ndiag, &n, __nap + offsetap, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stprfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stprfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__nap = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  stprfs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stptri_)(const char *uplo, const char *diag, int *n, float *ap, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stptriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray ap, jint offsetap, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__nap = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  stptri_(__nuplo, __ndiag, &n, __nap + offsetap, &__ninfo);
done:
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stptrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stptrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray ap, jint offsetap, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__nap = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nap = (*env)->GetPrimitiveArrayCritical(env, ap, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  stptrs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __nap + offsetap, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__nap) (*env)->ReleasePrimitiveArrayCritical(env, ap, __nap, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strcon_)(const char *norm, const char *uplo, const char *diag, int *n, float *a, int *lda, float *rcond, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strconK(JNIEnv *env, UNUSED jobject obj, jstring norm, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject rcond, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nnorm = NULL; const char *__nuplo = NULL; const char *__ndiag = NULL; float __nrcond = 0; int __ninfo = 0; float *__na = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nnorm = (*env)->GetStringUTFChars(env, norm, NULL))) goto fail;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __nrcond = (*env)->GetFloatField(env, rcond, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  strcon_(__nnorm, __nuplo, __ndiag, &n, __na + offseta, &lda, &__nrcond, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, rcond, floatW_val_fieldID, __nrcond);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (__nnorm) (*env)->ReleaseStringUTFChars(env, norm, __nnorm);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strevc_)(const char *side, const char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strevcK(JNIEnv *env, UNUSED jobject obj, jstring side, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jint mm, jobject m, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nside = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__nt = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__nwork = NULL;
  if (!(__nside = (*env)->GetStringUTFChars(env, side, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  strevc_(__nside, __nhowmny, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, &mm, &__nm, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__nside) (*env)->ReleaseStringUTFChars(env, side, __nside);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strexc_)(const char *compq, int *n, float *t, int *ldt, float *q, int *ldq, int *ifst, int *ilst, float *work, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strexcK(JNIEnv *env, UNUSED jobject obj, jstring compq, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jobject ifst, jobject ilst, jfloatArray work, jint offsetwork, jobject info) {
  jboolean failed = FALSE;
  const char *__ncompq = NULL; int __nifst = 0; int __nilst = 0; int __ninfo = 0; float *__nt = NULL; float *__nq = NULL; float *__nwork = NULL;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __nifst = (*env)->GetIntField(env, ifst, intW_val_fieldID);
  __nilst = (*env)->GetIntField(env, ilst, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  strexc_(__ncompq, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, &__nifst, &__nilst, __nwork + offsetwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, ilst, intW_val_fieldID, __nilst);
  if (!failed) (*env)->SetIntField(env, ifst, intW_val_fieldID, __nifst);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strrfs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strrfsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray x, jint offsetx, jint ldx, jfloatArray ferr, jint offsetferr, jfloatArray berr, jint offsetberr, jfloatArray work, jint offsetwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nx = NULL; float *__nferr = NULL; float *__nberr = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nx = (*env)->GetPrimitiveArrayCritical(env, x, NULL))) goto fail;
  if (!(__nferr = (*env)->GetPrimitiveArrayCritical(env, ferr, NULL))) goto fail;
  if (!(__nberr = (*env)->GetPrimitiveArrayCritical(env, berr, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  strrfs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, __nx + offsetx, &ldx, __nferr + offsetferr, __nberr + offsetberr, __nwork + offsetwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nberr) (*env)->ReleasePrimitiveArrayCritical(env, berr, __nberr, failed ? JNI_ABORT : 0);
  if (__nferr) (*env)->ReleasePrimitiveArrayCritical(env, ferr, __nferr, failed ? JNI_ABORT : 0);
  if (__nx) (*env)->ReleasePrimitiveArrayCritical(env, x, __nx, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strsen_)(const char *job, const char *compq, int *select, int *n, float *t, int *ldt, float *q, int *ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int *lwork, int *iwork, int *liwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsenK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring compq, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray q, jint offsetq, jint ldq, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jobject m, jobject s, jobject sep, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__ncompq = NULL; int __nm = 0; float __ns = 0; float __nsep = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__nt = NULL; float *__nq = NULL; float *__nwr = NULL; float *__nwi = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__ncompq = (*env)->GetStringUTFChars(env, compq, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ns = (*env)->GetFloatField(env, s, floatW_val_fieldID);
  __nsep = (*env)->GetFloatField(env, sep, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nq = (*env)->GetPrimitiveArrayCritical(env, q, NULL))) goto fail;
  if (!(__nwr = (*env)->GetPrimitiveArrayCritical(env, wr, NULL))) goto fail;
  if (!(__nwi = (*env)->GetPrimitiveArrayCritical(env, wi, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  strsen_(__njob, __ncompq, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nq + offsetq, &ldq, __nwr + offsetwr, __nwi + offsetwi, &__nm, &__ns, &__nsep, __nwork + offsetwork, &lwork, __niwork + offsetiwork, &liwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nwi) (*env)->ReleasePrimitiveArrayCritical(env, wi, __nwi, failed ? JNI_ABORT : 0);
  if (__nwr) (*env)->ReleasePrimitiveArrayCritical(env, wr, __nwr, failed ? JNI_ABORT : 0);
  if (__nq) (*env)->ReleasePrimitiveArrayCritical(env, q, __nq, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, sep, floatW_val_fieldID, __nsep);
  if (!failed) (*env)->SetFloatField(env, s, floatW_val_fieldID, __ns);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__ncompq) (*env)->ReleaseStringUTFChars(env, compq, __ncompq);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strsna_)(const char *job, const char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, float *s, float *sep, int *mm, int *m, float *work, int *ldwork, int *iwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsnaK(JNIEnv *env, UNUSED jobject obj, jstring job, jstring howmny, jbooleanArray select, jint offsetselect, jint n, jfloatArray t, jint offsett, jint ldt, jfloatArray vl, jint offsetvl, jint ldvl, jfloatArray vr, jint offsetvr, jint ldvr, jfloatArray s, jint offsets, jfloatArray sep, jint offsetsep, jint mm, jobject m, jfloatArray work, jint offsetwork, jint ldwork, jintArray iwork, jint offsetiwork, jobject info) {
  jboolean failed = FALSE;
  const char *__njob = NULL; const char *__nhowmny = NULL; int __nm = 0; int __ninfo = 0; jboolean *__jselect = NULL; int *__nselect = NULL; float *__nt = NULL; float *__nvl = NULL; float *__nvr = NULL; float *__ns = NULL; float *__nsep = NULL; float *__nwork = NULL; int *__niwork = NULL;
  if (!(__njob = (*env)->GetStringUTFChars(env, job, NULL))) goto fail;
  if (!(__nhowmny = (*env)->GetStringUTFChars(env, howmny, NULL))) goto fail;
  __nm = (*env)->GetIntField(env, m, intW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__jselect = (*env)->GetPrimitiveArrayCritical(env, select, NULL))) { goto fail; } do { int length = (*env)->GetArrayLength(env, select); if (length <= 0) goto fail; if (!(__nselect = malloc(sizeof(jboolean) * length))) goto fail; for (int i = 0; i < length; i++) { __nselect[i] = __jselect[i]; } } while(0);
  if (!(__nt = (*env)->GetPrimitiveArrayCritical(env, t, NULL))) goto fail;
  if (!(__nvl = (*env)->GetPrimitiveArrayCritical(env, vl, NULL))) goto fail;
  if (!(__nvr = (*env)->GetPrimitiveArrayCritical(env, vr, NULL))) goto fail;
  if (!(__ns = (*env)->GetPrimitiveArrayCritical(env, s, NULL))) goto fail;
  if (!(__nsep = (*env)->GetPrimitiveArrayCritical(env, sep, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  if (!(__niwork = (*env)->GetPrimitiveArrayCritical(env, iwork, NULL))) goto fail;
  strsna_(__njob, __nhowmny, __nselect + offsetselect, &n, __nt + offsett, &ldt, __nvl + offsetvl, &ldvl, __nvr + offsetvr, &ldvr, __ns + offsets, __nsep + offsetsep, &mm, &__nm, __nwork + offsetwork, &ldwork, __niwork + offsetiwork, &__ninfo);
done:
  if (__niwork) (*env)->ReleasePrimitiveArrayCritical(env, iwork, __niwork, failed ? JNI_ABORT : 0);
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__nsep) (*env)->ReleasePrimitiveArrayCritical(env, sep, __nsep, failed ? JNI_ABORT : 0);
  if (__ns) (*env)->ReleasePrimitiveArrayCritical(env, s, __ns, failed ? JNI_ABORT : 0);
  if (__nvr) (*env)->ReleasePrimitiveArrayCritical(env, vr, __nvr, failed ? JNI_ABORT : 0);
  if (__nvl) (*env)->ReleasePrimitiveArrayCritical(env, vl, __nvl, failed ? JNI_ABORT : 0);
  if (__nt) (*env)->ReleasePrimitiveArrayCritical(env, t, __nt, failed ? JNI_ABORT : 0);
  if (__nselect) { free(__nselect); } if (__jselect) (*env)->ReleasePrimitiveArrayCritical(env, select, __nselect, JNI_ABORT);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetIntField(env, m, intW_val_fieldID, __nm);
  if (__nhowmny) (*env)->ReleaseStringUTFChars(env, howmny, __nhowmny);
  if (__njob) (*env)->ReleaseStringUTFChars(env, job, __njob);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strsyl_)(const char *trana, const char *tranb, int *isgn, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *Ldc, float *scale, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strsylK(JNIEnv *env, UNUSED jobject obj, jstring trana, jstring tranb, jint isgn, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jfloatArray c, jint offsetc, jint Ldc, jobject scale, jobject info) {
  jboolean failed = FALSE;
  const char *__ntrana = NULL; const char *__ntranb = NULL; float __nscale = 0; int __ninfo = 0; float *__na = NULL; float *__nb = NULL; float *__nc = NULL;
  if (!(__ntrana = (*env)->GetStringUTFChars(env, trana, NULL))) goto fail;
  if (!(__ntranb = (*env)->GetStringUTFChars(env, tranb, NULL))) goto fail;
  __nscale = (*env)->GetFloatField(env, scale, floatW_val_fieldID);
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  if (!(__nc = (*env)->GetPrimitiveArrayCritical(env, c, NULL))) goto fail;
  strsyl_(__ntrana, __ntranb, &isgn, &m, &n, __na + offseta, &lda, __nb + offsetb, &ldb, __nc + offsetc, &Ldc, &__nscale, &__ninfo);
done:
  if (__nc) (*env)->ReleasePrimitiveArrayCritical(env, c, __nc, failed ? JNI_ABORT : 0);
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (!failed) (*env)->SetFloatField(env, scale, floatW_val_fieldID, __nscale);
  if (__ntranb) (*env)->ReleaseStringUTFChars(env, tranb, __ntranb);
  if (__ntrana) (*env)->ReleaseStringUTFChars(env, trana, __ntrana);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strti2_)(const char *uplo, const char *diag, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strti2K(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  strti2_(__nuplo, __ndiag, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strtri_)(const char *uplo, const char *diag, int *n, float *a, int *lda, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strtriK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring diag, jint n, jfloatArray a, jint offseta, jint lda, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__na = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  strtri_(__nuplo, __ndiag, &n, __na + offseta, &lda, &__ninfo);
done:
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*strtrs_)(const char *uplo, const char *trans, const char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_strtrsK(JNIEnv *env, UNUSED jobject obj, jstring uplo, jstring trans, jstring diag, jint n, jint nrhs, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject info) {
  jboolean failed = FALSE;
  const char *__nuplo = NULL; const char *__ntrans = NULL; const char *__ndiag = NULL; int __ninfo = 0; float *__na = NULL; float *__nb = NULL;
  if (!(__nuplo = (*env)->GetStringUTFChars(env, uplo, NULL))) goto fail;
  if (!(__ntrans = (*env)->GetStringUTFChars(env, trans, NULL))) goto fail;
  if (!(__ndiag = (*env)->GetStringUTFChars(env, diag, NULL))) goto fail;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__nb = (*env)->GetPrimitiveArrayCritical(env, b, NULL))) goto fail;
  strtrs_(__nuplo, __ntrans, __ndiag, &n, &nrhs, __na + offseta, &lda, __nb + offsetb, &ldb, &__ninfo);
done:
  if (__nb) (*env)->ReleasePrimitiveArrayCritical(env, b, __nb, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (__ndiag) (*env)->ReleaseStringUTFChars(env, diag, __ndiag);
  if (__ntrans) (*env)->ReleaseStringUTFChars(env, trans, __ntrans);
  if (__nuplo) (*env)->ReleaseStringUTFChars(env, uplo, __nuplo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stzrqf_)(int *m, int *n, float *a, int *lda, float *tau, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stzrqfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  stzrqf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, &__ninfo);
done:
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static void (*stzrzf_)(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_stzrzfK(JNIEnv *env, UNUSED jobject obj, jint m, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray tau, jint offsettau, jfloatArray work, jint offsetwork, jint lwork, jobject info) {
  jboolean failed = FALSE;
  int __ninfo = 0; float *__na = NULL; float *__ntau = NULL; float *__nwork = NULL;
  __ninfo = (*env)->GetIntField(env, info, intW_val_fieldID);
  if (!(__na = (*env)->GetPrimitiveArrayCritical(env, a, NULL))) goto fail;
  if (!(__ntau = (*env)->GetPrimitiveArrayCritical(env, tau, NULL))) goto fail;
  if (!(__nwork = (*env)->GetPrimitiveArrayCritical(env, work, NULL))) goto fail;
  stzrzf_(&m, &n, __na + offseta, &lda, __ntau + offsettau, __nwork + offsetwork, &lwork, &__ninfo);
done:
  if (__nwork) (*env)->ReleasePrimitiveArrayCritical(env, work, __nwork, failed ? JNI_ABORT : 0);
  if (__ntau) (*env)->ReleasePrimitiveArrayCritical(env, tau, __ntau, failed ? JNI_ABORT : 0);
  if (__na) (*env)->ReleasePrimitiveArrayCritical(env, a, __na, failed ? JNI_ABORT : 0);
  if (!failed) (*env)->SetIntField(env, info, intW_val_fieldID, __ninfo);
  if (failed) throwOOM(env);
  return;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlamch_)(const char *cmach);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamchK(JNIEnv *env, UNUSED jobject obj, jstring cmach) {
  jdouble __ret;
  jboolean failed = FALSE;
  const char *__ncmach = NULL;
  if (!(__ncmach = (*env)->GetStringUTFChars(env, cmach, NULL))) goto fail;
  __ret = dlamch_(__ncmach);
done:
  if (__ncmach) (*env)->ReleaseStringUTFChars(env, cmach, __ncmach);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dlamc3_)(double *a, double *b);

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc3K(JNIEnv *env, UNUSED jobject obj, jdouble a, jdouble b) {
  jdouble __ret;
  jboolean failed = FALSE;
  

  __ret = dlamc3_(&a, &b);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static double (*dsecnd_)();

jdouble Java_dev_ludovic_netlib_lapack_JNILAPACK_dsecndK(JNIEnv *env, UNUSED jobject obj) {
  jdouble __ret;
  jboolean failed = FALSE;

  __ret = dsecnd_();
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static int (*lsame_)(const char *ca, const char *cb);

jboolean Java_dev_ludovic_netlib_lapack_JNILAPACK_lsameK(JNIEnv *env, UNUSED jobject obj, jstring ca, jstring cb) {
  jboolean __ret;
  jboolean failed = FALSE;
  const char *__nca = NULL; const char *__ncb = NULL;
  if (!(__nca = (*env)->GetStringUTFChars(env, ca, NULL))) goto fail;
  if (!(__ncb = (*env)->GetStringUTFChars(env, cb, NULL))) goto fail;
  __ret = lsame_(__nca, __ncb);
done:
  if (__ncb) (*env)->ReleaseStringUTFChars(env, cb, __ncb);
  if (__nca) (*env)->ReleaseStringUTFChars(env, ca, __nca);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*second_)();

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_secondK(JNIEnv *env, UNUSED jobject obj) {
  jfloat __ret;
  jboolean failed = FALSE;

  __ret = second_();
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slamch_)(const char *cmach);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slamchK(JNIEnv *env, UNUSED jobject obj, jstring cmach) {
  jfloat __ret;
  jboolean failed = FALSE;
  const char *__ncmach = NULL;
  if (!(__ncmach = (*env)->GetStringUTFChars(env, cmach, NULL))) goto fail;
  __ret = slamch_(__ncmach);
done:
  if (__ncmach) (*env)->ReleaseStringUTFChars(env, cmach, __ncmach);
  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

static float (*slamc3_)(float *a, float *b);

jfloat Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc3K(JNIEnv *env, UNUSED jobject obj, jfloat a, jfloat b) {
  jfloat __ret;
  jboolean failed = FALSE;
  

  __ret = slamc3_(&a, &b);
done:

  if (failed) throwOOM(env);
  return __ret;
fail:
  failed = TRUE;
  goto done;
}

// static void (*dgges_)(char *jobvsl, char *jobvsr, char *sort, /*FIXME*/void *selctg, int *n, double *a, int *lda, double *b, int *ldb, /*FIXME*/void *sdim, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *work, int *lwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggesK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvsl, jstring jobvsr, jstring sort, jobject selctg, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject sdim, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vsl, jint offsetvsl, jint ldvsl, jdoubleArray vsr, jint offsetvsr, jint ldvsr, jdoubleArray work, jint offsetwork, jint lwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dggesx_)(char *jobvsl, char *jobvsr, char *sort, /*FIXME*/void *selctg, char *sense, int *n, double *a, int *lda, double *b, int *ldb, /*FIXME*/void *sdim, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *rconde, double *rcondv, double *work, int *lwork, int * iwork, int *liwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dggesxK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvsl, jstring jobvsr, jstring sort, jobject selctg, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jdoubleArray b, jint offsetb, jint ldb, jobject sdim, jdoubleArray alphar, jint offsetalphar, jdoubleArray alphai, jint offsetalphai, jdoubleArray beta, jint offsetbeta, jdoubleArray vsl, jint offsetvsl, jint ldvsl, jdoubleArray vsr, jint offsetvsr, jint ldvsr, jdoubleArray rconde, jint offsetrconde, jdoubleArray rcondv, jint offsetrcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sgges_)(char *jobvsl, char *jobvsr, char *sort, /*FIXME*/void *selctg, int *n, float *a, int *lda, float *b, int *ldb, /*FIXME*/void *sdim, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *work, int *lwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggesK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvsl, jstring jobvsr, jstring sort, jobject selctg, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject sdim, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vsl, jint offsetvsl, jint ldvsl, jfloatArray vsr, jint offsetvsr, jint ldvsr, jfloatArray work, jint offsetwork, jint lwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sggesx_)(char *jobvsl, char *jobvsr, char *sort, /*FIXME*/void *selctg, char *sense, int *n, float *a, int *lda, float *b, int *ldb, /*FIXME*/void *sdim, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *rconde, float *rcondv, float *work, int *lwork, int * iwork, int *liwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sggesxK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvsl, jstring jobvsr, jstring sort, jobject selctg, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jfloatArray b, jint offsetb, jint ldb, jobject sdim, jfloatArray alphar, jint offsetalphar, jfloatArray alphai, jint offsetalphai, jfloatArray beta, jint offsetbeta, jfloatArray vsl, jint offsetvsl, jint ldvsl, jfloatArray vsr, jint offsetvsr, jint ldvsr, jfloatArray rconde, jint offsetrconde, jfloatArray rcondv, jint offsetrcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sgees_)(char *jobvs, char *sort, /*FIXME*/void *select, int *n, float *a, int *lda, /*FIXME*/void *sdim, float *wr, float *wi, float *vs, int *ldvs, float *work, int *lwork, int *bwork, int *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeesK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvs, jstring sort, jobject select, jint n, jfloatArray a, jint offseta, jint lda, jobject sdim, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vs, jint offsetvs, jint ldvs, jfloatArray work, jint offsetwork, jint lwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*sgeesx_)(char *jobvs, char *sort, /*FIXME*/void *select, char *sense, int *n, float *a, int *lda, /*FIXME*/void *sdim, float *wr, float *wi, float *vs, int *ldvs, /*FIXME*/void *rconde, /*FIXME*/void *rcondv, float *work, int *lwork, int * iwork, int *liwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_sgeesxK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvs, jstring sort, jobject select, jstring sense, jint n, jfloatArray a, jint offseta, jint lda, jobject sdim, jfloatArray wr, jint offsetwr, jfloatArray wi, jint offsetwi, jfloatArray vs, jint offsetvs, jint ldvs, jobject rconde, jobject rcondv, jfloatArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dgees_)(char *jobvs, char *sort, /*FIXME*/void *select, int *n, double *a, int *lda, /*FIXME*/void *sdim, double *wr, double *wi, double *vs, int *ldvs, double *work, int *lwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeesK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvs, jstring sort, jobject select, jint n, jdoubleArray a, jint offseta, jint lda, jobject sdim, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vs, jint offsetvs, jint ldvs, jdoubleArray work, jint offsetwork, jint lwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dgeesx_)(char *jobvs, char *sort, /*FIXME*/void *select, char *sense, int *n, double *a, int *lda, /*FIXME*/void *sdim, double *wr, double *wi, double *vs, int *ldvs, /*FIXME*/void *rconde, /*FIXME*/void *rcondv, double *work, int *lwork, int * iwork, int *liwork, int *bwork, /*FIXME*/void *info);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dgeesxK(JNIEnv *env, UNUSED jobject obj,
    jstring jobvs, jstring sort, jobject select, jstring sense, jint n, jdoubleArray a, jint offseta, jint lda, jobject sdim, jdoubleArray wr, jint offsetwr, jdoubleArray wi, jint offsetwi, jdoubleArray vs, jint offsetvs, jint ldvs, jobject rconde, jobject rcondv, jdoubleArray work, jint offsetwork, jint lwork, jintArray iwork, jint offsetiwork, jint liwork, jbooleanArray bwork, jint offsetbwork, jobject info) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

// static void (*dlazq3_)(int *i0, /*FIXME*/void *n0, double *z, int *pp, /*FIXME*/void *dmin, /*FIXME*/void *sigma, /*FIXME*/void *desig, /*FIXME*/void *qmax, /*FIXME*/void *nfail, /*FIXME*/void *iter, /*FIXME*/void *ndiv, int *ieee, /*FIXME*/void *ttype, /*FIXME*/void *dmin1, /*FIXME*/void *dmin2, /*FIXME*/void *dn, /*FIXME*/void *dn1, /*FIXME*/void *dn2, /*FIXME*/void *tau);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlazq3K(JNIEnv *env, UNUSED jobject obj,
    jint i0, jobject n0, jdoubleArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee, jobject ttype, jobject dmin1, jobject dmin2, jobject dn, jobject dn1, jobject dn2, jobject tau) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dlazq4_)(int *i0, int *n0, double *z, int *pp, int *n0in, double *dmin, double *dmin1, double *dmin2, double *dn, double *dn1, double *dn2, /*FIXME*/void *tau, /*FIXME*/void *ttype, /*FIXME*/void *g);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlazq4K(JNIEnv *env, UNUSED jobject obj,
    jint i0, jint n0, jdoubleArray z, jint offsetz, jint pp, jint n0in, jdouble dmin, jdouble dmin1, jdouble dmin2, jdouble dn, jdouble dn1, jdouble dn2, jobject tau, jobject ttype, jobject g) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slazq3_)(int *i0, /*FIXME*/void *n0, float *z, int *pp, /*FIXME*/void *dmin, /*FIXME*/void *sigma, /*FIXME*/void *desig, /*FIXME*/void *qmax, /*FIXME*/void *nfail, /*FIXME*/void *iter, /*FIXME*/void *ndiv, int *ieee, /*FIXME*/void *ttype, /*FIXME*/void *dmin1, /*FIXME*/void *dmin2, /*FIXME*/void *dn, /*FIXME*/void *dn1, /*FIXME*/void *dn2, /*FIXME*/void *tau);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slazq3K(JNIEnv *env, UNUSED jobject obj,
    jint i0, jobject n0, jfloatArray z, jint offsetz, jint pp, jobject dmin, jobject sigma, jobject desig, jobject qmax, jobject nfail, jobject iter, jobject ndiv, jboolean ieee, jobject ttype, jobject dmin1, jobject dmin2, jobject dn, jobject dn1, jobject dn2, jobject tau) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slazq4_)(int *i0, int *n0, float *z, int *pp, int *n0in, float *dmin, float *dmin1, float *dmin2, float *dn, float *dn1, float *dn2, /*FIXME*/void *tau, /*FIXME*/void *ttype, /*FIXME*/void *g);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slazq4K(JNIEnv *env, UNUSED jobject obj,
    jint i0, jint n0, jfloatArray z, jint offsetz, jint pp, jint n0in, jfloat dmin, jfloat dmin1, jfloat dmin2, jfloat dn, jfloat dn1, jfloat dn2, jobject tau, jobject ttype, jobject g) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dlamc1_)(/*FIXME*/void *beta, /*FIXME*/void *t, /*FIXME*/void *rnd, /*FIXME*/void *ieee1);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc1K(JNIEnv *env, UNUSED jobject obj,
    jobject beta, jobject t, jobject rnd, jobject ieee1) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dlamc2_)(/*FIXME*/void *beta, /*FIXME*/void *t, /*FIXME*/void *rnd, /*FIXME*/void *eps, /*FIXME*/void *emin, /*FIXME*/void *rmin, /*FIXME*/void *emax, /*FIXME*/void *rmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc2K(JNIEnv *env, UNUSED jobject obj,
    jobject beta, jobject t, jobject rnd, jobject eps, jobject emin, jobject rmin, jobject emax, jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dlamc4_)(/*FIXME*/void *emin, double *start, int *base);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc4K(JNIEnv *env, UNUSED jobject obj,
    jobject emin, jdouble start, jint base) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*dlamc5_)(int *beta, int *p, int *emin, int *ieee, /*FIXME*/void *emax, /*FIXME*/void *rmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_dlamc5K(JNIEnv *env, UNUSED jobject obj,
    jint beta, jint p, jint emin, jboolean ieee, jobject emax, jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slamc1_)(/*FIXME*/void *beta, /*FIXME*/void *t, /*FIXME*/void *rnd, /*FIXME*/void *ieee1);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc1K(JNIEnv *env, UNUSED jobject obj,
    jobject beta, jobject t, jobject rnd, jobject ieee1) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slamc2_)(/*FIXME*/void *beta, /*FIXME*/void *t, /*FIXME*/void *rnd, /*FIXME*/void *eps, /*FIXME*/void *emin, /*FIXME*/void *rmin, /*FIXME*/void *emax, /*FIXME*/void *rmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc2K(JNIEnv *env, UNUSED jobject obj,
    jobject beta, jobject t, jobject rnd, jobject eps, jobject emin, jobject rmin, jobject emax, jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slamc4_)(/*FIXME*/void *emin, float *start, int *base);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc4K(JNIEnv *env, UNUSED jobject obj,
    jobject emin, jfloat start, jint base) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}


// static void (*slamc5_)(int *beta, int *p, int *emin, int *ieee, /*FIXME*/void *emax, /*FIXME*/void *rmax);

void Java_dev_ludovic_netlib_lapack_JNILAPACK_slamc5K(JNIEnv *env, UNUSED jobject obj,
    jint beta, jint p, jint emin, jboolean ieee, jobject emax, jobject rmax) {
  (*env)->ThrowNew(env, (*env)->FindClass(env, "java/lang/UnsupportedOperationException"), "not implemented");
}

jboolean get_system_property(JNIEnv *env, jstring key, jstring def, jstring *res) {
  jclass System_class = (*env)->FindClass(env, "java/lang/System");
  if (!System_class) {
    return FALSE;
  }
  jmethodID System_getProperty_methodID = (*env)->GetStaticMethodID(env, System_class, "getProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
  if (!System_getProperty_methodID) {
    return FALSE;
  }
  *res = (jstring)(*env)->CallStaticObjectMethod(env, System_class, System_getProperty_methodID, key, def);
  return TRUE;
}

jint JNI_OnLoad(JavaVM *vm, UNUSED void *reserved) {
  JNIEnv *env;
  if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {
    return -1;
  }

  jclass booleanW_class = (*env)->FindClass(env, "org/netlib/util/booleanW");
  if (!booleanW_class) {
    return -1;
  }
  booleanW_val_fieldID = (*env)->GetFieldID(env, booleanW_class, "val", "Z");
  if (!booleanW_val_fieldID) {
    return -1;
  }

  jclass intW_class = (*env)->FindClass(env, "org/netlib/util/intW");
  if (!intW_class) {
    return -1;
  }
  intW_val_fieldID = (*env)->GetFieldID(env, intW_class, "val", "I");
  if (!intW_val_fieldID) {
    return -1;
  }

  jclass floatW_class = (*env)->FindClass(env, "org/netlib/util/floatW");
  if (!floatW_class) {
    return -1;
  }
  floatW_val_fieldID = (*env)->GetFieldID(env, floatW_class, "val", "F");
  if (!floatW_val_fieldID) {
    return -1;
  }

  jclass doubleW_class = (*env)->FindClass(env, "org/netlib/util/doubleW");
  if (!doubleW_class) {
    return -1;
  }
  doubleW_val_fieldID = (*env)->GetFieldID(env, doubleW_class, "val", "D");
  if (!doubleW_val_fieldID) {
    return -1;
  }

  jclass StringW_class = (*env)->FindClass(env, "org/netlib/util/StringW");
  if (!StringW_class) {
    return -1;
  }
  StringW_val_fieldID = (*env)->GetFieldID(env, StringW_class, "val", "Ljava/lang/String;");
  if (!StringW_val_fieldID) {
    return -1;
  }

  jstring property_nativeLibPath;
  if (!get_system_property(env, (*env)->NewStringUTF(env, "dev.ludovic.netlib.lapack.nativeLibPath"), NULL, &property_nativeLibPath)) {
    return -1;
  }
  jstring property_nativeLib;
  if (!get_system_property(env, (*env)->NewStringUTF(env, "dev.ludovic.netlib.lapack.nativeLib"), (*env)->NewStringUTF(env, "lapack"), &property_nativeLib)) {
    return -1;
  }

  char lapack_name[1024];
  if (property_nativeLibPath) {
    const char *utf = (*env)->GetStringUTFChars(env, property_nativeLibPath, NULL);
    snprintf(lapack_name, sizeof(lapack_name), "%s", utf);
    (*env)->ReleaseStringUTFChars(env, property_nativeLibPath, utf);
  } else if (property_nativeLib) {
    const char *utf = (*env)->GetStringUTFChars(env, property_nativeLib, NULL);
    snprintf(lapack_name, sizeof(lapack_name), "lib%s.so", utf);
    (*env)->ReleaseStringUTFChars(env, property_nativeLib, utf);
  } else {
    /* either property_nativeLibPath or property_nativeLib should always be non-NULL */
    return -1;
  }

  lapack = dlopen(lapack_name, RTLD_LAZY);
  if (!lapack) {
    return -1;
  }

#define LOAD_SYMBOL(name) \
  name = dlsym(lapack, #name); \
  if (!name) { \
    return -1; \
  }

  LOAD_SYMBOL(dbdsdc_)
  LOAD_SYMBOL(dbdsqr_)
  LOAD_SYMBOL(ddisna_)
  LOAD_SYMBOL(dgbbrd_)
  LOAD_SYMBOL(dgbcon_)
  LOAD_SYMBOL(dgbequ_)
  LOAD_SYMBOL(dgbrfs_)
  LOAD_SYMBOL(dgbsvx_)
  LOAD_SYMBOL(dgbsv_)
  LOAD_SYMBOL(dgbtrf_)
  LOAD_SYMBOL(dgbtf2_)
  LOAD_SYMBOL(dgebak_)
  LOAD_SYMBOL(dgbtrs_)
  LOAD_SYMBOL(dgebd2_)
  LOAD_SYMBOL(dgebal_)
  LOAD_SYMBOL(dgecon_)
  LOAD_SYMBOL(dgebrd_)
  // LOAD_SYMBOL(dgees_)
  LOAD_SYMBOL(dgeequ_)
  LOAD_SYMBOL(dgeev_)
  // LOAD_SYMBOL(dgeesx_)
  LOAD_SYMBOL(dgegs_)
  LOAD_SYMBOL(dgeevx_)
  LOAD_SYMBOL(dgehd2_)
  LOAD_SYMBOL(dgegv_)
  LOAD_SYMBOL(dgelq2_)
  LOAD_SYMBOL(dgehrd_)
  LOAD_SYMBOL(dgels_)
  LOAD_SYMBOL(dgelqf_)
  LOAD_SYMBOL(dgelss_)
  LOAD_SYMBOL(dgelsd_)
  LOAD_SYMBOL(dgelsy_)
  LOAD_SYMBOL(dgelsx_)
  LOAD_SYMBOL(dgeqlf_)
  LOAD_SYMBOL(dgeql2_)
  LOAD_SYMBOL(dgeqpf_)
  LOAD_SYMBOL(dgeqp3_)
  LOAD_SYMBOL(dgeqrf_)
  LOAD_SYMBOL(dgeqr2_)
  LOAD_SYMBOL(dgerq2_)
  LOAD_SYMBOL(dgerfs_)
  LOAD_SYMBOL(dgesc2_)
  LOAD_SYMBOL(dgerqf_)
  LOAD_SYMBOL(dgesv_)
  LOAD_SYMBOL(dgesdd_)
  LOAD_SYMBOL(dgesvx_)
  LOAD_SYMBOL(dgesvd_)
  LOAD_SYMBOL(dgetf2_)
  LOAD_SYMBOL(dgetc2_)
  LOAD_SYMBOL(dgetri_)
  LOAD_SYMBOL(dgetrf_)
  LOAD_SYMBOL(dggbak_)
  LOAD_SYMBOL(dgetrs_)
  // LOAD_SYMBOL(dgges_)
  LOAD_SYMBOL(dggbal_)
  LOAD_SYMBOL(dggev_)
  // LOAD_SYMBOL(dggesx_)
  LOAD_SYMBOL(dggglm_)
  LOAD_SYMBOL(dggevx_)
  LOAD_SYMBOL(dgglse_)
  LOAD_SYMBOL(dgghrd_)
  LOAD_SYMBOL(dggrqf_)
  LOAD_SYMBOL(dggqrf_)
  LOAD_SYMBOL(dggsvp_)
  LOAD_SYMBOL(dggsvd_)
  LOAD_SYMBOL(dgtrfs_)
  LOAD_SYMBOL(dgtcon_)
  LOAD_SYMBOL(dgtsvx_)
  LOAD_SYMBOL(dgtsv_)
  LOAD_SYMBOL(dgttrs_)
  LOAD_SYMBOL(dgttrf_)
  LOAD_SYMBOL(dhgeqz_)
  LOAD_SYMBOL(dgtts2_)
  LOAD_SYMBOL(dhseqr_)
  LOAD_SYMBOL(dhsein_)
  LOAD_SYMBOL(dlabad_)
  LOAD_SYMBOL(disnan_)
  LOAD_SYMBOL(dlacn2_)
  LOAD_SYMBOL(dlabrd_)
  LOAD_SYMBOL(dlacpy_)
  LOAD_SYMBOL(dlacon_)
  LOAD_SYMBOL(dlae2_)
  LOAD_SYMBOL(dladiv_)
  LOAD_SYMBOL(dlaed0_)
  LOAD_SYMBOL(dlaebz_)
  LOAD_SYMBOL(dlaed2_)
  LOAD_SYMBOL(dlaed1_)
  LOAD_SYMBOL(dlaed4_)
  LOAD_SYMBOL(dlaed3_)
  LOAD_SYMBOL(dlaed6_)
  LOAD_SYMBOL(dlaed5_)
  LOAD_SYMBOL(dlaed8_)
  LOAD_SYMBOL(dlaed7_)
  LOAD_SYMBOL(dlaeda_)
  LOAD_SYMBOL(dlaed9_)
  LOAD_SYMBOL(dlaev2_)
  LOAD_SYMBOL(dlaein_)
  LOAD_SYMBOL(dlag2_)
  LOAD_SYMBOL(dlaexc_)
  LOAD_SYMBOL(dlags2_)
  LOAD_SYMBOL(dlag2s_)
  LOAD_SYMBOL(dlagtm_)
  LOAD_SYMBOL(dlagtf_)
  LOAD_SYMBOL(dlagv2_)
  LOAD_SYMBOL(dlagts_)
  LOAD_SYMBOL(dlahr2_)
  LOAD_SYMBOL(dlahqr_)
  LOAD_SYMBOL(dlaic1_)
  LOAD_SYMBOL(dlahrd_)
  LOAD_SYMBOL(dlaln2_)
  LOAD_SYMBOL(dlaisnan_)
  LOAD_SYMBOL(dlalsa_)
  LOAD_SYMBOL(dlals0_)
  LOAD_SYMBOL(dlamrg_)
  LOAD_SYMBOL(dlalsd_)
  LOAD_SYMBOL(dlangb_)
  LOAD_SYMBOL(dlaneg_)
  LOAD_SYMBOL(dlangt_)
  LOAD_SYMBOL(dlange_)
  LOAD_SYMBOL(dlansb_)
  LOAD_SYMBOL(dlanhs_)
  LOAD_SYMBOL(dlanst_)
  LOAD_SYMBOL(dlansp_)
  LOAD_SYMBOL(dlantb_)
  LOAD_SYMBOL(dlansy_)
  LOAD_SYMBOL(dlantr_)
  LOAD_SYMBOL(dlantp_)
  LOAD_SYMBOL(dlapll_)
  LOAD_SYMBOL(dlanv2_)
  LOAD_SYMBOL(dlapy2_)
  LOAD_SYMBOL(dlapmt_)
  LOAD_SYMBOL(dlaqgb_)
  LOAD_SYMBOL(dlapy3_)
  LOAD_SYMBOL(dlaqp2_)
  LOAD_SYMBOL(dlaqge_)
  LOAD_SYMBOL(dlaqr0_)
  LOAD_SYMBOL(dlaqps_)
  LOAD_SYMBOL(dlaqr2_)
  LOAD_SYMBOL(dlaqr1_)
  LOAD_SYMBOL(dlaqr4_)
  LOAD_SYMBOL(dlaqr3_)
  LOAD_SYMBOL(dlaqsb_)
  LOAD_SYMBOL(dlaqr5_)
  LOAD_SYMBOL(dlaqsy_)
  LOAD_SYMBOL(dlaqsp_)
  LOAD_SYMBOL(dlar1v_)
  LOAD_SYMBOL(dlaqtr_)
  LOAD_SYMBOL(dlarf_)
  LOAD_SYMBOL(dlar2v_)
  LOAD_SYMBOL(dlarfg_)
  LOAD_SYMBOL(dlarfb_)
  LOAD_SYMBOL(dlarfx_)
  LOAD_SYMBOL(dlarft_)
  LOAD_SYMBOL(dlarnv_)
  LOAD_SYMBOL(dlargv_)
  LOAD_SYMBOL(dlarrb_)
  LOAD_SYMBOL(dlarra_)
  LOAD_SYMBOL(dlarrd_)
  LOAD_SYMBOL(dlarrc_)
  LOAD_SYMBOL(dlarrf_)
  LOAD_SYMBOL(dlarre_)
  LOAD_SYMBOL(dlarrk_)
  LOAD_SYMBOL(dlarrj_)
  LOAD_SYMBOL(dlarrv_)
  LOAD_SYMBOL(dlarrr_)
  LOAD_SYMBOL(dlartv_)
  LOAD_SYMBOL(dlartg_)
  LOAD_SYMBOL(dlarz_)
  LOAD_SYMBOL(dlaruv_)
  LOAD_SYMBOL(dlarzt_)
  LOAD_SYMBOL(dlarzb_)
  LOAD_SYMBOL(dlascl_)
  LOAD_SYMBOL(dlas2_)
  LOAD_SYMBOL(dlasd1_)
  LOAD_SYMBOL(dlasd0_)
  LOAD_SYMBOL(dlasd3_)
  LOAD_SYMBOL(dlasd2_)
  LOAD_SYMBOL(dlasd5_)
  LOAD_SYMBOL(dlasd4_)
  LOAD_SYMBOL(dlasd7_)
  LOAD_SYMBOL(dlasd6_)
  LOAD_SYMBOL(dlasda_)
  LOAD_SYMBOL(dlasd8_)
  LOAD_SYMBOL(dlasdt_)
  LOAD_SYMBOL(dlasdq_)
  LOAD_SYMBOL(dlasq1_)
  LOAD_SYMBOL(dlaset_)
  LOAD_SYMBOL(dlasq3_)
  LOAD_SYMBOL(dlasq2_)
  LOAD_SYMBOL(dlasq5_)
  LOAD_SYMBOL(dlasq4_)
  LOAD_SYMBOL(dlasr_)
  LOAD_SYMBOL(dlasq6_)
  LOAD_SYMBOL(dlassq_)
  LOAD_SYMBOL(dlasrt_)
  LOAD_SYMBOL(dlaswp_)
  LOAD_SYMBOL(dlasv2_)
  LOAD_SYMBOL(dlasyf_)
  LOAD_SYMBOL(dlasy2_)
  LOAD_SYMBOL(dlatdf_)
  LOAD_SYMBOL(dlatbs_)
  LOAD_SYMBOL(dlatrd_)
  LOAD_SYMBOL(dlatps_)
  LOAD_SYMBOL(dlatrz_)
  LOAD_SYMBOL(dlatrs_)
  LOAD_SYMBOL(dlauu2_)
  LOAD_SYMBOL(dlatzm_)
  // LOAD_SYMBOL(dlazq3_)
  LOAD_SYMBOL(dlauum_)
  LOAD_SYMBOL(dopgtr_)
  // LOAD_SYMBOL(dlazq4_)
  LOAD_SYMBOL(dorg2l_)
  LOAD_SYMBOL(dopmtr_)
  LOAD_SYMBOL(dorgbr_)
  LOAD_SYMBOL(dorg2r_)
  LOAD_SYMBOL(dorgl2_)
  LOAD_SYMBOL(dorghr_)
  LOAD_SYMBOL(dorgql_)
  LOAD_SYMBOL(dorglq_)
  LOAD_SYMBOL(dorgr2_)
  LOAD_SYMBOL(dorgqr_)
  LOAD_SYMBOL(dorgtr_)
  LOAD_SYMBOL(dorgrq_)
  LOAD_SYMBOL(dorm2r_)
  LOAD_SYMBOL(dorm2l_)
  LOAD_SYMBOL(dormhr_)
  LOAD_SYMBOL(dormbr_)
  LOAD_SYMBOL(dormlq_)
  LOAD_SYMBOL(dorml2_)
  LOAD_SYMBOL(dormqr_)
  LOAD_SYMBOL(dormql_)
  LOAD_SYMBOL(dormr3_)
  LOAD_SYMBOL(dormr2_)
  LOAD_SYMBOL(dormrz_)
  LOAD_SYMBOL(dormrq_)
  LOAD_SYMBOL(dpbcon_)
  LOAD_SYMBOL(dormtr_)
  LOAD_SYMBOL(dpbrfs_)
  LOAD_SYMBOL(dpbequ_)
  LOAD_SYMBOL(dpbsv_)
  LOAD_SYMBOL(dpbstf_)
  LOAD_SYMBOL(dpbtf2_)
  LOAD_SYMBOL(dpbsvx_)
  LOAD_SYMBOL(dpbtrs_)
  LOAD_SYMBOL(dpbtrf_)
  LOAD_SYMBOL(dpoequ_)
  LOAD_SYMBOL(dpocon_)
  LOAD_SYMBOL(dposv_)
  LOAD_SYMBOL(dporfs_)
  LOAD_SYMBOL(dpotf2_)
  LOAD_SYMBOL(dposvx_)
  LOAD_SYMBOL(dpotri_)
  LOAD_SYMBOL(dpotrf_)
  LOAD_SYMBOL(dppcon_)
  LOAD_SYMBOL(dpotrs_)
  LOAD_SYMBOL(dpprfs_)
  LOAD_SYMBOL(dppequ_)
  LOAD_SYMBOL(dppsvx_)
  LOAD_SYMBOL(dppsv_)
  LOAD_SYMBOL(dpptri_)
  LOAD_SYMBOL(dpptrf_)
  LOAD_SYMBOL(dptcon_)
  LOAD_SYMBOL(dpptrs_)
  LOAD_SYMBOL(dptrfs_)
  LOAD_SYMBOL(dpteqr_)
  LOAD_SYMBOL(dptsvx_)
  LOAD_SYMBOL(dptsv_)
  LOAD_SYMBOL(dpttrs_)
  LOAD_SYMBOL(dpttrf_)
  LOAD_SYMBOL(drscl_)
  LOAD_SYMBOL(dptts2_)
  LOAD_SYMBOL(dsbevd_)
  LOAD_SYMBOL(dsbev_)
  LOAD_SYMBOL(dsbgst_)
  LOAD_SYMBOL(dsbevx_)
  LOAD_SYMBOL(dsbgvd_)
  LOAD_SYMBOL(dsbgv_)
  LOAD_SYMBOL(dsbtrd_)
  LOAD_SYMBOL(dsbgvx_)
  LOAD_SYMBOL(dspcon_)
  LOAD_SYMBOL(dsgesv_)
  LOAD_SYMBOL(dspevd_)
  LOAD_SYMBOL(dspev_)
  LOAD_SYMBOL(dspgst_)
  LOAD_SYMBOL(dspevx_)
  LOAD_SYMBOL(dspgvd_)
  LOAD_SYMBOL(dspgv_)
  LOAD_SYMBOL(dsprfs_)
  LOAD_SYMBOL(dspgvx_)
  LOAD_SYMBOL(dspsvx_)
  LOAD_SYMBOL(dspsv_)
  LOAD_SYMBOL(dsptrf_)
  LOAD_SYMBOL(dsptrd_)
  LOAD_SYMBOL(dsptrs_)
  LOAD_SYMBOL(dsptri_)
  LOAD_SYMBOL(dstedc_)
  LOAD_SYMBOL(dstebz_)
  LOAD_SYMBOL(dstein_)
  LOAD_SYMBOL(dstegr_)
  LOAD_SYMBOL(dsteqr_)
  LOAD_SYMBOL(dstemr_)
  LOAD_SYMBOL(dstev_)
  LOAD_SYMBOL(dsterf_)
  LOAD_SYMBOL(dstevr_)
  LOAD_SYMBOL(dstevd_)
  LOAD_SYMBOL(dsycon_)
  LOAD_SYMBOL(dstevx_)
  LOAD_SYMBOL(dsyevd_)
  LOAD_SYMBOL(dsyev_)
  LOAD_SYMBOL(dsyevx_)
  LOAD_SYMBOL(dsyevr_)
  LOAD_SYMBOL(dsygst_)
  LOAD_SYMBOL(dsygs2_)
  LOAD_SYMBOL(dsygvd_)
  LOAD_SYMBOL(dsygv_)
  LOAD_SYMBOL(dsyrfs_)
  LOAD_SYMBOL(dsygvx_)
  LOAD_SYMBOL(dsysvx_)
  LOAD_SYMBOL(dsysv_)
  LOAD_SYMBOL(dsytf2_)
  LOAD_SYMBOL(dsytd2_)
  LOAD_SYMBOL(dsytrf_)
  LOAD_SYMBOL(dsytrd_)
  LOAD_SYMBOL(dsytrs_)
  LOAD_SYMBOL(dsytri_)
  LOAD_SYMBOL(dtbrfs_)
  LOAD_SYMBOL(dtbcon_)
  LOAD_SYMBOL(dtgevc_)
  LOAD_SYMBOL(dtbtrs_)
  LOAD_SYMBOL(dtgexc_)
  LOAD_SYMBOL(dtgex2_)
  LOAD_SYMBOL(dtgsja_)
  LOAD_SYMBOL(dtgsen_)
  LOAD_SYMBOL(dtgsy2_)
  LOAD_SYMBOL(dtgsna_)
  LOAD_SYMBOL(dtpcon_)
  LOAD_SYMBOL(dtgsyl_)
  LOAD_SYMBOL(dtptri_)
  LOAD_SYMBOL(dtprfs_)
  LOAD_SYMBOL(dtrcon_)
  LOAD_SYMBOL(dtptrs_)
  LOAD_SYMBOL(dtrexc_)
  LOAD_SYMBOL(dtrevc_)
  LOAD_SYMBOL(dtrsen_)
  LOAD_SYMBOL(dtrrfs_)
  LOAD_SYMBOL(dtrsyl_)
  LOAD_SYMBOL(dtrsna_)
  LOAD_SYMBOL(dtrtri_)
  LOAD_SYMBOL(dtrti2_)
  LOAD_SYMBOL(dtzrqf_)
  LOAD_SYMBOL(dtrtrs_)
  LOAD_SYMBOL(ieeeck_)
  LOAD_SYMBOL(dtzrzf_)
  LOAD_SYMBOL(ilaver_)
  LOAD_SYMBOL(ilaenv_)
  LOAD_SYMBOL(lsamen_)
  LOAD_SYMBOL(iparmq_)
  LOAD_SYMBOL(sbdsqr_)
  LOAD_SYMBOL(sbdsdc_)
  LOAD_SYMBOL(sgbbrd_)
  LOAD_SYMBOL(sdisna_)
  LOAD_SYMBOL(sgbequ_)
  LOAD_SYMBOL(sgbcon_)
  LOAD_SYMBOL(sgbsv_)
  LOAD_SYMBOL(sgbrfs_)
  LOAD_SYMBOL(sgbtf2_)
  LOAD_SYMBOL(sgbsvx_)
  LOAD_SYMBOL(sgbtrs_)
  LOAD_SYMBOL(sgbtrf_)
  LOAD_SYMBOL(sgebal_)
  LOAD_SYMBOL(sgebak_)
  LOAD_SYMBOL(sgebrd_)
  LOAD_SYMBOL(sgebd2_)
  LOAD_SYMBOL(sgeequ_)
  LOAD_SYMBOL(sgecon_)
  // LOAD_SYMBOL(sgeesx_)
  // LOAD_SYMBOL(sgees_)
  LOAD_SYMBOL(sgeevx_)
  LOAD_SYMBOL(sgeev_)
  LOAD_SYMBOL(sgegv_)
  LOAD_SYMBOL(sgegs_)
  LOAD_SYMBOL(sgehrd_)
  LOAD_SYMBOL(sgehd2_)
  LOAD_SYMBOL(sgelqf_)
  LOAD_SYMBOL(sgelq2_)
  LOAD_SYMBOL(sgelsd_)
  LOAD_SYMBOL(sgels_)
  LOAD_SYMBOL(sgelsx_)
  LOAD_SYMBOL(sgelss_)
  LOAD_SYMBOL(sgeql2_)
  LOAD_SYMBOL(sgelsy_)
  LOAD_SYMBOL(sgeqp3_)
  LOAD_SYMBOL(sgeqlf_)
  LOAD_SYMBOL(sgeqr2_)
  LOAD_SYMBOL(sgeqpf_)
  LOAD_SYMBOL(sgerfs_)
  LOAD_SYMBOL(sgeqrf_)
  LOAD_SYMBOL(sgerqf_)
  LOAD_SYMBOL(sgerq2_)
  LOAD_SYMBOL(sgesdd_)
  LOAD_SYMBOL(sgesc2_)
  LOAD_SYMBOL(sgesvd_)
  LOAD_SYMBOL(sgesv_)
  LOAD_SYMBOL(sgetc2_)
  LOAD_SYMBOL(sgesvx_)
  LOAD_SYMBOL(sgetrf_)
  LOAD_SYMBOL(sgetf2_)
  LOAD_SYMBOL(sgetrs_)
  LOAD_SYMBOL(sgetri_)
  LOAD_SYMBOL(sggbal_)
  LOAD_SYMBOL(sggbak_)
  // LOAD_SYMBOL(sggesx_)
  // LOAD_SYMBOL(sgges_)
  LOAD_SYMBOL(sggevx_)
  LOAD_SYMBOL(sggev_)
  LOAD_SYMBOL(sgghrd_)
  LOAD_SYMBOL(sggglm_)
  LOAD_SYMBOL(sggqrf_)
  LOAD_SYMBOL(sgglse_)
  LOAD_SYMBOL(sggsvd_)
  LOAD_SYMBOL(sggrqf_)
  LOAD_SYMBOL(sgtcon_)
  LOAD_SYMBOL(sggsvp_)
  LOAD_SYMBOL(sgtsv_)
  LOAD_SYMBOL(sgtrfs_)
  LOAD_SYMBOL(sgttrf_)
  LOAD_SYMBOL(sgtsvx_)
  LOAD_SYMBOL(sgtts2_)
  LOAD_SYMBOL(sgttrs_)
  LOAD_SYMBOL(shsein_)
  LOAD_SYMBOL(shgeqz_)
  LOAD_SYMBOL(sisnan_)
  LOAD_SYMBOL(shseqr_)
  LOAD_SYMBOL(slabrd_)
  LOAD_SYMBOL(slabad_)
  LOAD_SYMBOL(slacon_)
  LOAD_SYMBOL(slacn2_)
  LOAD_SYMBOL(sladiv_)
  LOAD_SYMBOL(slacpy_)
  LOAD_SYMBOL(slaebz_)
  LOAD_SYMBOL(slae2_)
  LOAD_SYMBOL(slaed1_)
  LOAD_SYMBOL(slaed0_)
  LOAD_SYMBOL(slaed3_)
  LOAD_SYMBOL(slaed2_)
  LOAD_SYMBOL(slaed5_)
  LOAD_SYMBOL(slaed4_)
  LOAD_SYMBOL(slaed7_)
  LOAD_SYMBOL(slaed6_)
  LOAD_SYMBOL(slaed9_)
  LOAD_SYMBOL(slaed8_)
  LOAD_SYMBOL(slaein_)
  LOAD_SYMBOL(slaeda_)
  LOAD_SYMBOL(slaexc_)
  LOAD_SYMBOL(slaev2_)
  LOAD_SYMBOL(slag2d_)
  LOAD_SYMBOL(slag2_)
  LOAD_SYMBOL(slagtf_)
  LOAD_SYMBOL(slags2_)
  LOAD_SYMBOL(slagts_)
  LOAD_SYMBOL(slagtm_)
  LOAD_SYMBOL(slahqr_)
  LOAD_SYMBOL(slagv2_)
  LOAD_SYMBOL(slahrd_)
  LOAD_SYMBOL(slahr2_)
  LOAD_SYMBOL(slaisnan_)
  LOAD_SYMBOL(slaic1_)
  LOAD_SYMBOL(slals0_)
  LOAD_SYMBOL(slaln2_)
  LOAD_SYMBOL(slalsd_)
  LOAD_SYMBOL(slalsa_)
  LOAD_SYMBOL(slaneg_)
  LOAD_SYMBOL(slamrg_)
  LOAD_SYMBOL(slange_)
  LOAD_SYMBOL(slangb_)
  LOAD_SYMBOL(slanhs_)
  LOAD_SYMBOL(slangt_)
  LOAD_SYMBOL(slansp_)
  LOAD_SYMBOL(slansb_)
  LOAD_SYMBOL(slansy_)
  LOAD_SYMBOL(slanst_)
  LOAD_SYMBOL(slantp_)
  LOAD_SYMBOL(slantb_)
  LOAD_SYMBOL(slanv2_)
  LOAD_SYMBOL(slantr_)
  LOAD_SYMBOL(slapmt_)
  LOAD_SYMBOL(slapll_)
  LOAD_SYMBOL(slapy3_)
  LOAD_SYMBOL(slapy2_)
  LOAD_SYMBOL(slaqge_)
  LOAD_SYMBOL(slaqgb_)
  LOAD_SYMBOL(slaqps_)
  LOAD_SYMBOL(slaqp2_)
  LOAD_SYMBOL(slaqr1_)
  LOAD_SYMBOL(slaqr0_)
  LOAD_SYMBOL(slaqr3_)
  LOAD_SYMBOL(slaqr2_)
  LOAD_SYMBOL(slaqr5_)
  LOAD_SYMBOL(slaqr4_)
  LOAD_SYMBOL(slaqsp_)
  LOAD_SYMBOL(slaqsb_)
  LOAD_SYMBOL(slaqtr_)
  LOAD_SYMBOL(slaqsy_)
  LOAD_SYMBOL(slar2v_)
  LOAD_SYMBOL(slar1v_)
  LOAD_SYMBOL(slarfb_)
  LOAD_SYMBOL(slarf_)
  LOAD_SYMBOL(slarft_)
  LOAD_SYMBOL(slarfg_)
  LOAD_SYMBOL(slargv_)
  LOAD_SYMBOL(slarfx_)
  LOAD_SYMBOL(slarra_)
  LOAD_SYMBOL(slarnv_)
  LOAD_SYMBOL(slarrc_)
  LOAD_SYMBOL(slarrb_)
  LOAD_SYMBOL(slarre_)
  LOAD_SYMBOL(slarrd_)
  LOAD_SYMBOL(slarrj_)
  LOAD_SYMBOL(slarrf_)
  LOAD_SYMBOL(slarrk_)
  LOAD_SYMBOL(slarrr_)
  LOAD_SYMBOL(slarrv_)
  LOAD_SYMBOL(slartg_)
  LOAD_SYMBOL(slartv_)
  LOAD_SYMBOL(slaruv_)
  LOAD_SYMBOL(slarz_)
  LOAD_SYMBOL(slarzb_)
  LOAD_SYMBOL(slarzt_)
  LOAD_SYMBOL(slas2_)
  LOAD_SYMBOL(slascl_)
  LOAD_SYMBOL(slasd0_)
  LOAD_SYMBOL(slasd1_)
  LOAD_SYMBOL(slasd2_)
  LOAD_SYMBOL(slasd3_)
  LOAD_SYMBOL(slasd4_)
  LOAD_SYMBOL(slasd5_)
  LOAD_SYMBOL(slasd6_)
  LOAD_SYMBOL(slasd7_)
  LOAD_SYMBOL(slasd8_)
  LOAD_SYMBOL(slasda_)
  LOAD_SYMBOL(slasdq_)
  LOAD_SYMBOL(slasdt_)
  LOAD_SYMBOL(slaset_)
  LOAD_SYMBOL(slasq1_)
  LOAD_SYMBOL(slasq2_)
  LOAD_SYMBOL(slasq3_)
  LOAD_SYMBOL(slasq4_)
  LOAD_SYMBOL(slasq5_)
  LOAD_SYMBOL(slasq6_)
  LOAD_SYMBOL(slasr_)
  LOAD_SYMBOL(slasrt_)
  LOAD_SYMBOL(slassq_)
  LOAD_SYMBOL(slasv2_)
  LOAD_SYMBOL(slaswp_)
  LOAD_SYMBOL(slasy2_)
  LOAD_SYMBOL(slasyf_)
  LOAD_SYMBOL(slatbs_)
  LOAD_SYMBOL(slatdf_)
  LOAD_SYMBOL(slatps_)
  LOAD_SYMBOL(slatrd_)
  LOAD_SYMBOL(slatrs_)
  LOAD_SYMBOL(slatrz_)
  LOAD_SYMBOL(slatzm_)
  LOAD_SYMBOL(slauu2_)
  LOAD_SYMBOL(slauum_)
  // LOAD_SYMBOL(slazq3_)
  // LOAD_SYMBOL(slazq4_)
  LOAD_SYMBOL(sopgtr_)
  LOAD_SYMBOL(sopmtr_)
  LOAD_SYMBOL(sorg2l_)
  LOAD_SYMBOL(sorg2r_)
  LOAD_SYMBOL(sorgbr_)
  LOAD_SYMBOL(sorghr_)
  LOAD_SYMBOL(sorgl2_)
  LOAD_SYMBOL(sorglq_)
  LOAD_SYMBOL(sorgql_)
  LOAD_SYMBOL(sorgqr_)
  LOAD_SYMBOL(sorgr2_)
  LOAD_SYMBOL(sorgrq_)
  LOAD_SYMBOL(sorgtr_)
  LOAD_SYMBOL(sorm2l_)
  LOAD_SYMBOL(sorm2r_)
  LOAD_SYMBOL(sormbr_)
  LOAD_SYMBOL(sormhr_)
  LOAD_SYMBOL(sorml2_)
  LOAD_SYMBOL(sormlq_)
  LOAD_SYMBOL(sormql_)
  LOAD_SYMBOL(sormqr_)
  LOAD_SYMBOL(sormr2_)
  LOAD_SYMBOL(sormr3_)
  LOAD_SYMBOL(sormrq_)
  LOAD_SYMBOL(sormrz_)
  LOAD_SYMBOL(sormtr_)
  LOAD_SYMBOL(spbcon_)
  LOAD_SYMBOL(spbequ_)
  LOAD_SYMBOL(spbrfs_)
  LOAD_SYMBOL(spbstf_)
  LOAD_SYMBOL(spbsv_)
  LOAD_SYMBOL(spbsvx_)
  LOAD_SYMBOL(spbtf2_)
  LOAD_SYMBOL(spbtrf_)
  LOAD_SYMBOL(spbtrs_)
  LOAD_SYMBOL(spocon_)
  LOAD_SYMBOL(spoequ_)
  LOAD_SYMBOL(sporfs_)
  LOAD_SYMBOL(sposv_)
  LOAD_SYMBOL(sposvx_)
  LOAD_SYMBOL(spotf2_)
  LOAD_SYMBOL(spotrf_)
  LOAD_SYMBOL(spotri_)
  LOAD_SYMBOL(spotrs_)
  LOAD_SYMBOL(sppcon_)
  LOAD_SYMBOL(sppequ_)
  LOAD_SYMBOL(spprfs_)
  LOAD_SYMBOL(sppsv_)
  LOAD_SYMBOL(sppsvx_)
  LOAD_SYMBOL(spptrf_)
  LOAD_SYMBOL(spptri_)
  LOAD_SYMBOL(spptrs_)
  LOAD_SYMBOL(sptcon_)
  LOAD_SYMBOL(spteqr_)
  LOAD_SYMBOL(sptrfs_)
  LOAD_SYMBOL(sptsv_)
  LOAD_SYMBOL(sptsvx_)
  LOAD_SYMBOL(spttrf_)
  LOAD_SYMBOL(spttrs_)
  LOAD_SYMBOL(sptts2_)
  LOAD_SYMBOL(srscl_)
  LOAD_SYMBOL(ssbev_)
  LOAD_SYMBOL(ssbevd_)
  LOAD_SYMBOL(ssbevx_)
  LOAD_SYMBOL(ssbgst_)
  LOAD_SYMBOL(ssbgv_)
  LOAD_SYMBOL(ssbgvd_)
  LOAD_SYMBOL(ssbgvx_)
  LOAD_SYMBOL(ssbtrd_)
  LOAD_SYMBOL(sspcon_)
  LOAD_SYMBOL(sspev_)
  LOAD_SYMBOL(sspevd_)
  LOAD_SYMBOL(sspevx_)
  LOAD_SYMBOL(sspgst_)
  LOAD_SYMBOL(sspgv_)
  LOAD_SYMBOL(sspgvd_)
  LOAD_SYMBOL(sspgvx_)
  LOAD_SYMBOL(ssprfs_)
  LOAD_SYMBOL(sspsv_)
  LOAD_SYMBOL(sspsvx_)
  LOAD_SYMBOL(ssptrd_)
  LOAD_SYMBOL(ssptrf_)
  LOAD_SYMBOL(ssptri_)
  LOAD_SYMBOL(ssptrs_)
  LOAD_SYMBOL(sstebz_)
  LOAD_SYMBOL(sstedc_)
  LOAD_SYMBOL(sstegr_)
  LOAD_SYMBOL(sstein_)
  LOAD_SYMBOL(sstemr_)
  LOAD_SYMBOL(ssteqr_)
  LOAD_SYMBOL(ssterf_)
  LOAD_SYMBOL(sstev_)
  LOAD_SYMBOL(sstevd_)
  LOAD_SYMBOL(sstevr_)
  LOAD_SYMBOL(sstevx_)
  LOAD_SYMBOL(ssycon_)
  LOAD_SYMBOL(ssyev_)
  LOAD_SYMBOL(ssyevd_)
  LOAD_SYMBOL(ssyevr_)
  LOAD_SYMBOL(ssyevx_)
  LOAD_SYMBOL(ssygs2_)
  LOAD_SYMBOL(ssygst_)
  LOAD_SYMBOL(ssygv_)
  LOAD_SYMBOL(ssygvd_)
  LOAD_SYMBOL(ssygvx_)
  LOAD_SYMBOL(ssyrfs_)
  LOAD_SYMBOL(ssysv_)
  LOAD_SYMBOL(ssysvx_)
  LOAD_SYMBOL(ssytd2_)
  LOAD_SYMBOL(ssytf2_)
  LOAD_SYMBOL(ssytrd_)
  LOAD_SYMBOL(ssytrf_)
  LOAD_SYMBOL(ssytri_)
  LOAD_SYMBOL(ssytrs_)
  LOAD_SYMBOL(stbcon_)
  LOAD_SYMBOL(stbrfs_)
  LOAD_SYMBOL(stbtrs_)
  LOAD_SYMBOL(stgevc_)
  LOAD_SYMBOL(stgex2_)
  LOAD_SYMBOL(stgexc_)
  LOAD_SYMBOL(stgsen_)
  LOAD_SYMBOL(stgsja_)
  LOAD_SYMBOL(stgsna_)
  LOAD_SYMBOL(stgsy2_)
  LOAD_SYMBOL(stgsyl_)
  LOAD_SYMBOL(stpcon_)
  LOAD_SYMBOL(stprfs_)
  LOAD_SYMBOL(stptri_)
  LOAD_SYMBOL(stptrs_)
  LOAD_SYMBOL(strcon_)
  LOAD_SYMBOL(strevc_)
  LOAD_SYMBOL(strexc_)
  LOAD_SYMBOL(strrfs_)
  LOAD_SYMBOL(strsen_)
  LOAD_SYMBOL(strsna_)
  LOAD_SYMBOL(strsyl_)
  LOAD_SYMBOL(strti2_)
  LOAD_SYMBOL(strtri_)
  LOAD_SYMBOL(strtrs_)
  LOAD_SYMBOL(stzrqf_)
  LOAD_SYMBOL(stzrzf_)
  LOAD_SYMBOL(dlamch_)
  // LOAD_SYMBOL(dlamc1_)
  // LOAD_SYMBOL(dlamc2_)
  LOAD_SYMBOL(dlamc3_)
  // LOAD_SYMBOL(dlamc4_)
  // LOAD_SYMBOL(dlamc5_)
  LOAD_SYMBOL(dsecnd_)
  LOAD_SYMBOL(lsame_)
  LOAD_SYMBOL(second_)
  LOAD_SYMBOL(slamch_)
  // LOAD_SYMBOL(slamc1_)
  // LOAD_SYMBOL(slamc2_)
  LOAD_SYMBOL(slamc3_)
  // LOAD_SYMBOL(slamc4_)
  // LOAD_SYMBOL(slamc5_)

#undef LOAD_SYMBOL

  return JNI_VERSION_1_6;
}

void JNI_OnUnload(UNUSED JavaVM *vm, UNUSED void *reserved) {
  dlclose(lapack);
}
